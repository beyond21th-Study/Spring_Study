[ week10 Spring Study, AOP ]

{ 프록시와 프록시 패턴, 데코레이터 패턴 }
- 단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전형적인 전략 패턴을 사용하면된다.
- 트랜잭션 기능에는 추상화 작업을 통해 전략 패턴이 적용되어있지만 기능의 구현 내용만 분리했을 뿐.
- 아래 그림은 부가적인 기능을 위임을 통해 외부로 분리했을때이다(비즈니스 로직과 성격이 다르기때문에 분리 가능).
￼



- 아래 그림처럼 핵심 코드가 담긴 클래스에서 독립시키고, UseServiceTx를 만들었고, 트랜잭션 관련 코드가 남지 않는다.

￼
- 분리된 부가기능을 담은 클래스의 중요한 특징
    * 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야함.
    * 핵심기능은 부가기능을 가진 클래스의 존재를 모른다. —> 그래서 부가기능이 핵심기능을 사용하는 구조가 된다.
    * 문제는 핵심기능을 직접 사용하면 부가기능 적용 기회 날라감 ㅠ
    * 그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 핵심기능을 사용하도록 해야함.
        * 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록!
    * 그러기 위해선 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 해야하고, 부가기능 자신도 같은 인터페이스 구현한 뒤 자신이 그 사이에 끼어들어야함.(아래그림처럼)
￼
- 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 프록시(Proxy)라고 부름.
- 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 타깃 또는 실체라고 부른다.
￼
- 프록시 특징
    * 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것.

- 프록시 사용목적에 따른 구분
    * 1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위함.
    * 2. 타깃에 부가적인 기능을 부여해주기 위함.
* 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만 목적에 따라 디장니 패턴에서는 다른 패턴으로 구문.





{ 데코레이터 패턴 }
* 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴을 말함.
* 컴파일 시점, 즉 코드상에는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻.
* 이름의 유래 : 제품이나 케잌 등을 여러 겹으로 포장하고 그 위에 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있기 때문.
    * 그래서 프록시가 꼭 한개로 제한되지 않음. 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없음.
    * 프록시가 여러 개인 만큼 순서를 정해 단계적으로 위임하는 구조로 만들면 된다.
￼
* 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못함. 그래서 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시 주입 받을 수 있게 해야된다.



* InputStream이라는 인터페이스를 구현한 타깃 FileInputStream에 버퍼 읽기 기능을 제공해주는 BufferedInputStream이라는 데코레이터를 적용한 예다.
￼



* UserService 인터페이스를 구현한 타깃인 UserServiceImpl에 트랜잭션 부가기능을 제공해주는 UserServiceTx를 추가한 것도 데코패턴 적용임.
    * 이 경우는 수정자 메소드를 이용해 데코레이터인 UserServiceTx에 위임할 타깃인 UserServiceImpl을 주입했다.

* 인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링의 DI를 이용하면 편리함.
* 데코레이터 빈의 프로퍼티로 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면된다.
￼
￼






{ 프록시 패턴 }
* 일반적인 프록시와 디자인 패턴의 프록시 패턴은 구분할 필요가 있음.
* 전자
    * 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법을 총칭한다.
* 후자
    * 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가짐.

* 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.


* 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않으면 필요시점까지 오브젝트를 생성하지 않는 편이 좋다.

* BUT 타깃 옵젝에 대한 레퍼런스가 미리 필요할 때가 있는데 이럴 때 프록시 패턴을 적용하면 됨.
    * 예를 들어, 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다. 
    * 그리고 프록시의메소드를 통해 타깃을 사용하려고 시도하면, 그때 프록시가 타깃 옵젝을 생성하고 요청을 위임하는 방식

* 또한 원격 옵젝을 이용할때도 프록시 사용 good.
    * 마치 로컬처럼 사용할 수 있기 때문.

* 특별한 상황에서 타깃에 대한 접근권한을 제어하기 위해 프록시 패턴을 사용할 수 있음.
* 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것이다.
    * 구조만보면 프록시와 데코레이터는 유사하지만, 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음.

    * 생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야하기 때문에 타깃 클래스에 대한 직접적인 정보 알아야됨.

    * BUT 인터페이스를 통해서도 위임 가능. 
        * 아래 그림처럼 접근 제어를 두고 다른 데코레이터를 추가하는 방식도 있다.
￼



- 다이내믹 프록시
* 많은 개발자들은 프록시를 귀찮다 느낌. Why? 타깃 코드를 직접 고치지 번거롭게 프록시 만들기 기챠나ㅏ~~~~
    * 매번 새로운 클래스, 이넡페이스에는 모든 메소드 일일이 구현해서 위임 해야되서 ㅠㅠ

* 목 옵젝을 만들땐 목 프레임워크를 사용해 편하게 바꿨음. -> 프록시도 그렇게 할래ㅠㅠ 해보자!
    * 일일이 프록시 클래스를 정의 X, 몇가지 API를 이용해 프로시처럼 도앚ㄱ하는 옵젝을 다이내믹하게 만들면돼~


- 프록시의 구성과 프록시 작성의 문제점
* 프록시는 다음의 두가지 기능으로 구성됨.
    * 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 옵젝으로 위임함.
    * 지정된 요청에 대해서는 부가기능을 수행.

* 우리가 위에서 만든 UserServiceTx는 기능 부가를 위한 프록시임.
￼
￼

* 위의 UserServiceRx처럼 프록시의 역할은 위임과 부가작업 두가지로 구분가능.


* 하지만 프록시를 만들기 번거로운 이유는?
    * 1. 
        * 타깃의 인터페이스를 구현하고 위임하는 코드 작성 번거로움.
        * 부가기능 없는 메소드도 구현해서 타깃으로 위임하는 코드를 일일이 만들어줘야됨.
        * 양이 많아지면 부담스러움.
        * 타깃 이터페이스의 메소드가 추가되거나 변경될 때마다 함께 수정해줘야됨.

    * 2.
        * 부가기능 코드가 중복될 가능성 많음.
        * 메스드 많아지고 트랜잭션 적용 비율이 높아지면 유사한 코드들의 메소드가 중복되서 나타날거임.

* 이런 문제들의 해결로 유용한게 바로바로 JDK의 다이내믹 프록시!!!!



- 리플렉션
* 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만듦.
* 즉, 자바의 코드 자체를 추상화해서 접근하도록 만든 것!

* 자바의 모든 클래스는 Class 타입의 오브젝트를 하나씩 갖고 있다. 이름, 어떤 클래스를 상속, 인터페이스 구현, 필드, 어떤 메소드를 정의했는지 파라미터와 리턴 타입은 무엇인지 알아낼 수 있음.

* 만약 String의 length() 메소드라면 아래 그림처럼하면된다.
￼
* length라는 이름을 가지고 있고, 파라미터 없는 메소드의 정보를 가져온다.

￼
* 특정 오브젝트를 실행시킬땐 Method 인터페이스에 정의된 invoke() 메소드를 사용하면된다.
* invoke()메소드는 실행시킬 대상(object)와 파라미터 목록(args)



{ 리플렉션 } 

* 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만드는데 자바의 코드 자체를 추상화해서 접근하도록 만든다.
* 리플렉션 API 중에서 메소드에 대한 정의를 담은 Method라는 인터페이스를 이용해 메소드 호출방법을 알아보자면
￼
* 특정 오브젝트의 메소드를 실행시킬 수 있다.
* 특정 오브젝트의 메소드를 실행시키려면 Method 인터페이스에 정의된 invoke() 메소드를 사용하면된다.

* 실행시킬 object와 파라미터 목록으로 메소드 호출 후 결과를 Object 타입으로 돌려줌.
￼



* Method를 이용해 메소드를 호출하는 방법을 익힉기 위한 학습테스트이다.
￼
* String 클래스의 length() 메소드와 charAt() 메소드를 코드에서 직접 호출하는 방법과, Method를 이용해 리플렉션 방식으로 호출하는 방식을 비교한 것.







{ 프록시 클래스 }
* 프록시를 적용할 타깃 클래스와 인터페이스 정의.
￼


* 타깃 클래스
￼


* 인터페이스를 통해 HelloTarget 옵젝을 사용하는 클라이언트 역할을 하는 간단 테스트.
￼
￼


* 프록시는 Hello 인터페이스를 구현하고, Hello 타입의 타깃 오브젝트를 받아서 저장한다.
* Hello 인터페이스 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤에 결과를 대문자로 바꿘주는 부가 기능을 적용하고 리턴한다.
* 위임과 기능 부가라는 두 가지 프록시의 기능을 모두 처리하는 전형적인 프록시 클래스다.
￼


* 테스트 코드를 추가해서 프록시 동작하는지 확인한자!
￼
* 하지만 이 프록시는 프록시 적용의 일반적인 문제점 두 가지를 모두 가지고 있따.
* 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야 하며,  부가적인 기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복되서 나타남. 






{ 다이내믹 프록시 적용 }
￼
* 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트임.
* 타깃 인터페이스와 같은 타입으로 만들어져서, 클라이언트는 다이내믹 프록시 옵젝을 타깃 인터페이스를 통해 사용할 수 있다.
* BUT 프록시가 인터페이스 구현 클래스의 옵젝은 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야함.

* 부가기능은 프록시 옵젝과 독립적으로 InvocationHandler를 구현한 오브젝트에 담는다.
* InvocationHandler 인터페이스는 메소드 한개만 가진 간단한 인터페이스다. 
￼
* 리플렉션의 Method 인터페이스를 파라미터로 받고, 메소드 호출할 때 전달되는 파라미터도 args로 받음. 
* 다이내믹 프록시 옵젝은 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 InvocationHandler 구현 오브젝트의 invoke()메소드로 넘긴다.
* 타깃 인터페이스의 모든 메소드 요청이 하나의 메소드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
￼




￼
* 다이내믹 프록시로부터 요청을 전달받으려면 InvocationHandler를 구현해야함.
* 메소드는 invoke()하나뿐. 다이내믹 프록시가 클랑이언트로 받는 모든 요청은 invoke()메소드로 전달된다. 
* 다이내믹 프록시를 통해 요청이 전달되면 리플렉션 API를 이용해 타깃 오브젝트의 메소드를 호출한다. 타깃 옵젝은 생성자를 통해 미리 전달받아두고,
* Hello 인터페이스의 모든 메소드는 결과가 String 타입이므로 메소드 호출의 결과를 String 타입으로 변환해도 안전하다.



￼
* 1. 파라미터 클래스 로더를 제공해야함. 다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것.
* 2. 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스임. 한 번에 하나 이상의 인터페이스를 구현할 수도 있다. -> 따라서 배열 사용.
* 3. 파라미터는 부가 기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 옵젝을 제공해야함. 






{ 다이내믹 프록시의 확장 }
*  인터페이스 메소드가 3개가 아니라 30개로 늘어나도? -> UppercaseHandler와 다이내믹 프록시를 생성한 코드는 손댈 것이 없다.
* 다이내믹 프록시가 만들어질 때 추가된 메소드가 자동으로 포함되고, 부가 기능은 invoke() 메소드에서 처리되기 때문.

* InvocationHandler 방식의 장점은?
    * 타깃의 종류에 상관없이도 적용 가능.
    * 재사용 가능.
￼




* InvacationHandler는 단일 메소드에서 모든 요청을 처리하기 때문에 어떤 메소드에 어떤 기능을 적용할지를 선택하는 과정이 필요할 수 있음.
* 호출하는 메소드의 이름, 파라미터의 개수와 타입, 리턴 타입 등의 정보를 가지고 부가적인 기능을 적용할 메소드를 선택할 수 있음.
* 리턴 타입뿐만 아니라 메소드의 이름도 조건으로 걸 수 있음!
* ￼




- 다이내믹 프록시를 이용한 트랜잭션 부가기능
* UserServiceTx를 다이내믹 프록시 방식으로 변경해보면. 서비스 인터페이스 메소드와 트랜잭션이 필요한 메소드마다 트랜잭션 처리 코드가 중복되서 비효율적임.
* 따라서 다이내믹 프록시와 연동해서 트랜잭션 기능을 부가해주는 InvocationHandler는 한개만 정의해도 충분.
￼
￼
* 요청을 위임할 티깃을 DI로 제공받도록함. 타깃을 저장할 변수는 Object로 선언. 따라서 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용 가능.
* 트랜잭션 추상화 인터페이스인 PlatformTransactionManager를 DI 받도록하고, 타깃 옵젝의 모든 메소드에 무조건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI 받는다.

* InvaocationHandler의 invoke()메소드 구현 방법은 UppercaseHandler에 적용했던 것과 동일.
* 타깃 옵젝 모든 메소드에 트랜잭션 적용 X 선별적으로 적용할 것이므로 적용할 대상을 선별하는 작업을 먼저 진행.
* DI 받은 이름 패턴으로 시작되는 이름을 가진 메소드 확인.
* 패턴과 일치하는 이름을 가진 메소드라면트랜잭션 적용 메소드 호출, 아니면 부가기능 없이 타깃 옵젝 메소드 호출해서 결과를 리턴.



{ TransactionHandler와 다이내믹 프록시를 이용하는 테스트 }
* UserServiceTx대신 TransactionHandler를 이용하는 다이내믹 프록시 사용하도록 수정.
￼






- 다이내믹 프록시를 위한 팩토리 빈
* TransactionHandler와 디이내믹 프록시를 스프링의 DI를 통해 사용할 수 있도록 만들어야할 차례.
* BUT 문제는 DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로는 등록할 방법 X.
* 그래서 Proxy 클래스의 newProxyInstance()라는 스태틱 팩토리 메소드를 통해서 만듦.



{ 팩토리 빈 }
* 스프링을 대신해서 옵젝의 생성로직을 담당하도록 만들어진 특별한 빈.
* 팩토리 빈 만드는 방법
    * 가장 간단한 방법은 스프링의 FactoryBean이라는 인터페이스 구현.
￼



* 빈 오브젝트로 만들어 사용하고 싶은 클래스 정의. Message 클래스는 생성자를 통해 옵젝 만들 수 없음. 만들려면 반드시 스태틱 메소드 사용해야함.
￼
* Message 클래스의 옵젝을 만드려면 newMessage()라는 스태틱 메소드를 사용해야함.
* 따라서 이 클래스를 직접 스프링 빈으로 등록해서 사용할 수 X.
* 그래서 아래그림처럼.
￼


* 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 옵젝을 만들어줌.
* 리플렉션은 private으로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문.
* BUT private로 만들어진건 중요한 이유가 있으므로 무시하고 강제로 옵젝 생성하면 위험.
* 그래서 private 생성자를 가진 클래스를 빈으로 등록은 권장 X.
￼
* 팩토리 빈은 전형적인 팩토리 메소드를 가진 옵젝. 빈의 클래스로 등록된 팩토리 빈은 빈 옵젝을 생성하는 과정에만 사용됨.




{ 팩토리 빈의 설정 방법 }
￼
* 여타 빈 설정과 다른 점은 message 빈 옵젝 타입이 class 애트리뷰트에 정의된 MessageFactoryBean이 아니라 Message 타입 이라는 것.



* 위의 설정을 FactoryBeanTest-context.xml으로 저장하고 테스트 작성.
￼
* Message ㅂ빈의 타입이 무엇인지 확실 X. 그래서 @Autowired의 타입 자동와이어링으로 message 빈을 가져오는 대신 ApplicationContext를 이용해 getBean() 메소드는 빈의 타입을 지정하지 않으면 Object 타입으로 리턴한다.




* 드물지만 팩토리 빈이 만들어주는 빈 옵젝이 아니라 팩토리 빈 자체를 가져오고 싶을떈  ‘&’를 빈 이름 앞에 붙여주면 팩토리 빈 자체를 돌려줌.
* ￼




{ 다이내믹 프록시를 만들어주는 팩토리 빈 }
￼
* 스프링 빈에는 팩토리 빈과 UserServiceImpl만 빈으로 등록함. 팩토리 빈은 다이내믹 프록시가 위임할 타깃 옵젝인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아둬야 함. 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 옵젝을 전달해줘야되기 때문.



{ 트랜잭션 프록시 팩토리 빈 }
￼
￼
* 앞에 테스트까지 해봤던 코드임.



￼
* Target, transactionManager 프로퍼티는 다른 빈을 가리켜서 ref 애트리뷰트로 설정
* pattern은 스트링으로 된 문자열이니 value 애트리뷰트를 사용해 값을 지정.
* serviceInterface는 Class타입. -> value를 이용해 클래스 또는 인터페이스 이름 넣어주면 됨.



{ 트랜잭션 프록시 팩토리 빈 테스트 }
* UserServiceTest에서 add()는 @Autowired로 가져온 userService 빈을 사용해서 TxProxyFactoryBean 팩토리 빈이 생성하는 다이내믹 프록시를 통해 UserService 기능을 사용하게 될 것이다. 
* BUT upgradeLevels()와 mockUpgradeLevels()는 목 옵젝을 이용해 비즈니스 로직에 대한 단위 테스트라서 트랜잭션과 무관함.

* 자동 생성된 트랜잭션 프록시의 타깃을 테스트용으로 교체 어려움. -> ToProxyFactoryBean을 직접 가져와 타깃을 수동으로 변경하고 @DirtiesContext로 뒤처리 하는 방식이 있다.
￼
￼
* TxProxyFactoryBean은 계속 재사용 가능. 트랜잭션 부가기능이 필요한 빈이 추가될때마다 빈 설정만 추가해주면 됨.



- 프록시 팩토리 빈 방식의 장점과 한계.
{ 프록시 팩토리 빈의 재사용 } 
* 코드 수정 없이 다양한 클래스에 적용가능. -> 타깃 옵젝에 맞는 프로퍼티 정보를 설정해서 빈으로 등록하기만 하면됨.
* 하나 이상의 ToProxyFactoryBean을 동시에 빈으로 등록해도 상관 X. -> 팩토리 빈이라서 각 빈의 타입은 타깃 인터페이스와 일치.

￼
* 트랜잭션 적용하기 전에는 위에 그림처럼 빈으로 등록해서 사용했을 것이다.


￼
* coreService 빈에 트랜잭션 기능이 필요해지면 UserService에 적용하느라 만들었던 TxProxyFactoreyBean을 그대로 적용해주면 됨.
* 이름으로 등록했던 빈 아이디를 coreServicceTarget으로 변경.

￼
* Target 프로퍼티를 coreServiceTarget 빈으로 설정해주고 serviceIngerface에는 프록시가 구현할 인터페이스인 CoreService를 넣어주면 준비 끝.
* CoreService 인터페이스에 정의된 모드 메소드에 트랜잭션 기능을 적용하려면 pattern값을 빈 문자열로 설정해주면 됨.
* 이제 coreService라는 아이디를 가진 빈을 DI 받아 사용하는 클라이언트는 코드의 변경없이 프록시가 제공해주는 트랜잭션 기능 적용가능!
￼


{ 프록시 팩토리 빈 방식의 장점 }
* 데코레이터 패턴이 적용된 프록시를 적극적 활용 못하는 두가지 문제점.
    * 1. 프록시를 적용할 대상이 구현하고 있는 인터페이스를 구현하는 프록시 클래스를 일일이 만들어야하는 번거로움.
    * 2. 부가적인 기능이 여러 메소드에 반복적으로 나타나서 코드 중복 문제.

* 팩토리 빈은 위의 두가지 문제 해결!


{ 프록시 팩토리 빈의 한계 }
* 프록시를 통해 타깃에 부가기능 제공은 메소드 단위로 일어남.
* 여러 개의 메소드에 부가기능을 한번에 제공은 가능. 여러 개의 클래스에 공통적인 부가기능 제공은 X.

* 또한 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어짐.
