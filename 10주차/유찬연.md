# 다이내믹 프록시와 팩토리

## 프록시와 프록시 패턴, 데코레이터 패턴

<img width="699" height="136" alt="{0DC663C7-9CD2-4E1D-B609-77AB31020675}" src="https://github.com/user-attachments/assets/a3d0711d-0748-4d45-b896-a7a52b591cf3" />

트랜잭션과 같은 부가 기능을 위임을 통해 외부로 분리했을 경우 구체적인 구현 코드는 제거됐지만 위임을 통해 기능을 사용하는 코드는 핵심 코드와 함께 남아 있음.

하지만 트랜잭션이라는 기능은 비즈니스 로직과 성격이 다르기 때문에 아예 그 적용 사실 자체를 밖으로 분리 가능.

<img width="703" height="144" alt="{F6415C6C-4716-4D77-9642-2DD4F4C310B1}" src="https://github.com/user-attachments/assets/2defd850-0e54-47e7-8e22-0b4249da8f51" />

위처럼 분리된 부가 기능을 담은 클래스에는 부가 기능 외의 나머지 모든 기능은 핵심 기능을 가진 클래스로 위임이 필요.

핵심 기능은 부가 기능을 가진 클래스의 존재 자체를 모르기 때문에 부가 기능이 핵심 기능을 사용하는 구조가 됨.

문제는 클라이언트가 핵심 기능을 가진 클래스를 직접 사용하면 부가 기능이 적용될 기회가 없다는 것.

그래서 부가 기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며, 클라이언트가 자신을 거쳐 핵심 기능을 사용하도록 만들어야 함.

이를 위해 클라이언트는 인터페이스를 통해서만 핵심 기능을 사용하게 하고 부가 기능 자신도 같은 인터페이스를 구현한 뒤 자신이 그 사이에 끼어들어야 함.

<img width="699" height="160" alt="{FB50095D-7729-42B1-8E80-2E0E60A30ED3}" src="https://github.com/user-attachments/assets/ec6b851b-a81c-42c8-bff0-dea04bcd8bcc" />

이렇게 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 프록시라고 함

### 데코레이터 패턴

데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 동적으로 부여해주기 위해 프록시를 사용하는 패턴

꼭 프록시가 한 개로 제한되지 않고 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없음.

같은 인터페이스를 구현한 타겟과 여러 개의 프록시를 사용 가능.

프록시가 여러 개이므로 순서를 정해 단계적으로 위임하는 구조로 만들면 됨.

<img width="699" height="161" alt="{D97929D8-76D1-4D8B-820B-87C8A91BF747}" src="https://github.com/user-attachments/assets/18200332-68f1-4854-a561-5933b7141923" />

아래 이미지는 동적 부가 기능의 부여라는 데코레이터 패턴의 전형적인 적용 예.

<img width="699" height="426" alt="{72E33E5F-E832-4C17-91F4-62C8EB766FF2}" src="https://github.com/user-attachments/assets/64a93705-d420-4b9f-b45a-7d19abb2f41e" />

데코레이터 패턴은 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결되는지 코드 레벨에서는 미리 알 수 없음.

구성하기에 따라 여러 개의 데코레이터 적용도 가능.

데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법.

### 프록시 패턴

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는 대신 클라이언트가 타깃에 접근하는 방식을 변경해줌.

프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것.

구조적으로 프록시와 데코레이터는 유사하지만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많음. (예 → 타깃 오브젝트 생성이 복잡하거나 당장 필요하지 않은 경우, 원격 오브젝트를 이용하는 경우, 특별한 상황에서 타깃에 대한 접근 권한을 제어하기 위한 경우 등)

why? 생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문.

물론 프록시 패턴을 인터페이스를 통해 위임하도록 만드는 것도 가능.

<img width="703" height="180" alt="{019E7AAB-1E04-4FDF-A3CE-054309BE220C}" src="https://github.com/user-attachments/assets/aa3da034-4064-4c7e-a0eb-c7fc70023ae5" />

## 다이내믹 프록시

프록시는 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이지만 많은 개발자들은 잘 사용하지 않음.

why? 프록시를 만드는 일이 상당히 번거롭게 느껴지기 때문.

그렇다면 프록시 편리하게 만들어서 사용할 방법이 없을까?

### 프록시의 구성과 프록시 작성의 문제점

프록시는 다음의 두 가지 기능으로 구성됨.

- 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 위임.
- 지정된 요청에 대해서는 부가 기능을 수행

<img width="700" height="765" alt="{810244FC-553D-48BA-9665-C853D2C5E0CC}" src="https://github.com/user-attachments/assets/798d1e5e-fc2f-4f8e-b977-b45cb28ae6f9" />

이전에 만들어두었던 UserServiceTx 코드는 UserService 인터페이스를 구현하고 타깃으로 요청을 위임하는 트랜잭션 부가 기능을 수행하는 코드로 구분 가능.

이렇게 프록시의 역할은 위임과 부가 작업으로 구분 가능.

그렇다면 프록시 작성이 번거로운 이유는?

1. 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기가 번거로움. 
2. 부가 기능 코드가 중복될 가능성이 많음..

첫 번째 문제점의 경우 부가 기능이 필요하지 않은 메소드도 구현하여 타깃으로 위임하는 코드를 일일이 작성해야 함. → 해결이 간단하지 않음

이를 해결하기 위해 유용한 것이 바로 JDK의 다이내믹 프록시.

### 리플렉션

다이내믹 프록시는 리플렉션 기능을 이용하여 프록시를 만들어 줌.

리플렉션이란 코드 자체를 추상화하여 접근하도록 만든 것.

자바의 모든 클래스는 클래스 자체의 구성 정보를 담은 Class 타입의 오브젝트를 하나씩 가짐.

클래스 오브젝트를 이용하면 클래스 코드에 대한 메타 정보를 가져오거나 오브젝트를 조작 가능.

<img width="701" height="586" alt="{416EAD07-5A58-4990-9033-7EF8ED0AE275}" src="https://github.com/user-attachments/assets/4f27f614-a53e-4f8a-99e6-cb702ee5258b" />

위의 예제 코드는 length() 메소드와 charAt() 메소드를 코드에서 직접 호출하는 방법과 Method(리플렉션 API 중 메소드에 대한 정의를 담은 인터페이스)를 이용해 리플렉션 방식으로 호출하는 방법을 비교한 것.

invoke () 메소드는 메소드를 실행시킬 대상 오브젝트와 파라미터 목록을 받아서 메소드를 호출한 뒤에 그 결과를 Object 타입을 반환하는 메소드.

### 프록시 클래스

다이내믹 프록시를 이용한 프록시 생성.

아래는 프록시를 적용할 간단한 타깃 클래스와 인터페이스.

<img width="703" height="626" alt="{997616B2-A440-4FD2-892B-D1A7634B71F0}" src="https://github.com/user-attachments/assets/5f0f765f-c892-4e4b-94a7-1b4f0225bce9" />

아래는 Hello 인터페이스를 구현한 프록시를 생성.

<img width="699" height="611" alt="{D3A880ED-BEC7-4D68-AFEC-97F2148A724A}" src="https://github.com/user-attachments/assets/b82a9314-04ee-4a73-adef-629ca6f27107" />

프록시에는 데코레이터 패턴을 적용하여 타깃인 HelloTarget에 부가 기능을 추가하였고 이름은 HelloUpperCase.

추가할 기능은 리턴할 문자를 모두 대문자로 바꿔주는 것.

Hello 인터페이스 구현 메소드에서는 타깃 오브젝트의 메소드를 호출한 뒤 결과를 대문자로 바꿔주는 부가 기능을 적용하고 리턴.

위임과 기능 부가라는 프록시의 두 기능을 모두 처리하는 전형적인 프록시 클래스.

이 프록시는 프록시 적용의 일반적인 문제점 두 가지를 모두 가짐.

인터페이스의 모든 메소드를 구현해 위임하도록 코드를 작성해야 하며, 부가 기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복됨.

### 다이내믹 프록시 적용

<img width="697" height="275" alt="{335FA326-9CC9-4A35-94D9-15EE12036D72}" src="https://github.com/user-attachments/assets/950831bd-86ac-4b0f-b319-5eb8cc443c98" />

다이내믹 프록시 → 프록시 팩토리에 의해 런타임 시 동적으로 만들어지는 오브젝트.

다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 타입으로 만들어 짐.

클라이언트는 다이내믹 프록시 오브젝트를 타깃 인터페이스를 통해 사용 가능.

이 덕분에 프록시를 만들 때 인터페이스를 모두 구현해가며 클래스를 정의할 필요 x.

프록시 팩토리에게 인터페이스 정보만 제공해주면 해당 인터페이스를 구현한 클래스의 오브젝트를 자동을 생성해줌.

하지만 부가 기능 제공 코드는 직접 작성해야 함.

부가 기능은 프록시 오브젝트와 독립적으로 InvocationHandler를 구현한 오브젝트에 담음.

InvocatinoHandler는 아래의 메소드를 하나만 가진 간단한 인터페이스.

<img width="698" height="67" alt="{9882740E-ADE1-442E-A9E6-F84C3D3F5AF7}" src="https://github.com/user-attachments/assets/a22a1af7-72a0-479a-85ef-1fd6ddbfde31" />

InvocationHandler 구현 오브젝트가 타깃 오브젝트 레퍼런스를 갖고 있다면 리플렉션을 이용해 간단히 위임 코드 생성 가능.

<img width="698" height="219" alt="{CAE77FF3-0B3F-4968-B79D-8435AE121B7B}" src="https://github.com/user-attachments/assets/50455553-65d7-4aff-ae28-751f4b0c84c9" />

InvocationHandler 인터페이스를 구현한 오브젝트를 제공해주면 다이내믹 프록시가 받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내줌.

Hello 인터페이스의 메소드가 아무리 많아도 invoke() 메소드 하나로 처리 가능.

<img width="695" height="391" alt="{C9360782-B131-4CDE-9CBD-3939E18FE42F}" src="https://github.com/user-attachments/assets/700216dc-a001-4a6d-a72f-6845a947d774" />

위는 다이내믹 프록시로부터 메소드 호출 정보를 받아 처리하는 InvocationHandler 구현 클래스.

모든 요청을 타깃에 위임하면서 리턴 값을 대문자로 바꿔주는 부가 기능을 가짐.

다이내믹 프록시가 클라이언트로 받는 모든 요청은 invoke() 메소드로 전달되고 invoke() 메소드는 리플렉션 API를 통해 타깃 오브젝트의 메소드를 호출.

타깃 오브젝트는 생성자를 통해 미리 전달 받음.

타깃 오브젝트의 메소드 호출이 끝났으면 프록시가 제공하려는 부가 기능인 리턴 값을 대문자로 바꾸는 작업을 수행하고 결과를 리턴.

리턴된 값은 다이내믹 프록시가 받아서 최종적으로 클라이언트에게 전달.

<img width="699" height="207" alt="{19FCF067-BE33-43B5-8A03-2F835ECD9A75}" src="https://github.com/user-attachments/assets/03e64830-deb2-4555-aac7-04dee7188ec7" />

위는 다이내믹 프록시를 생성하는 코드.

첫 번째 파라미터는 클래스 로더를 제공해야 함.

다이내믹 프록시가 클래스 로더를 지정하는 것.

두 번째 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스.

다이내믹 프록시는 한 번에 하나 이상의 인터페이스 구현이 가능하므로 인터페이스의 배열을 사용.

마지막 세 번째 파라미터로는 부가 기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 오브젝트를 제공해야 함.

리플렉션 API와 다이내믹 프록시 생성 방법을 적용했음에도 다이내믹 프록시 적용의 장점을 알기 어려움.

### 다이내믹 프록시의 확장

인터페이스의 메소드가 늘어나는 경우 다이내믹 프록시를 생성해서 사용하는 코드는 전혀 손댈 것이 없음.

why? 다이내믹 프록시가 생성도리 때 추가된 메소드가 자동으로 포함될 것이고, 부가 기능은 invoke() 메소드에서 처리되기 때문.

UppercaseHanler는 모든 메소드의 리턴 타입이 스트링이라고 가정하지만 스트링 외의 리턴 타입을 가지는 메소드가 추가될 경우 런타임 시 캐스팅 오류가 발생할 것.

리플렉션은 강한 기능을 가진 대신 주의 깊게 사용할 필요가 있음.

그래서 Method를 이용한 타깃 오브젝트의 메소드 호출 후 리턴 타입을 확인하여 스트링인 경우만 대문자로 바꿔주고 그 외에는 그대로 넘겨주는 방식으로 수정하는 것이 좋음.

InvocationHandler 방식의 또 한 가지 장점은 타깃의 종류에 상관 없이 적용이 가능하다는 점.

<img width="697" height="535" alt="{14B7708B-6265-404D-B20A-58F9A79223F1}" src="https://github.com/user-attachments/assets/e9e5c5f0-a4e1-4476-8969-6c070e5ef22c" />

InvocationHandelr는 단일 메소드에서 모든 요청을 처리하기 때문에 어떤 메소드에 어떤 기능을 적용할 지를 선택하는 과정이 필요할 수도 있음.

호출하는 메소드의 정보를 가지고 부가적인 기능을 적용할 메소드 선택 가능하며 리턴 타입 뿐만 아니라 메소드의 이름도 조건으로 걸 수 있음.

아래는 메소드의 이름이 say로 시작하는 경우에만 대문자로 바꾸는 기능을 적용한 코드.

<img width="703" height="341" alt="{5FC36344-2A6D-4209-BAA3-8F8338550720}" src="https://github.com/user-attachments/assets/e30b7a44-adcb-4a80-999e-c8add7fe80b8" />

## 다이내믹 프록시를 이용한 트랜잭션 부가기능

### 트랜잭션 InvocationHandler

<img width="219" height="351" alt="{D9DFE87B-32B0-4974-933B-4A731367559C}" src="https://github.com/user-attachments/assets/57a28b99-cbc3-447d-8d04-7f858ffb5006" />

위는 트랜잭션 부가기능을 가진 핸들러의 코드.

요청을 위임할 타깃을 DI로 제공받도록 하고 타깃을 저장할 변수는 Object로 선언.

따라서 UserServiceImpl 외 트랜잭션 적용이 필요한 어떤 타깃 오브젝트에도 적용 가능.

타깃 오브젝트의 모든 메소드에 무조건 트랜잭션이 적용되지 않도록 트랜잭션을 적용할 메소드 이름의 패턴을 DI.

간단히 시작 부분을 비교할 수 있게 작성.

invoke() 메소드를 구현하는 방법은 UppercaseHandler에 적용했던 것과 동일하게 트랜잭션을 적용할 대상을 선별하는 작업 우선 진행.

패턴과 일치하는 이름을 가진 메소드라면 트랜잭션을 적용하는 메소드를 호출하고 아니라면 부가 기능 없이 타깃 오브젝트의 메소드를 호출하여 결과를 리턴.

트랜잭션을 적용하면서 타깃 오브젝트의 메소드를 호출하는 것 역시 UserServiceTx와 동일하지만 롤백을 적용하기 위한 예외는 RuntimeException 대신 InvocationTargetException을 잡도록 해야 함.

why? 리플렉션 메소드인 Method.invoke() 를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationException으로 한 번 포장되어 전달되기 때문에 InvocationException으로 받은 후 getTargetException() 메소드로 중첩되어 있는 예외를 가져와야 함.

## 다이내믹 프록시를 위한 팩토리 빈

DI의 대상이 되는 다이내믹 프록시 오브젝트는 일반적인 스프링의 빈으로 등록할 방법이 없음.

### 팩토리 빈

사실 스프링은 클래스 정보를 가지고 디폴트 생성자를 통해 오브젝트를 만드는 방법 외에도 빈을 만들 수 있는 여러 가지 방법을 제공.

대표적으로 팩토리 빈을 이용한 빈 생성 방법이 있음.

팩토리 빈 → 스프링을 대신해서 오브젝트의 생성 로직을 담당하도록 만들어진 특별한 빈.

<img width="699" height="262" alt="{4D99CEF3-BEAF-4F02-A284-93255FDEE011}" src="https://github.com/user-attachments/assets/79e576b7-84a4-44fe-ac5b-1b75509aec79" />

FactoryBean 인터페이스는 위처럼 세 가지 메소드로 구성됨.

<img width="698" height="467" alt="{8A7C0016-9B9B-4C83-97E1-ECEDE902FFF1}" src="https://github.com/user-attachments/assets/4ef54b06-ff3e-4816-bcfe-50bcf0e6e7e3" />

Message 클래스의 오브젝트를 만들려면 newMessage() 라는 스태틱 메소드를 사용해야 함.

사실 스프링은 private 생성자를 가진 클래스도 빈으로 등록해주면 리플렉션을 이용해 오브젝트 생성 가능.

리플렉션은 private로 선언된 접근 규약을 위반할 수 있는 강력한 기능이 있기 때문.

하지만 생성자를 private로 만들었다는 것은 스태틱 메소드를 통해 오브젝트를 생성해야 하는 중요한 이유가 있기에 오브젝트를 강제로 생성하는 것은 위험.

<img width="701" height="566" alt="{A1571C10-8FD0-4D41-8873-0AD1CFF9899F}" src="https://github.com/user-attachments/assets/737a9fb0-2abd-443c-bef8-9a0d636e6194" />

위는 Message 클래스의 오브젝트를 생성해주는 팩토리 빈.

팩토리 빈은 전형적인 팩토리 메소드를 가진 오브젝트.

스프링은 FactoryBean 인터페이스를 구현한 클래스가 빈의 클래스로 지정되면, 팩토리 빈 클래스의 오브젝트의 getObject() 메소드를 이용해 오브젝트를 가져오고, 이를 빈 오브젝트로 사용.

빈의 클래스로 등록된 팩토리 빈은 빈 오브젝트를 생성하는 과정에서만 사용될 뿐임.

### 팩토리 빈의 설정 방법

<img width="697" height="172" alt="{D3CFC81D-0D79-4621-8D86-1EA364326E03}" src="https://github.com/user-attachments/assets/2757d153-4d09-4a4b-95f5-bc0b1adc719f" />

팩토리 빈의 설정은 일반 빈과 다르지 않지만 일반 빈 설정과 다른 점은 message 빈 오브젝트의 타입이 class 어트리뷰트에 정의된 MessageFactoryBean이 아닌 Message 타입이라는 것.

Message 빈의 타입은 MessageFactoryBean의 getObjectType() 메소드가 돌려주는 타입으로 결정됨.

또한 getObject() 메소드가 생성해주는 오브젝트 message 빈의 오브젝트가 됨.

### 다이내믹 프록시를 만들어주는 팩토리 빈

다이내믹 프록시 오브젝트를 팩토리 빈을 사용하여 스프링의 빈으로 만들어줄 수 있음.

팩토리 빈의 getObject() 메소드에 다이내믹 프록시 오브젝트를 만들어주는 코드를 넣으면 됨.

<img width="697" height="222" alt="{32A9E8E9-5E47-4523-AAA8-F67CCF8B6FE1}" src="https://github.com/user-attachments/assets/f601758c-1d35-4c15-b80a-82f04bd29f2f" />

스프링 빈에는 팩토리 빈과 UserServcieImpl만 빈으로 등록.

팩토리 빈은 다이내믹 프록시가 위임할 타깃 오브젝트인 UserServiceImpl에 대한 레퍼런스를 프로퍼티를 통해 DI 받아두어야 함.

why? 다이내믹 프록시와 함께 생성할 TransactionHandler에게 타깃 오브젝트를 전달해줘야 하기 때문.

## 프록시 팩토리 빈 방식의 장점과 한계

### 프록시 팩토리 빈의 재사용

TransactionHandler를 이용하는 다이내믹 프록시를 생성해주는 TxProxyFactoryBean은 코드의 수정 없이도 다양한 클래스에 적용 가능.

How? 타깃 오브젝트에 맞는 프로퍼티 정보를 설정해서 빈으로 등록해주기만 하면 됨.

UserService 외에 트랜잭션 경계 설정 기능을 부여해줄 필요가 있는 클래스의 경우 인터페이스에 정의된 수십여 개의 메소드에 트랜잭션을 모두 적용 필요.

<img width="698" height="148" alt="{1E73C15E-125C-460E-BDBA-7E31F54173F3}" src="https://github.com/user-attachments/assets/2699b274-69d2-4929-951c-dfc9e1aaf26f" />

트랜잭션을 적용하기 전에는 위와 같이 빈으로 등록해서 사용.

<img width="699" height="225" alt="{1B5DCA20-88CD-42B0-80B6-28A1B8047D2D}" src="https://github.com/user-attachments/assets/884bc1f9-3f7e-4e5f-9242-b2873b5f7034" />

이후 빈에 트랜잭션 기능이 필요해지면 기존에 적용하느라 만들었던 TxProxyFactoryBean을 그대로 적용해주면 됨.

<img width="700" height="207" alt="{775E842F-0CAA-4059-B46E-868B6137A89E}" src="https://github.com/user-attachments/assets/5ec45c0a-883c-4bff-af3e-7c4c237d7230" />

위의 이미지를 통해 설정을 변경하기 전과 후의 오브젝트 관계 확인 가능.

전에는 트랜잭션이 적용되지 않은, 비즈니스 로직만 가진 CoreServiceImpl 클래스의 빈만 존재했지만, 후에는 CoreServiceImpl의 모든 메소드에 트랜잭션 기능이 적용됨.

### 프록시 팩토리 빈 방식의 장점

프록시 팩토리 빈은 데코레이터 패턴이 적용된 프록시의 문제점을 해결해줌.

다이내믹 프록시를 이용하면 타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 제거할 수 있고, 하나의 핸들러 메소드를 구현하는 것만으로도 수많은 메소드에 부가 기능을 부여해줄 수 있으니 부가 기능 코드의 중복 문제도 사라짐.

추가로 다이내믹 프록시에 팩토리 빈을 이용한 DI까지 더해주면 다이내믹 프록시 생성 코드도 제거 가능

### 프록시 팩토리 빈의 한계

프록시를 통해 타깃에 부가 기능을 제공하는 것은 메소드 단위로 일어나는 일.

하나의 클래스 안에 존재하는 여러 개의 메소드에 부가 기능을 한 번에 제공하는 것은 어렵지 않지만, 한 번에 여러 개의 클래스에 제공하는 것은 불가능.

why? 트랜잭션과 같이 비즈니스 로직을 담은 많은 클래스의 메소드에 적용할 필요가 있다면 거의 비슷한 프록시 팩토리 빈의 설정이 중복되는 것을 막을 수 없음.

또한 하나의 타깃에 여러 개의 부가 기능을 적용하는 경우도 문제.

적용 대상인 서비스 클래스의 빈 설정 파일에 프록시 팩토리 빈 설정이 부가 기능의 개수만큼 붙음.

다른 문제점으로 TransactionHandler 오브젝트가 프록시 팩토리 빈 개수만큼 만들어 진다는 점이 있음.

TransactionHandler는 타깃 오브젝트를 프로퍼티로 가짐.

따라서 부가 기능을 제공하는 동일한 코드임에도 불구하고 타깃 오브젝트가 달라지면 새로운 TransactionHandler 오브젝트를 생성해야 함.

이러한 TransactionHandler 의 중복을 없애고 모든 타깃에 적용 가능한 싱글 톤 빈으로 만들어 적용이 가능할까?

그에 대한 대답은.. 다음 주에 계속..
