# 6.3 다이내믹 프록시와 팩토리 빈
## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

<img width="673" height="159" alt="image" src="https://github.com/user-attachments/assets/1ce72680-5f35-4f07-b52a-c445e60f2ce5" />

- 부가기능 전부를 핵심 코드가 담긴 클래스에서 독립에서 독립시킨 그림.
- 이렇게 분리된 부가기능을 담은 클래슨는 중요한 특징이 이는데, 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해 줘야 한다.
- 하지만 이렇게 구성했다고 하더라도 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.
- 그래서 부가기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐 핵심기능을 사용하도록 만들어야 한다.

<img width="681" height="164" alt="image" src="https://github.com/user-attachments/assets/960f2574-29ca-462f-ac6b-d158372c34be" />

- 부가기능 코드에서는 핵심 기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.
- 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 대표적인 경우다 (= 비즈니스(핵심기능)코드에는 손 대지 않고 그 실행 앞/뒤에 트랜잭션 시작과 종료 로직을 감싸서 추가하는 것을 의미)
- 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 '프론시'라고 부른다.
- 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를  '타깃' 또는 '실체'라고 부른다.

<img width="647" height="116" alt="image" src="https://github.com/user-attachments/assets/7160279e-93c4-430d-989a-a1729e462a26" />

- 위 그림은 클라이언트가 프록시를 통해 타깃을 사용하는 구조이다.
- 프록시의 특징은
  - 타깃과 같은 인터페이스를 구현했다는 것 (클라이언트 입장에서는 타깃과 구분되지 않음)
  - 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다. (동시에 클라이언트와 타깃 사이에 위치해, 타깃 호출을 통제하거나 부가 기능을 적용할 수 있다)
- 프록시는 사용 목적에 따라 두 가지로 구분 할 수 있다.
  - 클라이언트가 타깃에 접근하는 방법을 제어하기 위한 목적
  - 타깃에 부가적인 기능을 부여해주기 위한 목적
- 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만 목적(접근 제어인지, 기능 확장에 따라서) 디자인 패턴데서는 다른 패턴으로 구분한다.

### 데코레이터 패턴

- 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴이다.
- 다이내믹하게 기능을 부여한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에(인터페이스가 프록시와 타깃을 구분 없이 교체 가능하게 만들어, 기능을 끼워 넣을 수 있는 설계 지점을 제공하기 때문에 인터페이스로 접근) 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
<br> 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입 받을 수 있도록 만들어야 한다.


- UserServiceImpl(진짜 로직)에 UserServiceTx(트랜잭션 담당)를 덮어씌워서, 클라이언트는 트랜잭션이 적용된 서비스만 보게 했다

- UserServiceImpl : 타깃, 진짜 비즈니스 로직 있음, “회원 등급 변경”, “유저 처리” 이런 코드
<br> -> 트랜잭션 모름

- UserServiceTx : 데코레이터, 트랜잭션 시작/커밋/롤백 담당, 내부에 UserService를 하나 들고 있음
<br> -> 기능은 위임하고, 앞뒤로 트랜잭션만 붙임

<img width="1299" height="428" alt="image" src="https://github.com/user-attachments/assets/0728d94d-ac3c-49e3-b628-eaf0d99cf5b3" />

- userService라는 이름의 빈은 UserServiceTx의 객체.
<br> 그 안에 트랜잭션 매니저도 넣어주고, userServiceImpl이라는 진짜 서비스도 넣어준다.
<br> UserServiceTx가 UserServiceImpl을 감싸도록 설정한 것

"DI를 통한 다이나믹한 구성" ? : 코드를 바꾸지 않고 설정만으로 누가 누구를 감쌀지 결정했다-라는 뜻. 

- 데코레이터 패턴은 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다. (항상 타입이 UserService userService; 이거니깐)
- 여러 개의 데코레이터를 적용 할 수도, 필요하면 다른 데코레이터를 중간에 끼워 넣을 수도 있다.
- 그래서 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

### 프록시 패턴

- 프록시 : 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝틀르 두는 방법.
- 프록시 패턴 : 디자인패턴의 생성, 구현, 행위 패턴 중에서 구현 패턴 중 하나. 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우.
<br> 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다. <br> 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그대 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다. <br> 만약 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후에 사용죄는 경우라면 이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다. <br> -> 객체가 비쌀 때가 많다. DB나 네트워크를 연결하거나, 대용량 데이터를 로딩할때. -> 프록시를 쓰면 처음에는 가벼운 프록시만 생성하고 진짜 쓸 때만 타깃을 생성하니까 객체를 안 쓰면 끝까지 안 만들어진다.
<br> -> 서버 부팅을 하거나 화면에 진입할때 프록시 없으면 시작하자마자 모든 객체를 생성한다. 하지만 프록시가 있으면 역시나 필요할때만 생성하기 때문에 애플리케이션 시작 할때 빠르다.
<br> -> 메모리를 덜 쓴다.
<br> -> 클라이언트는 타깃을 쓰는 것 처럼 사용하기 때문에 코드 변경이나 조건문이 추가 되는 경우가 없다. 프록시가 뒤에서 다 처리 ㅐ준다. 결국 코드 구조는 그대로 유지된다. 결국 가짜를 먼저 주고, 진짜로 쓰는 순간에 만드는, 생성을 최대한 늦추니까 성능은 올라가고 메모리는 적게씀으로써 불필요한 생성을 방지한다.

### 6.3.2 다이내믹 프록시

- 프록시는 기존 코드에 영향을 주지않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다. 그럼에도 불구하고 많은 개발자는 타깃 코드를 직접 고치고 말지, 번거롭게 프록시를 만들고 싶어하진 않는다. 프록시를 만드는 일이 번거롭게 느껴지기 때문이다.
<br> -> 매번 새로운 클래스를 정의해야 하고, 인터페이스의 구현해야 할 메소드는, 많으면 모든 메소드를 일일이 구현해서 위임하는 코드를 넣어야 하기 때문이다. 단위 테스를 위해 목이나 스텁을 일일이 클래스로 정의하고 인터페이스의 모의 메소드를 구현하는 일이 불편했던 것과 마찬가지다.

- 그렇다면 프록시도 편리하게 만들어서 사용하는 방법은 없을까?
<br> -> 자바에는 java.lang.reflect 패키기 안에 프록시를 손쉽게 만들 수 있도록 지원해주는 클래스들이 있다.
<br> 기본적인 아이디언느 목 프레임워크와 비슷하다. 일일이 프록시 클래스를 정의하지 않고도 몇 가지 API를 이용해 프록시처럼 동작하는 오브젝트를 다이내믹하게 생성하는 것이다. (프록시 클래스를 직접 만들지 않아도 API 한 번 호출하면 실행 중에 프록시 객체를 만들어 준다)


### 프록시의 구성과 프록시 작성의 문제점

- 프록시의 기능
  - 타깃과 같은 메소드를 구현하고 있다가 메소드가 호출되면 타깃 오브젝트로 '위임'한다
  - 지정된 요청에 대해서는 '부가기능'을 수행한다.

<img width="614" height="719" alt="image" src="https://github.com/user-attachments/assets/00e5c6c9-6f14-4e9c-8a4e-7353b9ba48a8" />

- 그림을 설명해보자면 프록시는 <br> 1. {진짜 로직은 userService(타깃)에게 넘기는} 위임 <br> 2. {upgradeLevels() 앞 뒤에 트랜잭션을 처리함으로써} 부가기능 <br> 이 두 역할을 한다

- 하지만 인터페이스 메서드 마다 '위임 코드'를 다 만들어야하고, 타깃 인터페이스의 메서드가 추가되고 변경될 때마다 함께 수정해야한다는 번거로움이 있다.
- 트랜잭션 같은 부가기능 코드가 계속 중복될 가능성이 많다는 문제점이 있다.

- 부가기능의 중복문제는 중복되는 코드를 분리해서 어떻게든 해결해 보면 될 것 같지만, 첫 번째 문제인 인터페이스 메소드의 구현과 위임 기능 문제는 간단해 보이지 않는다. 이런 문제를 해결하는 데 유용한 것이 'JDK의 다이내믹 프록시'이다.

### 리플렉션

- 다이내믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어 준다. 리플렉션은 자바의 코드 자체를 '추상화'해서 접근하도록 만든 것이다.

<img width="179" height="53" alt="image" src="https://github.com/user-attachments/assets/d8a2ad48-113f-4645-9970-87a8cc408200" />

- 이 스트링의 길이를 알고 싶으면 name.length()를 호출하면 된다
- 자바의 모든 클래스는 Class 타입의 객체를 하나씩 갖고 있다
- String.class / name.getClass()로 Class 객체를 얻을 수 있다
- Class 객체를 이용하면 클래스의 메타정보를 알 수 있다. 더 나아가 메서드를 실행할 수도 있다.

- java.lang.reflect.Method 인터페이스는 메소드에 대한 자세한 정보를 담고 있다.
- Method.invoke()를 사용하면 메서드를 실행할 수 있다

<img width="372" height="53" alt="image" src="https://github.com/user-attachments/assets/63f9c52e-e003-4109-b7c6-c7af6c9f8edd" />

- obj : 이 메서드를 실행할 대상 객체
- args : 메서드에 넘길 파라미터들


<img width="514" height="56" alt="image" src="https://github.com/user-attachments/assets/6602385e-51e6-4705-899a-4bab3f22fd82" />

- 이를 이용해 lenth() 메소드를 위와 같이 실행할 수 있다.

<img width="1218" height="731" alt="image" src="https://github.com/user-attachments/assets/56641d3d-dc28-4043-8213-17474682278f" />

- 위 예제는 String 메서드를 직접 호출하는 방식과 리플렉션으로 Method를 얻어 invoke로 호출하는 방식이 동일한 결과를 낸다는 것을 보여주는 테스트이다.


### 프록시 클래스

여기서

<img width="519" height="419" alt="image" src="https://github.com/user-attachments/assets/06562fda-2e50-4803-9d06-fe08931e8844" />

이 부분을 보면

<img width="461" height="103" alt="image" src="https://github.com/user-attachments/assets/5716db2a-123f-4476-aaaf-ef88c81eb957" />

데코레이터 프록시인걸 알수 있다

- 그런데 이 프록시는, 프록시 저용의 일반적인 문제점 두 가지를 모두 갖고 있다. <br> -> 인터페이스의 모든 메소드를 구현해 위임하도록 코드를 만들어야 하며, 부가기능인 리턴 값을 대문자로 바꾸는 기능이 모든 메소드에 중복돼서 나타난다.


### 다이내믹 프록시 적용

<img width="498" height="216" alt="image" src="https://github.com/user-attachments/assets/057ab8d6-5796-4929-ac7f-2c0beb12845b" />

- 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 다이내믹하게 만들어지는 오브젝트이다. 다이내믹 프록시 오브젝트는 타깃의 인터페이스와 같은 차입으로 만들어진다.
- 다이내믹 프록시가 인터페이스 구현 클래스의 오브젝트는 만들어주지만, 프록시로서 필요한 부가기능 제공 코드는 직접 작성해야 한다.

<img width="382" height="43" alt="image" src="https://github.com/user-attachments/assets/bc7973cb-137f-4156-880f-a95aec3f474d" />

- invoke()메소드는 리플렉션의 Method인터페이스를 파라미터로 받고, 메소드를 호출할 때 전달되는 파라미터도 args로 받는다. 즉 모든 메서드 호출이 invoke()하나로 들어온다. 


<img width="485" height="148" alt="image" src="https://github.com/user-attachments/assets/885429bf-1767-45c4-a5bd-251c467a873b" />

- 위 그림은 다이내믹 프록시 오브젝트와 InvocationHandler 오브젝트, 타깃 오브젝트 사이의 메소드 호출이 일어나는 과정을 나타낸다.
- 다이내믹 프록시가 받는 모든 요청을 InvocationHandler의 invoke() 메소드로 보내준다.
- Hello 인터페이스의 메소드가 아무리 많더라도 invoke() 메소드 하나로 처리할 수 있다. 

<img width="541" height="297" alt="image" src="https://github.com/user-attachments/assets/5cc364c9-a389-41b4-a157-dff45e58e475" />

- 위 사진은 HelloUppercase클래스와 마찬가지로, 모든 요청을 타깃에 위임하면서 리턴 값을 대문자로 바꿔주는 부가기능을 가진 InvocationHandler 구현 클래스이다.

```
public Object invoke(Object proxy, Method method, Object[] args)
```

-> 어떤 프록시로 어떤 메서드를 어떤 인자로 호출했는지 알려주겠단 말

```
String ret = (String) method.invoke(target, args);
```

- method : 호출된 메서드 정보 (sayHello / sayHi / sayThankYou)

- args : 그 메서드의 파라미터

- method.invoke(target, args) : 타깃에게 위임

```
return ret.toUpperCase();
```

- 타깃결과를 가공하고 기능을 부가한다. 


<img width="498" height="150" alt="image" src="https://github.com/user-attachments/assets/553aa8dc-07f5-415e-8b7f-a8d316adf5d0" />

- Hello 인터페이스를 구현한 프록시 객체를 만들고, 모든 호출은 UppercaseHandler.invoke()로 보내자.

- 파라미터는 클래스 로더를 제공해야한다. 다이내믹 프록시가 정의되는 클래스 로더를 지정하는 것이다.
- 파라미터는 다이내믹 프록시가 구현해야 할 인터페이스이다. <br> 다이내믹 프록시는 한 번에 하나 이상의 인터페이스를 구현 할 수도 있어서 인터페이스의 배열을 사용한다.
- 파라미터로는 부가기능과 위임 관련 코드를 담고 있는 InvocationHandler 구현 오브젝트를 제공해야 한다. <br> Hello 타입의 타깃 오브젝트를 생성자로 받고, 모든 메소드 호출의 리턴 값을 대문자로 바꿔주는 UppercaseHandler오브젝트를 전달 했다.
- newProxyInstance()에 의해 만들어지는 다이내믹 프록시 오브젝트는 파라미터로 제공한 Hello 인터페이스를 구현한 클래스의 오브젝트이기 때문에 Hello 타입으로 캐스팅이 가능하다.

- 다이내믹 프록시를 쓰는 이유?
  <br> -> 코드가 더 어려워 보이고 리플렉션이라 처음엔 복잡하지만 메서드 수가 늘어나도 코드가 증가하지않고 공통 기능을 한 군데에서 처리할수 있는 장점, 즉 중복이 제거가 되고 확정성이 있기 때문에 다이내믹 프록시를 쓴다.

### 다이내믹 프록시의 확장

- Hello 인터페이스 메서드가 3개라서 괜찮다. 하지만 실제로는 30개, 100개로 늘어날 수 있다.
- 그렇게 되면 메서드가 늘어날 때마다 프록시 클래스도 계속 수정해야되고 기능(대문자 변환)이 모든 메서드에 중복된다.

<img width="510" height="360" alt="image" src="https://github.com/user-attachments/assets/ca18bd66-3b5f-42a5-831b-929128ee57b0" />

- 리턴 타입을 검사한다. String이면 대문자로 변환하고 아니면 그대로 반환한다.
<br> 훨씬 안전하고 범용적이다

<img width="509" height="245" alt="image" src="https://github.com/user-attachments/assets/7af91bc0-d276-42dd-a7f2-910eace3c120" />

- say로 시작하는 메서드에만 대문자 기능을 적용한다.

### 6.3.3 다이내믹 프록시를 이용한 트랜잭션 부가기능

```
class UserServiceTx implements UserService {
    UserService userService;
    PlatformTransactionManager txManager;
}
```
- 기존 UserServiceTx는 인터페이스 메서드를 전부 다시 구현해야 하고, 트랜잭션 코드가 메서드마다 중복되었고 다른 서비스에 재사용 불가했다.
- 이 문제는 트랜잭션 부가기능을 제공하는 다이내믹 프록시를 만들어 적용하는 방법이 효율적이다.

<img width="644" height="233" alt="image" src="https://github.com/user-attachments/assets/de372e62-bbd5-43f0-ae27-dc982e825e4d" />

<img width="652" height="710" alt="image" src="https://github.com/user-attachments/assets/159c302e-af38-48c2-848b-6ae1b3e7200b" />

```
public Object invoke(Object proxy, Method method, Object[] args)
```

- 다이내믹 프록시의 모든 메서드 호출은 여기로 들어온다.

- InvocationHandler의 invoke() 메소드를 구현하는 방법은 UppercaseHandler에 적용했던 것과 동일하다. <br> 타깃 오브젝트의 모든 메소드에 트랜잭션을 적용하는 게 아니라 선별적으로 적용할 것이므로 적용할 대상을 선별하는 작업을 먼저 진행한다.
<br> DI 받은 이름 패턴으로 시작되는 이름을 가진 메소드인지 확인한다. 패턴과 일치하는 이름을 가진 메소드라면 트랜잭션을 적용하는 메소드를 호출하고, 아니라면 부가기능 없이 타깃 오브젝트의 메소드를 호출해서 결과를 리턴하게 한다.

- 트랜잭션을 적용하면서 타깃 오브젝트의 메소드를 호출하는 것은 UserServiceTx에서와 동일하다.
<br> 한 가지 차이점은 롤백을 적용하기 위한 예외는 RuntimeException 대신에 InvocationTargetException을 잡도록 해야 한다는 점이다.
<br> 리플렉션 메소드인 Method.invoke()를 이용해 타깃 오브젝트의 메소드를 호출할 때는 타깃 오브젝트에서 발생하는 예외가 InvocationTargetException으로 한 번 포장돼서 전달된다.
<br> 따라서 일단 InvocationTargetException으로 받은 후 getTargetException() 메소드로 중첩되어 있는 예외를 가져와야 한다.

- 즉 
<br> method.invoke() 사용 -> 리플렉션
<br> 예외는 항상 InvocationTargetException으로 감싸지기 때문에 getTargetException()으로 진짜 예외 꺼낸다.


### TansactionHandler와 다이내믹 프록시를 이용하는 테스트

- 기존 방식인 UserServiceTx -> 인터페이스 메소드 전부 구현하고 트랜잭션 코드가 메소드마다 반복된다. 
- 새로운 방식인 TransactionHandler + Proxy.newProxyInstance() -> 프록시 클래스 작성안하고, InvocationHandler 하나로 모든 메소드 처리하며 어떤 서비스에도 재사용 가능하다

<img width="636" height="314" alt="image" src="https://github.com/user-attachments/assets/2151811f-d08a-4374-aace-93e0318d583a" />

- UserServiceTx 오브젝트 대신 TransactionHandler를 만들고 타깃 오브젝트와 트랜잭션 매니저, 메소드 패턴을 주입해준다. 



























