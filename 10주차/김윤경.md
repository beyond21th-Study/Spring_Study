# 6.3 다이내믹 프록시와 팩토리 빈
## 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

<img width="673" height="159" alt="image" src="https://github.com/user-attachments/assets/1ce72680-5f35-4f07-b52a-c445e60f2ce5" />

- 부가기능 전부를 핵심 코드가 담긴 클래스에서 독립에서 독립시킨 그림.
- 이렇게 분리된 부가기능을 담은 클래슨는 중요한 특징이 이는데, 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해 줘야 한다.
- 하지만 이렇게 구성했다고 하더라도 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다.
- 그래서 부가기능은 마치 자신이 핵심 기능을 가진 클래스인 것처럼 꾸며서 클라이언트가 자신을 거쳐 핵심기능을 사용하도록 만들어야 한다.

<img width="681" height="164" alt="image" src="https://github.com/user-attachments/assets/960f2574-29ca-462f-ac6b-d158372c34be" />

- 부가기능 코드에서는 핵심 기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다.
- 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 대표적인 경우다 (= 비즈니스(핵심기능)코드에는 손 대지 않고 그 실행 앞/뒤에 트랜잭션 시작과 종료 로직을 감싸서 추가하는 것을 의미)
- 이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 '프론시'라고 부른다.
- 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를  '타깃' 또는 '실체'라고 부른다.

<img width="647" height="116" alt="image" src="https://github.com/user-attachments/assets/7160279e-93c4-430d-989a-a1729e462a26" />

- 위 그림은 클라이언트가 프록시를 통해 타깃을 사용하는 구조이다.
- 프록시의 특징은
  - 타깃과 같은 인터페이스를 구현했다는 것 (클라이언트 입장에서는 타깃과 구분되지 않음)
  - 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다. (동시에 클라이언트와 타깃 사이에 위치해, 타깃 호출을 통제하거나 부가 기능을 적용할 수 있다)
- 프록시는 사용 목적에 따라 두 가지로 구분 할 수 있다.
  - 클라이언트가 타깃에 접근하는 방법을 제어하기 위한 목적
  - 타깃에 부가적인 기능을 부여해주기 위한 목적
- 두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용한다는 점은 동일하지만 목적(접근 제어인지, 기능 확장에 따라서) 디자인 패턴데서는 다른 패턴으로 구분한다.

### 데코레이터 패턴

- 데코레이터 패턴은 타깃에 부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴이다.
- 다이내믹하게 기능을 부여한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다.
- 프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에(인터페이스가 프록시와 타깃을 구분 없이 교체 가능하게 만들어, 기능을 끼워 넣을 수 있는 설계 지점을 제공하기 때문에 인터페이스로 접근) 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다.
<br> 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메소드를 통해 위임 대상을 외부에서 런타임 시에 주입 받을 수 있도록 만들어야 한다.


- UserServiceImpl(진짜 로직)에 UserServiceTx(트랜잭션 담당)를 덮어씌워서, 클라이언트는 트랜잭션이 적용된 서비스만 보게 했다

- UserServiceImpl : 타깃, 진짜 비즈니스 로직 있음, “회원 등급 변경”, “유저 처리” 이런 코드
<br> -> 트랜잭션 모름

- UserServiceTx : 데코레이터, 트랜잭션 시작/커밋/롤백 담당, 내부에 UserService를 하나 들고 있음
<br> -> 기능은 위임하고, 앞뒤로 트랜잭션만 붙임

<img width="1299" height="428" alt="image" src="https://github.com/user-attachments/assets/0728d94d-ac3c-49e3-b628-eaf0d99cf5b3" />

- userService라는 이름의 빈은 UserServiceTx의 객체.
<br> 그 안에 트랜잭션 매니저도 넣어주고, userServiceImpl이라는 진짜 서비스도 넣어준다.
<br> UserServiceTx가 UserServiceImpl을 감싸도록 설정한 것

"DI를 통한 다이나믹한 구성" ? : 코드를 바꾸지 않고 설정만으로 누가 누구를 감쌀지 결정했다-라는 뜻. 

- 데코레이터 패턴은 인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다. (항상 타입이 UserService userService; 이거니깐)
- 여러 개의 데코레이터를 적용 할 수도, 필요하면 다른 데코레이터를 중간에 끼워 넣을 수도 있다.
- 그래서 데코레이터 패턴은 타깃의 코드를 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

### 프록시 패턴

- 프록시 : 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝틀르 두는 방법.
- 프록시 패턴 : 디자인패턴의 생성, 구현, 행위 패턴 중에서 구현 패턴 중 하나. 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우.
<br> 프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다. 클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트를 만드는 대신 프록시를 넘겨준다. <br> 프록시의 메소드를 통해 타깃을 사용하려고 시도하면, 그대 프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다. <br> 만약 레퍼런스는 갖고 있지만 끝까지 사용하지 않거나 많은 작업이 진행된 후에 사용죄는 경우라면 이렇게 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다. <br> -> 









