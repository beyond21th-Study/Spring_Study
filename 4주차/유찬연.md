# 템플릿과 콜백

복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그 중 일부분만 자주 바꿔서 사용해야 하는 경우 → 일종의 전략 패턴 적용 적합

전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식

이를 스프링에서는 **템플릿/콜백 패턴**

전략 패턴의 컨텍스트 : 템플릿

익명 내부 클래스로 만들어지는 오브젝트 : 콜백

# 템플릿

어떤 목적을 위해 미리 만들어 둔 모양이 있는 틀.

프로그래밍에서는 고정된 부분에 바꿀 수 있는 부분을 넣어서 사용하는 경우를 말함

JSP는 HTML이라는 고정된 부분에 EL과 스크립 릿이라는 변하는 부분을 넣은 일종의 템플릿 파일.

템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼 클래스에 두고, 바뀌는 부분을 서브 클래스의 메소드에 두는 구조로 형성됨

### 스크립틀릿

JSP 초창기 방식으로 JSP 안에서 <% … %> 안에 자바 코드를 직접 넣는 것.

HTML 파일 안에 자바 코드를 넣는 느낌

이 방식의 경우 HTML과 자바 코드가 섞여서 보기 어렵고 유지보수가 힘듦.

### EL

스크립틀릿을 대체하려고 나온 표현 언어.

JSP 2.0부터 도입됐고, ${ } 형태로 데이터를 출력

request.setAttribute()로 저장된 값을 EL이 자동으로 꺼내서 출력

깔끔하고 가독성이 좋아서 현대 JSP 개발의 기본이 됨

## 콜백

실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트.

파라미터로 전달되지만 값을 참조하기 위한 것이 아닌 특정 로직을 담은 메소드를 실행시키기 위해 사용.

자바에서는 메소드 자체를 파라미터로 전달할 방법이 없어 메소드가 담긴 오브젝트를 전달해야 함.

그래서 functional object라고도 함.

## 템플릿/콜백의 특징

템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용

why? 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문.

또한 하나의 템플릿에서 여러 가지 종류의 전략을 사용하는 경우 → 하나 이상의 콜백 오브젝트 사용 가능

콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어짐

콜백 인터페이스의 메소드에는 보통 파라미터가 있음.

이 파라미터는 템플릿의 작업 흐름 중에 만들어지는 컨텍스트 정보를 전달받을 때 사용됨.

아래는 템플릿/콜백 패턴의 일반적인 작업 흐름 이미지.

![image.png](attachment:ad0a617f-30f4-4c8a-b702-ad0651368723:image.png)

- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공하는 것. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달
- 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조 정보를 가지고 콜백 오브젝트의 메소드를 호출. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조 정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 반환
- 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행. 경우에 따라 최종 결과를 클라이언트에 다시 돌려주기도 함.

클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI.

템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어남.

일반적인 DI의 경우 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용. 

But, 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달 받는 것이 특징.

또한, 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징. 

클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적인 DI와 조금 다름.

템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법.

## 콜백의 재활용

템플릿/콜백 방식은 템플릿에 담긴 코드를 반복적으로 사용하는 원시적인 방법에 비해 많은 장점이 있지만, 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 불편하다는 단점 존재.

### 콜백의 분리와 재활용

분리를 통해 재사용이 가능한 코드를 찾아낼 수 있다면 복잡한 익명 내부 클래스의 사용을 최소화 가능.

![image.png](attachment:1b49be27-fd70-4884-b0e2-ca8a7615580d:image.png)

위의 PreparedStatement에서 변하는 부분은 오직 “delete from users”라는 문자열 뿐이므로 중복될 가능성이 있는 변하지 않는 부분을 분리하여 작성하면, 아래의 이미지처럼 작성됨.

![image.png](attachment:396d0fb7-98f4-47fe-b5be-5baf2f726a87:image.png)

바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하고 바뀌지 않는 부분을 빼내어 executeSql() 메소드 생성.

SQL을 담은 파라미터를 final로 선언하여 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 하는 것만 주의하면 됨.

### 콜백과 템플릿의 결합

재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨도 됨.

![image.png](attachment:19ff11df-4394-4cfa-b0a4-bb2d2753b701:image.png)

executeSql() 메소드가 JdbcContext로 이동했으니 UserDao의 메소드에서도 아래 이미지와 같이 jdbcContext를 통해 메소드를 호출하도록 수정 필요.

![image.png](attachment:f1a31a95-2bc1-4e74-9baf-ca52ffc5672c:image.png)

이를 통해 익명 내부 클래스의 사용으로 복잡해 보이던 클라이언트 메소드가 깔끔하고 단순해짐.

![image.png](attachment:3c1c7290-5e68-4ceb-813e-dd50042c73b7:image.png)

일반적으로 성격이 다른 코드들은 가능한 한 분리하는 편이 낫지만, 이 경우는 반대.

why? 하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문.

구체적인 구현과 내부의 전략 패턴, 코드에 의한 DI, 익명 내부 클래스 등의 기술은 최대한 감춰두고, 외부에는 꼭 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것.

add() 메소드에도 콜백의 작업 적용 가능.

이 경우 SQL 문장과 함께 PreparedStatement에 바인딩될 파라미터 내용 추가 필요.

바인딩 파라미터의 개수는 일정하지 않으므로 자바 5에서 추가된 가변인자로 정의해두는 것이 좋음.

콜백에서 PreparedStatement를 만든 뒤 바인딩할 파라미터 타입을 살펴서 적절한 설정 메소드로 호출해주는 작업.

## 템플릿/콜백 응용

고정된 작업 흐름을 갖고 있으면서 자주 반복되는 코드가 있다면, 중복되는 코드를 분리할 방법을 생각해보는 습관 필요.

중복된 코드는 우선 메소드로 분리 시도.

그 중 일부 작업을 필요에 따라 바꾸어 사용해야 한다면 인터페이스를 사이에 두고 분리해서 전략 패턴을 적용한 뒤 DI로 의존 관계를 관리.

그런데 여기서 바뀌는 부분이 한 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴 적용 고려 가능.

가장 전형적인 템플릿/콜백 패턴의 후보는 try/catch/finally 블록을 사용하는 코드.

일정한 리소스를 만들거나 가져와 작업하면서 예외가 발생할 가능성이 있는 코드는 보통 try/catch/finally 구조로 코드가 만들어질 가능성이 높음.

why? 예외 상황을 처리하기 위한 catch와 리소스를 반납하거나  제거하는 finally가 필요하기 때문.

### 테스트와 try/catch/finally

모든 라인의 숫자를 더한 합을 돌려주는 코드의 테스트 코드.

![image.png](attachment:4eef3bee-d119-49ba-a5ab-a87c7b6213cb:image.png)

모든 라인의 숫자를 더한 합을 돌려주는 코드.

![image.png](attachment:ff3860c3-a744-4e5d-8ff7-8665e2a9419f:image.png)

파일을 BufferReader를 통해 마지막 줄까지 반복해서 읽어와 미리 만들어 둔 sum 변수에 값을 더해주는 간단한 코드.

try/catch/finally를 적용한 calsSum() 메소드.

![image.png](attachment:c3d27f95-a6a9-4e2e-9409-bdb686c29582:image.png)

DAO의 JDBC 코드에 적용했던 것과 기본 개념은 동일. 

만들어진 모든 리소스는 확실히 정리하고 빠져나오도록 만드는 것과 모든 예외 상황에 대해서 적절한 처리를 해주도록 하는 것.

### 중복의 제거와 템플릿/ 콜백 설계

이번에는 모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 발생.

그리고 이후에도 여러 가지 방식으로 숫자 데이터를 처리하는 기능이 계속 추가될 것이라는 소식도 생겼다고 가정.

파일을 읽어서 처리하는 비슷한 기능을 새로 추가되는 코드마다 복사해서 사용하지 않고, 템플릿/콜백 패턴을 적용.

템플릿이 파일을 열고 각 라인을 읽어올 수 있는 BufferReader를 만들어 콜백에게 전달해주고, 콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 반환.

![image.png](attachment:28356b8c-bf3c-47e0-a58f-0cad1e97d52b:image.png)

템플릿에서는 BufferdReaderCallback 인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행.

콜백이 돌려준 결과는 최종적으로 모든 처리를 마친 후에 다시 클라이언트에 반환.

![image.png](attachment:a4c033f6-6217-4bf7-9344-563089547001:image.png)

BufferReader를 만들어서 넘겨주는 것과 그 외의 모든 번거로운 작업에 대한 작업 흐름은 템플리셍서 진행하고, 준비된 BufferReader를 이요해 작업을 수행하는 부분은 콜백을 호출해서 처리하도록 작성.

![image.png](attachment:1f6feb03-5df5-4b1b-8b53-ed7c32cd96ca:image.png)

템플릿으로 분리한 부분을 제외한 나머지 코드를 BufferReaderCallback 인터페이스로 만든 익명 내부 클래스에 담고, 처리할 파일의 경로와 함께 준비된 익명 내부 클래스의 오브젝트를 템플릿에 전달.

코드의 가독성을 위해 콜백 오브젝트를 일단 변수에 저장한 뒤 사용.

템플릿이 리턴하는 값을 최종 결과로 사용하면 됨.

이제 파일에 있는 숫자의 곱을 구하는 메소드도 이 템플릿/콜백을 이용하여 작성.

아래는 테스트 코드의 이미지.

![image.png](attachment:f841441c-082d-4c80-898d-776ec6976c1b:image.png)

![image.png](attachment:1cda755f-4db9-4b40-9fbc-06a9a8621868:image.png)

그리고 테스트를 성공시키는 코드를 작성.

앞에서 만든 sumCallBack과 거의 비슷하지만 각 라인의 숫자를 더하는 대신 곱하는 기능을 담은 콜백을 사용하도록 작성.

![image.png](attachment:c2ee6616-be0d-4ea0-a493-11bc6c1fd4fb:image.png)

## 템플릿/콜백의 재설계

![image.png](attachment:0bfb3659-c273-4a4f-86d4-67eb4dac4007:image.png)

![image.png](attachment:9ee44bb5-7de5-4a73-b450-6942c3214c32:image.png)

앞선 두 개의 코드의 콜백을 비교해보면 아주 유사한 구조를 가짐을 알 수 있음.

결과를 저장할 변수를 초기화하고, BufferReader를 이용해 파일의 마지막 라인까지 순차적으로 읽으면서 각 라인에서 읽은 내용을 결과를 저장할 변수의 값과 함께 계산하다가, 파일을 다 읽었으면 결과를 저장하고 있는 변수의 값을 리턴.

템플릿과 콜백을 찾아낼 때는 변하는 코드의 경계를 찾고 그 경계 사이에 두고 주고 받는 일정한 정보가 있는지 확인하면 됨.

여기서 바뀌는 코드는 네 번째 줄 뿐이므로, 네 번째 라인을 처리하고 다시 외부로 전달되는 것은 multiply 또는 sum과 각 라인의 숫자 값을 가지고 계산한 결과.

![image.png](attachment:71217f80-02d9-4bce-b775-64fe85883c53:image.png)

LineCallBack은 파일의 각 라인과 현재까지 계산한 값을 넘겨주도록 작성되어 있음.

그리고 새로운 계산 결과를 리턴 값을 통해 다시 전달 받음.

아래는 LineCallBack 인터페이스를 경계로 만든 새로운 템플릿.

![image.png](attachment:6b489247-d8b6-4578-9407-121f8cdb3fec:image.png)

![image.png](attachment:b4115098-cc5f-4e20-a662-965a7f1d0838:image.png)

템플릿에 파일의 각 라인을 읽는 작업이 추가됨.

계산 결과를 담을 변수를 초기화할 값도 파라미터로 전달.

새로 만든 템플릿이 기존과 다른 점은 while 루프 안에서 콜백을 호출한다는 점.

아래는 수정된 템플릿을 사용하는 코드.

![image.png](attachment:53663a9f-895b-4616-88d1-6862fdc201da:image.png)

여타 로우 레벨의 파일 처리 코드가 템플릿으로 분리되고 순수한 계산 로직만 남아 있어 코드의 관심이 무엇인지 명확하게 확인 가능.

간단한 예제를 통해 템플릿/콜백 패턴이 다양한 작업에 손쉽게 활용 가능하다는 점을 확인.

## 제네릭스를 이용한 콜백 인터페이스

지금까지 사용한 LineCallBack과 lineReadTemplate()은 템플릿과 콜백이 만들어내는 결과가 Integer 타입으로 고정.

만약 파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고 싶은 경우 → 자바 언어의 제네릭스 이용 가능.

파일의 각 라인에 있는 문자를 모두 연결해서 하나의 스트링으로 돌려주는 기능 구현.

템플릿이 리턴하는 타입 : 스트링, 콜백의 작업 결과 : 스트링.

아래는 콜백 메소드의 리턴 값과 파라미터 값의 타입을 제네렉 타입 파라미터 T로 선언.

![image.png](attachment:2d7b338b-6c30-4fc5-beca-31e02497b517:image.png)

템플릿도 타입 파라미터를 사용해 제네릭 메소드로 수정.

콜백의 타입 파라미터와 초기 값인 initVal의 타입 그리고 템플릿의 결과 값 타입을 모두 동일하게 선언해야 함.

![image.png](attachment:aa42c8b5-d8dc-4cc1-af63-f52a6155e095:image.png)

line ReadTemplate() 메소드는 이제 타입 파라미터 T를 갖는 인터페이스 LineCallBack 타입의 오브젝트와 T 타입 파라미터로 선언된 LineCallBack의 메소드를 호출해서 처리한 후 T 타입의 결과를 리턴하는 메소드가 됨.

제네릭스 코드에 익숙하지 않은 경우 타입 파라미터가 많아서 복잡해 보일 수 있음.

이럴 때는 타입 파라미터 T를 String이나 Integer같은 특정 타입으로 바꿔서 생각해보면 이해하는데 도움이 됨.

이제 파일의 모든 라인의 내용을 하나의 문자열로 길게 연결하는 기능을 가진 메소드를 추가.

![image.png](attachment:ec8d3d57-122f-4d14-8a23-d235b4e8b0cb:image.png)

최종적으로 lineReadTemplate() 메소드의 결과도 스트링 타입이 돼서 concatenate() 메소드의 리턴 타입도 스트링으로 정의 가능.

아래는 concatenate() 메소드에 대한 테스트.

![image.png](attachment:ec2246bc-efde-4e9c-8ce4-06736d6fb973:image.png)

파일의 각 라인의 내용을 숫자로 바꾸지 않고 스트링으로 연결하기에 결과 값은 “1234”.

# 스프링의 JdbcTemplate

스프링은 JDBC를 이용하는 DAO에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백 제공.

또한 거의 모든 종류의 JDBC 코드에서 사용 가능한 템플릿과 콜백을 제공할 뿐만 아니라, 자주 사용되는 패턴을 가진 콜백은 다시 템플릿에 결합시켜 간단한 메소드 호출만으로 사용이 가능하도록 만들어져 있음.

스프링이 제공하는 기본 템플릿은 JdbcTemplate.

현재 UserDao는 DataSource를 DI 받아서 JdbcContext에 주입해 템플릿 오브젝트로 만들어 사용.

이제 JdbcContext를 JdbcTemplate으로 변경. 

JdbcTemplate은 생성자의 파라미터로 DataSourc를 주입하면 됨

![image.png](attachment:7cfaad0f-fcd3-457c-b424-c54eae1ebf96:image.png)

## update()

PreparedStatementCreator 타입의 콜백을 받아서 사용하는 JdbcTemplate의 템플릿 메소드는 update().

![image.png](attachment:b81c2f46-34fb-4210-98d8-3b520621a649:image.png)

![image.png](attachment:99ef848c-80ef-47da-bee6-6bc667e0853d:image.png)

JdbcTemplate에도 executeSql()처럼 SQL 문장만 전달하면 미리 준비된 콜백을 만들어 템플릿을 호출하는 것까지 한 번에 해주는 편리한 메소드가 존재.

![image.png](attachment:ef948812-2467-4720-a730-be57784217e5:image.png)

또한, JdbcTemplate은 치환자를 가진 SQL로 PreparedStatment를 만들고 함께 제공하는 파라미터를 수서대로 바인딩해주는 기능을 가진 update() 메소드 제공.

현재 add() 메소드에서 만드는 콜백은 PreparedStatement를 만드는 것과 파라미터를 바인딩하는 두 가지 작업을 수행.

![image.png](attachment:e23b1925-0eab-432e-b995-90701e46323a:image.png)

이렇게 간단하게 변경 가능.

![image.png](attachment:1aebf352-7681-42c5-b6e6-0ed6e7e39543:image.png)

## queryForInt()

getCount()는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드.

이런 작업 흐름을 가진 코드에서 사용할 수 있는 템플릿은 PreparedStatementCreator 콜백과  ResultSetExtractor 콜백을 파라미터로 받는 query() 메소드.

ResultSetExtractor는 PreparedStatement의 쿼리를 실행해서 얻은 ResultSet을 전달받는 콜백.

ResultSetExtractor 콜백은 템플릿이 제공하는 ResultSet을 이용해 원하는 값을 추출해서 템플릿에 전달하면, 템플릿은 나머지 작업을 수행한 뒤 그 값을 query() 메소드의 리턴 값으로 반환.

콜백이 두 개 등장하는 다소 복잡해 보이는 구조지만, 템플릿/콜백의 동작 방식을 생각해보면 이해 가능.

1. PreparedStatmentCreator 콜백은 템플릿으로부터 Connection을 받고 PreparedStatement를 돌려줌.
2. ResultSetExtractor는 템플릿으로부터 ResultSet을 받고 거기서 추출한 결과를 돌려줌.

아래는 JdbcTemplate을 사용하도록 수정한 getCount() 메소드.

![image.png](attachment:263bf0b0-c4ed-4928-98f2-dd3f4081f30a:image.png)

![image.png](attachment:fe45b424-aedd-46e3-b5f3-a2226a44e898:image.png)

원래 getCount() 메소드에 있던 코드 중 변하는 부분만 콜백으로 만들어져서 제공.

두 번째 콜백에서 리턴하는 값은 결국 템플릿 메소드의 결과로 다시 리턴.

원래 클라이언트/템플릿/콜백의 3단계 구조이므로, 콜백이 만들어낸 결과는 템플릿을 거쳐야만 클라이언트인 getCount() 메소드로 넘어오게 됨.

또한 ResultSetExtractor는 제네릭스 타입 파라미터를 가짐.

ResultSet에서 추출할 수 있는 값의 타입은 다양하기 때문에 타입 파라미터를 사용.

ResultSetExtractor 콜백에 지정한 타입은 제네릭 메소드에 적용돼서 query() 템플릿의 리턴 타입도 함께 변경.

위의 콜백 오브젝트 코드는 재사용에 매우 유리한 구조.

클라이언트에서 콜백의 작업을 위해 특별히 제공할 값도 없어서 단순함.

손쉽게 ResultSetExtractor 콜백을 템플릿 안으로 옮겨 재활용 가능.

JdbcTemplate은 이런 기능이 내장된 queryForInt() 라는 편리한 메소드를 제공.

![image.png](attachment:7e246b87-a827-4eb7-a0c1-acfd8d95114f:image.png)

## queryForObject()

get() 메소드에 JdbcTemplate 적용.

![image.png](attachment:a1a121cd-f67f-44d5-b179-16230f469bf1:image.png)

첫 번째 파라미터는 PreparedStatement를 만들기 위한 SQL, 두 번째는 여기에 바인딩할 값들.

뒤에 다른 파라미터가 있기 때문에 가변 인자가 아닌 Object 타입 배열을 사용해야 함.

배열 초기화 블록을 사용해 SQL의 ? 에 바인딩할 id 값 전달.

queryForobject() 내부에서 이 두 가지 파라미터를 사용하는 PreparedStatement 콜백이 만들어짐.

queryForobject()는 SQL을 실행시 한 개의 로우만 얻을 것으로 예상.

그리고 ResultSet의 next()를 실행하여 첫 번째 로우로 이동시킨 후 RowMapper 콜백을 호출.

이미 RowMapper가 호출되는 시점에서 ResultSet은 첫 번째 로우를 가리키고 있으므로 다시 rs.next() 호출 필요 x.

RowMapper에서는 현재 ResultSet이 가리키고 있는 로우의 내용을 User 오브젝트 그대로 담아서 리턴해주면 됨.

RowMapper가 리턴한 User 오브젝트는 queryForobject() 메소드의 리턴 값으로 get() 메소드에 전달.

queryForobject() 를 이용할 때 조회 결과가 없는 예외 상황을 처리하는 방법.

이미 queryForobject() 는 SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어짐.

이때 던져지는 예외가 바로 EmptyResultDataAccessException.

EmptyResultDataAccessException은 JdbcTemplate의 queryForobject() 등에서 사용하려고 만들어진 것.

## query()

현재 등록되어 있는 모든 사용자 정보를 가져오는 메소드 getAll()에 대한 테스트.

![image.png](attachment:7deb0083-ab55-4df1-b864-383df1fdba95:image.png)

UserDaoTest 안에 픽스처로 준비해둔 user1, user2, user3을 차례로 추가하면서 getAll() 이 돌려주는 리스트의 크기와 리스트에 담긴 User 오브젝트의 내용을 픽스처와 비교.

이때 Id 순서대로 정렬됨에 유의.

User의 값을 비교하는 코드가 반복되기 때문에 별도의 메소드로 분리.

@Test, @Before 등의 애노테이션이 붙지 않는 메소드에 테스트 코드에서 반복적으로 나타나는 코드를 담아두고 재사용하는 건 좋은 습관.

여러 테스트 클래스에 걸쳐 재사용되는 코드라면 별도의 클래스로 분리하는 것도 고려 가능.

### query() 템플릿을 이용하는 getAll() 구현

앞에서 사용한 queryForObject()는 쿼리의 결과가 로우 하나일 때 사용하고, query()는 여러 개의 로우가 결과로 나오는 일반적인 경우 사용 가능.

query()의 리턴 타입은 List<T>.

query()는 제네릭 메소드로 타입은 파라미터로 넘기는 RowMapper<T> 콜백 오브젝트에서 결정됨.

![image.png](attachment:16c4c2b8-1ea8-4360-b025-1a3222517db6:image.png)

첫 번째 파라미터에는 실행할 SQL 쿼리 삽입.

바인딩할 파라미터가 있다면 두 번째 파라미터에 추가도 가능.

파라미터가 없는 경우 생략 가능.

마지막 파라미터는 RowMapper 콜백.

query() 템플릿은 SQL을 실행해서 얻은 ResultSet의 모든 로우를 열람하면서 로우마다 RowMapper 콜백을 호출.

SQL 쿼리를 실행해 DB에서 가져오는 로우의 개수만큼 호출.

RowMapper는 현재 로우의 내용을 User 타입 오브젝트에 매핑해서 반환.

이렇게 만들어진 User 오브젝트는 템플릿이 미리 준비한List<User> 컬렉션에 추가되고,  모든 로우에 대한 작업을 마치면 모든 로우에 대한 User 오브젝트를 담고 있는 List<User> 오브젝트가 리턴.

### 테스트 보완

테스트 성공시 다음 기능으로 넘어가고 싶더라도 긍정적인 결과만 테스트하는 것이 아닌 부정적인 테스트도 필요.

get()이라면 Id가 없을 때는 어떻게 되는지, getAll()이라면 결과가 하나도 없는 경우에는 어떻게 되는지를 검증하는 것이 네거티브 테스트

미리 예외상황에 대한 일관성 있는 기준을 정해두고 이를 테스트로 만들어 검증 필요.

![image.png](attachment:7a353150-1091-47de-b7bc-add53195c7a8:image.png)

JdbcTemplate의 query() 메소드가 예외적인 경우 크기가 0인 리스트 오브젝트를 리턴하는 것으로 정해져 있는 경우에도 굳이 검증 코드 추가가 필요? Yes.

이유는 사용자 입장에서 내부적으로 JdbcTemplate을 사용하는지 개발자가 직접 만드는지 알 수도 없고 알 필요도 없기 때문.

그렇기에 예상된느 결과를 모두 검증하는 게 옳음.

또한 내부적으로 query()를 사용했다고 하더라도 getAll() 메소드가 다른 결과를 리턴하게 할 수도 있기 때문.

(query()의 결과를 무조건 getAll()에서 리턴해야 할 이유는 없음)

## 재사용 가능한 콜백의 분리

UserDao 코드를 살펴보면 처음 작성했을 때보다 코드의 양이 줄어들었을 뿐 아닌 각 메소드의 기능을 파악하기도 쉽게 작성되어 있음.

핵심적인 SQL 문장과 파라미터, 그리고 생성되는 결과의 타입 정보만 남기고 모든 판에 박힌 로우 레벨 중복 코드는 깔끔하게 제거됐기 때문.

하지만 할 일이 남음.

### DI를 위한 코드 정리

필요 없어진 DataSource 인스턴스 변수를 제거.

UserDao의 모든 메소드가 JdbcTemplate을 이용하도록 만들어 더 이상 DataSource를 직접 사용할 일 x.

단지 JdbcTemplate을 생성하면서 직접 DI를 해주기 위해 필요한 DataSource 전달이 필요하니 수정자 메소드는 남김.

![image.png](attachment:cc8ac5ec-aaa6-4564-8921-616bb4b45b0a:image.png)

Jdbc Template을 직접 스프링 빈으로 등록하는 방식을 사용하고 싶은 경우 setDataSource를 set dbcTemplate으로 바꿔주면 됨.

### 중복 제거

get()과 getAll()의 RowMapper의 내용이 동일.

사용되는 상황은 다르지만 ResultSet 로우 하나를 User 오브젝트 하나로 변환해주는 동일한 기능을 가진 콜백.

User용 RowMapper 콜백을 메소드에서 분리해 중복을 없애고 재사용되게 만들 필요가 있음.

RowMapper 콜백 오브젝트에는 상태 정보가 없음.

따라서 하나의 콜백 오브젝트를 멀티스레드에서 동시에 사용해도 문제 x.

![image.png](attachment:4e754ab4-0b32-4db9-b80a-3d7df23e29ac:image.png)

인스턴스 변수에 저장해둔 userMapper 콜백 오브젝트는 아래와 같이 get()과 getAll()에서 사용하면 됨.

![image.png](attachment:b9f9d7b6-802b-48b0-a9d4-66f7346df61a:image.png)

### 템플릿/콜백 패턴과 UserDao

템플릿/콜백 패턴과 DI를 이용해 예외 처리와 리소스 관리, 유연한 DataSource 활용 방법까지 제공하는 최종적으로 완성된 UserDao 클래스.

![image.png](attachment:c9e45874-c006-4e70-a3cd-b0aadee82d68:image.png)

![image.png](attachment:78fdf620-ab31-4c06-8578-c3c139c056b8:image.png)

UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담겨 있음.

User라는 자바오브젝트와 USER 테이블 사이에 어떻게 정보를 주고 받을지, DB와 커뮤니케이션하기 위한 SQL 문장이 어떤 것인지에 대한 최적화된 코드를 갖고 있음.

만약 사용할 테이블과 필드 정보가 바뀌면 UserDao의 거의 모든 코드가 함께 바뀜 → 응집도가 높음.

반면, JDBC API를 사용하는 방식, 예외 처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 대한 책임과 관심은 모두 JdbcTemplate에 있음.

따라서 변경이 일어나더라도 UserDao 코드에는 영향 x → 낮은 결합도 유지.

다만, JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 가짐.

만약 더 낮은 결합도를 유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 사용하도록 만들어도 됨.

UserDao 추가 개선 방안

1. userMapper를 아예 UserDao 빈의 DI용 프로퍼티로 만들어 버리면 UserMapper를 독립된 빈으로 만들고 XML 설정에 User 테이블의 필드 이름과 User 오브젝트 프로퍼티 매핑 정보를 담을 수도 있을 것.이렇게 UsreMapper를 분리할 수 있다면 User의 프로퍼티와 User의 테이블의 이름이 바뀌거나 매핑 방식이 바뀌는 경우 UserDao 코드를 수정하지 않고도 매핑 정보를 변경할 수 있다는 것이 장점.
2.  DAO 메소드에서 사용하는 SQL 문장을 UserDao 코드가 아니라 외부 리소스에 담고 이를 읽어와 사용하게 하는 것. 이렇게 해두면 DB 테이블의 이름이나 필드 이름을 변경하거나 SQL 쿼리를 최적화해야 할 때도 UserDao 코드에는 손을 댈 필요 x.어떤 개발팀이 정책적으로 모든 SQL 쿼리를 DBA들이 만들어서 제공하고 관리하는 경우 SQL이 독립된 파일에 담겨 있다면 편리할 것
