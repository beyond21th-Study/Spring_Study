# 4주차

# 3.5 템플릿과 콜백

### 템플릿

템플릿(template)은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다. 학생들이 도형을 그릴 때 사용하는 도형자 또는 모양자가 바로 템플릿이다. 프로그래밍에서는 고정된 틀 안에 바꿀 수 있는 부분을 넣어서 사용하는 경우에 템플릿 이라고 부른다. JSP는 HTML이라는 고정된 부분에 EL과 스크립릿이라는 변하는 부분을 넣은 일종의 템플릿 파일이다. 템플릿 메소드 패턴은 고정된 틀의 로직을 가지는 템플릿 메소드를 슈퍼클래스에 두고, 바뀌는 부분을 서브클래스의 메소드에 두는 구조로 이뤄진다.

### 콜백

콜백(callback)은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다.

파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용한다. 자바에선 메소드 자체를 파라미터로 전달할 방법은 없기 때문에 메소드가 담긴 오브젝트를 전달해야 한다. 그래서 Functional Object라고도 한다.

- 그래서 JSP는 뭐고 EL, 스크립릿은 뭔데?
    
    JSP는 **Java Server Pages의 약자**로, HTML에 Java 코드를 삽입하여 동적인 웹 페이지를 만드는 서버 측 스크립팅 기술입니다. JSP는 내부적으로 자바 서블릿으로 변환되어 실행되며, 웹 개발자가 HTML과 Java 코드를 혼합해 웹 애플리케이션을 쉽게 개발하도록 돕습니다. 이 기술은 현재 'Jakarta Server Pages'로 이름이 변경되었습니다. 
    
    EL :  Expression Language 이란?
    
    표현식 또는 액션 태그를 대신해서 값을 표현하는 언어
    
    스크립릿(스크립트 릿)은 HTML과 JAVA를 섞어놓은 표현
    

### 3.5.1

템플릿/ 콜백의 동작원리

템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미에서 붙인 이름이다. 콜백은 템필릿 안에서 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

여러 개의 메소드를 가진 일반적인 인터페이스를 사용할 수 있는 전략 패턴의 전략과 달리 템플릿/콜백 패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다. 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다. 하나의 템플릿에서 여러 가지 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용할 수도 있다.

콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다고 보면 된다.콜백 인터페이싀 메소드에는 보통 파라미터가 있다. 이 파라미터는 템플릿의 작업 흐름중에 만들어지는 컨텍스트 정보를 전달받을 때 사용된다.

![image.png](image.png)

- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고, 콜백이 참조할 정보를 제공하는 것이다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
- 템플릿은 정해진 작업 흐름을 따라 작업을 진행하다가 내부에서 생성한 참조정보를 가지고 콜백 오브젝트의 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해서 작업을 수행하고 그 결과를 다시 템플릿에 돌려준다.
- 템플릿은 콜백이 돌려준 정보를 사용해서 작업을 마저 수행한다. 경우데 따라 최종 결과를 클라이언트에 다시 돌려주기도 한다.

조금 복잡해 보이지만 DI 방식의 전략 패턴 구조라고 생각하고 보면 간단하다. 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI다.

템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어난다.

일반적인 DI라면 템플릿에 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용할 것이다. 반면에 템플릿/콜백 방식에서는 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받는다는 것이 특징이다. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징이다. 클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적인 DI와 조금 다르다.

템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법이라고 이해할 수 있다. 단순히 전략패턴으로만 보기엔 독특한 특징이 많으므로 템플릿/콜백을 하나의 고유한 디자인 패턴으로 기억해두면 편리하다. 다만 이 패턴에 녹아 있는 전략 패턴과 수동 DI를 이해할 수 있어야한다.

![image.png](image%201.png)

위 사진은 UserDao, JdbcContext를 템플릿/콜백 패턴의 구조에서 살펴본 것이다.

JdbcContext의 workWithStatementStrategy() 템플릿은 리턴 값이 없는 단순한 구조다.

조회 작업에서는 보통 템플릿의 작업 결과를 클라이언트에 리턴해준다. 템플릿의 작업 흐름이 좀 더 복잡한 경우에는 한 번 이상 콜백을 호출하기도 하고 여러 개의 콜백을 클라이언트로부터 받아서 사용하기도 한다.

### 3.5.2 편리한 콜백의 재활용

템플릿/콜백 방식은 템플릿에 담긴 코드를 여기저기서 반복적으로 사용하는 원시적인 방법에 비해 많은 장점이 있다. 그런데 템플릿/콜백 방식에서 한 가지 아쉬운 점이 있다. DAO 메소드에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기가 조금 불편하다는 점이다.

### 콜백의 분리와 재활용

만약 분리를 통해 재사용이 가능한 코드를 찾아낼 수 있다면 익명 내부 클래스를 사용한 코드를 간결하게 만들 수도 있다.

![image.png](image%202.png)

위 사진을 본다면 makePreparedStatement() 메소드를 구현한 콜백 오브젝트 코드를 살펴보면 그 내용은 간단하다. 고정된 SQL 쿼리 하나를 담아서 PreparedStatement를 만드는게 전부다. 바인딩할 파라미터 없이 미리 만들어진 SQL을 이용해 PreparedStatement를 만들기만 하면 되는 콜백이 적지는 않을 것이다. 유사한 내용의 콜백 오브젝트가 반복될 가능성이 높다

여기서 ← 중복될 가능성이 있는 자주 바뀌지 않는 부분을 분리해보자

변하는 부분은 delete from users 부분이기 때문에 그 외의 부분을 분리하는 쪽으로 가보자

![image.png](image%203.png)

![image.png](image%204.png)

위의 사진을 보면 바뀌지 않는 모든 부분을 빼내서 executeSql() 메소드로 만들었다. 바뀌는 부분인 SQL 문장만 파라미터로 받아서 사용하게 만들었다. SQL을 담은 파라미터를 `final` 로 선언해서 익명 내부 클래스인 콜백 안에서 직접 사용할 수 있게 하는 것만 주의하면 된다.

리스트 3-2의 delteAll() 메소드와 비교한다면 확연히 차이점이 보일것이다.

**변하는 것과 변하지 않는 것을 분리하고 변하지 않는건 재활용할 수 있게 만든다는 간단한 원리**를 계속 적용했을 때 이렇게 단순하면서도 안전하게 작성 가능한 JDBC 활용 코드가 완성된다.

### 콜백과 템플릿의 결합

![image.png](image%205.png)

![image.png](image%206.png)

이렇게 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유할 수 있는 템플릿 클래스 안으로 옮겨 모든 DAO 메소드에서 executeSQL()메소드를 사용 가능하게끔 했다.

![image.png](image%207.png)

일반적으로 성격이 다른 코드들은 가능한 한 분리하는 편이 낫지만, 이 경우는 반대다.

하나의 목적을 위해 서로 긴밀하게 연관되어 동작하는 응집력이 강한 코드들이기 때문에 한 군데 모여 있는 게 유리하다. 구체적인 구현과 내부의 전략 패턴, 코드에 의한 DI, 익명 내부 클래스 등의 기술은 최대한 감춰두고, 외부에는 꼭 필요한 기능을 제공하는 단순한 메소드만 노출해주는 것이다.

### 3.5.3 템플릿/ 콜백의 응용

템플릿 / 콜백 패턴은 사실 스프링에서만 사용할 수 있다거나 스프링만이 제공해주는 독점적인 기술은 아니다. 하지만 스프링만큼 이 패턴을 적극적으로 활용하는 프레임워크는 없다. 스프링의 많은 API나 기능을 살펴보면 템플릿/콜백 패턴을 적용한 경우를 많이 발견할 수 있다.

따지고 보면 DI도 순수한 스프링의 기술은 아니다. 기본적으로는 객체지향의 장점을 잘 살려서 설계하고 구현하도록 도와주는 여러 가지 원칙과 패턴의 활용 결과일 뿐이다.

스프링은 단지 이를 편리하게 사용할 수 있도록 도와주는 컨테이너를 제공하고, 이런 패턴의 사용 방법을 지지해주는 것뿐이다. 

스프링을 사용하는 개발자라면 당연히 스프링이 제공하는 템플릿/콜백 기능을 잘 사용할 수 있어야 한다. 동시에 템플릿/콜백이 필요한 곳이 있으면 직접 만들어서 사용할줄도 알아야 한다.

![image.png](image%208.png)

모든 라인의 숫자를 읽어와서 합을 계산하는 테스트 코드를 준비했다.

![image.png](image%209.png)

FileIO 부분에서도 예외가 발생할 수 있기 때문에 예외처리를 진행한다.

![image.png](image%2010.png)

### 중복의 제거와 템플릿 / 콜백 설계

요구사항이 변경되어 모든 숫자의 곱을 계산하는 기능을 추가해야 한다는 요구가 발생했다.

파일을 읽어서 처리하는 비슷한 기능이 새로 필요할 때마다 앞에서 만든 코드를 복사해서 사용할 것인가?

→ 아니어야 한다. 한 두번까지는 어떻게 넘어간다고 해도, 세번 이상 반복된다면 본격적으로 코드를 개선할 시점이라고 생각해야 한다. 객체지향 언어를 사용하고 객체지향 설계를 통해 코드를 작성하는 개발자의 기본적인 자세다.

템플릿/콜백 패턴을 적용해보자. 먼저 템플릿에 담을 반복되는 작업 흐름은 어떤 것인지 살펴보고 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇이고, 콜백이 템플릿에게 돌려줄 내용은 무엇인지, 템플릿이 작업을 마친 뒤 전달해줘야 하는 것을 생각해야한다.

템플릿/콜백을 적용할 때는 템플릿과 콜백의 경계를 정하고 템플릿이 콜백에게, 콜백이 템플릿에게 각각 전달해야하는 내용이 무엇인지 파악하는게 가장 중요하다. 그에 따라 콜백의 인터페이스를 정의해야하기 때문이다.

![image.png](image%2011.png)

각각의 라인을 읽어 올 수 잇는 BufferedReader를 만들어서 콜백에게 전달해주고, 콜백이 각 라인을 읽어서 알아서 처리한 후에 최종 결과만 템플릿에게 돌려주는 것이다.

![image.png](image%2012.png)

템플릿 부분을 메소드로 분리해보자.

템플릿에서는 BufferedReaderCallback 인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행해주면 된다. 콜백이 돌려준 결과는 최정적으로 모든 처리를 마친 후에 다시 클라이언트에 돌려주면 된다.

![image.png](image%2013.png)

BufferedReader를 만들어서 넘겨주는 것과 그 외의 모든 번거로운 작업에 대한 작업 흐름은 템플릿에서 진행하고, 준비된 BufferedReader를 이용해 작업을 수행하는 부분은 콜백을 호출해서 처리하도록 만들었다.

이렇게 준비된 fileReadTemplate()을 사용하도록 하면 된다.

템플릿으로 분리한 부분을 제외한 나머지 코드를 BufferedReaderCallback 인터페이스로 만든 익명 내부 클래스에 담는다. 처리할 파일의 경로와 함께 준비된 익명 내부 클래스의 오브젝트를 템플릿에 전달한다.

![image.png](image%2014.png)

곱을 계산하는 콜백을 가진 calcMultiply 메소드는 이렇게 설계하면 된다.

### 템플릿/ 콜백의 재설계

![image.png](image%2015.png)

![image.png](image%2016.png)

조금만 살펴봐도 두 개의 코드가 아주 유사함을 알 수 있다.

템플릿과 콜백을 찾아낼 때는, 변하는 코드의 경계를 찾고 그 경계를 사이에 두고 주고받는 일정한 정보가 있는지 확인하면 된다고 했다. 여기서 바뀌는 코드는 실제로 네번째 줄뿐이다.

![image.png](image%2017.png)

LineCallback은 파일의 각 라인과 현재까지 계산한 값을 넘겨주도록 되어있다. 그리고 새로운 계산 결과를 리턴 값을 통해 전달받는다. 이 콜백을 기준으로 코드를 다시 정리해보면 템플릿에 포함되는 작업 흐름은 더 많아지고 콜백은 단순해질 것이다.

![image.png](image%2018.png)

![image.png](image%2019.png)

그림은 잘못되었지만 계산 결과를 저장할 초기 값은 initVal이다.

파라미터로 전달 받고, 템플릿에 파일의 각 라인을 읽는 작업이 추가됐다. 새로 만든 템플릿이 기존에 만들었던 템플릿들과 다른 점은 while 루프 안에서 콜백을 호출한다는 점이다. 콜백을 여러 번 반복적으로 호출하는 구조가 된 것이다.

![image.png](image%2020.png)

여타 로우레벌의 파일 처리 코드가 템플릿으로 분리되고 순사한 계산 로직만 남아 있기 때문에 코드의 관심이 무엇인지 명확하게 보인다. Calculator 클래스와 메소드는 데이터를 가져와 계산한다는 핵심 기능에 충실한 코드만 갖고 있게 됐다.

코드의 특성이 바뀌는 경계를 잘 살피고 그것을 인터페이스를 사용해 분리한다는, 가장 기본적인 객체지향 원칙에만 충실하면 어렵지 않게 템플릿/콜백 패턴을 만들어 활용할 수 있을 것이다.

### 제네릭스를 이용한 콜백 인터페이스

![image.png](image%2021.png)

지금까지 작성한 코드는 템플릿과 콜백이 만들어내는 결과가 Integer타입으로 고정되어있다.

만약 결과 타입을 다양하게 가져가고 싶다면 제네릭스를 사용하면 된다.

그럼 이제 확장해보자.

![image.png](image%2022.png)

![image.png](image%2023.png)

lineReadTemplate() 메소드는 이제 타입 파라미터 T를 갖는 인터페이스 LineCallback 타입의 오브젝트와 T 타입의 초기값 initVal을 받아서, T 타입의 변수 res를 정의하고, T 타입 파라미터로 선언된 LineCallback의 메소드를 호출해서 처리한 후에 T 타입의 결과를 리턴하는 메소드가 되는 것이다.

![image.png](image%2024.png)

## 3.6 스프링의 JDBCTemplate

스프링은 JDBC를 이용하는 DAO에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공한다. 거의 모든 종류의 JDBC 코드에 사용 가능한 템플릿과 콜백을 제공할 뿐만 아니라, 자주 사용되는 패턴을 가진 콜백은 다시 템플릿에 결합시켜서 간단한 메소드 호출만으로 사용이 가능하도록 만들어져 있기 때문에 템플릿/콜백 방식의 기술을 사용하고 있는지 모르고도 쓸 수 있을 정도로 편리하다.

스프링이 제공하는 JDBC코드용 기본 템플릿은 JdbcTemplate이다.

![image.png](image%2025.png)

JdbcTemplate의 콜백은 PreparedStatementCreator 인터페이스의 createPreparedStatement() 메소드다. 템플릿으로부터 Connection을 제공받아서 PreparedStatement를 만들어 돌려준다는 면에서 구조는 동일하다. PreparedStatementCreator 타입의 콜백을 받아서 사용하는 JdbcTemplate의 템플릿 메소드는 update()다.

![image.png](image%2026.png)

![image.png](image%2027.png)

### 3.6.2 queryForInt()

getCount()는 SQL 쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드다.

이런 작업 흐름을 가진 코드에서 사용할 수 있는 템플릿은 PreparedStatementCreator 콜백과 ResultSetExtractor 콜백을 파라미터로 받는 query() 메소드다.

ResultSetExtractor는 PreparedStatement의 쿼리를 실행해서 얻은 ResultSet을 전달받는 콜백이다. ResultSetExtractor 콜백은 템플릿이 제공하는 ResultSet을 이용해 원하는 값을 추출해서 템플릿에 전달하면, 템플릿은 나머지 작업을 수행한 뒤에 그 값을 query()메소드의 리턴 값으로 돌려준다.

![image.png](image%2028.png)

![image.png](image%2029.png)

이렇게 두개의 익명 내부 클래스를 JdbcTemplate는 queryForInt()라는 편리한 메소드를 제공해준다.

이 메소드를 사용하면 위 코드를 아래 사진과 같이 정리할 수 있다.

![image.png](image%2030.png)

### 3.6.3 queryForObject()

get() 메소드는 지금까지 만들었던 것 중에서 가장 복잡하다.

일단 SQL은 바인딩이 필요한 치환자(?)를 가지고 있다.

ResultSet에서 getCount()처럼 단순한 값이 아니라 복잡한 User 오브젝트로 만드는 작업이다. ResultSet에서 결과를 User 오브젝트로 만들어 프로퍼티에 넣어줘야 한다.

ResultSetExtractor 콜백 대신 RowMapper 콜백을 사용해야 한다.

ResultSetExtractor와 RowMapper 모두 템플릿으로부터 ResultSet을 전달받고, 필요한 정보를 추출해서 리턴하는 방식으로 동작한다. 다른 점은 ResultSetExtractor는 ResultSet을 한 번 전달받아 알아서 추출 작업을 모두 진행하고 최종 결과만 리턴해주면 되는 데 반해, RowMapper는 ResultSet의 로우 하나를 매핑하기 위해 사용되기 때문에 여러 번 호출될 수 있다는 점이다.

![image.png](image%2031.png)

기본 키 값으로 조회하는 get() 메소드 SQL의 실행 결과는 로우가 하나인 ResultSet이다. ResultSet의 첫ㅎ 번째 로우에 RowMapper를 적용하도록 만들면 된다. RowMapper 콜백은 첫 번째 로우에 담긴 정보를 하나의  User 오브젝트에 매핑하게 해주면 된다.

가변인자가 아닌 Obejct 타입 배열을 사용한 이유는 뒤에 다른 파라미터가 있기 때문이다. 배열 초기화 블록을 사용해서 SQL의 ?에 바인딩할 id 값을 전달한다.

queryForObject()는 SQL을 실행하면 한 개의 로우만 얻을 것이라고 기대한다. 그리고 ResultSet의 next()를 실행해서 첫 번째 로우로 이동시킨 후에 RowMapper 콜백을 호출한다. 이미 RowMapper가 호출되는 시점에서 ResultSet은 첫 번째 로우를 가리키고 있으므로 다시 rs.next()를 호출할 필요는 없다. RowMapper에서는 현재 ResultSet이 가리키고 있는 로우의 내용을 User 오브젝트에 그대로 담아서 리턴해주기만 하면 된다.

queryForObject()는 SQL을 실행해서 받은 로우의 개수가 하나가 아니라면 예외를 던지도록 만들어져 있다.

이때 던져지는 예외가 바로 EmptyResultDataAccessException이다.

### 3.6.4 query()

![image.png](image%2032.png)

query()는 여러 개의 로우가 결과로 나오는 일반적인 경우에 쓸 수 있다.

리턴타입은 List<T>다. query()는 제네릭 메소드로 타입은 파라미터로 넘기는 RowMapper<T> 콜백 오브젝트에서 결정된다.

바인딩 할 파라미터가 있다면 두번째 파라미터에 추가할 수도 있고, 없다면 생략할 수도 있다.

### 3.6.5 재사용 가능한 콜백의 분리

### DI를 위한 코드 정리

![image.png](image%2033.png)

UserDao의 모든 메소드가 JdbcTemplate을 이용하도록 만들었으니 DataSource를 직접 사용할 일은 없기때문에 제거한다.

### 중복 제거

![image.png](image%2034.png)

![image.png](image%2035.png)

다양한 조건으로 사용자를 조회하는 검색 기능이 추가될 수도 있고 RowMapper는 한 두번 사용될 것 같지 않아 분리를 한다.

RowMapper 콜백 오브젝트에는 상태 정보가 없다. 따라서 하나의 콜백 오브젝트를 멀티스레드에서 동시에 사용해도 문제가 되지 않는다. RowMapper 콜백은 하나만 만들어서 공유하자.

### 템플릿/ 콜백 패턴과 UserDao

![image.png](image%2036.png)

![image.png](image%2037.png)

JDBC API를 사용하는 방식, 예외처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은 모두 JdbcTemplate에게 있다. 따라서 변경이 일어난다고 해도 UserDao코드에는 아무런 영향을 주지 않는다. 그런 면에서 책임이 다른 코드와는 낮은 결합도를 유지하고 있다. 다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 갖고 있다. JdbcTemplate이 스프링에서 JDBC를 이용해 DAO를 만드는 데 사용되는 사실상 표준 기술이고, JDBC 대신 다른 데이터 액세스 기술을 사용하지 않는 한 바뀔 리도 없겠지만, 그대로 더 낮은 결합도를 유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 사용하도록 만들어도 된다.

장기적으로 봤을 때 개선할 점은

첫째는 userMapper가 인스턴스 변수로 설정되어 있고, 한 번 만들어지면 변경되지 않는 프로퍼티와 같은 성격을 띠고 있으니 아예 UserDao 빈의 DI용 프로퍼티로 만들어버리면 어떨까

둘째는 DAO 메소드에서 사용하는 SQL 문장을 UserDao 코드가 아니라 외부 리소스에 담고 이를 읽어와 사용하게 하는 것이다.