[ week4 String Study ]

- 템플릿과 콜백
    * UserDao와 StatementStrategy, JdbcContext를 이용한 코드는 전략 패턴이 적용된 것.
    * -> 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 일부분만 자주바꾸는 경우 적합함.
    * 전략 패턴의 기본 구조는 익명 내부 클래스를 활용한 방식. -> 템플릿/ 콜백 패턴 이라고 부름.
    * 전략 패턴의 컨텍스트를 템플릿이라하고, 익명 내부 클래스로 만들어지는 오브젝트를 콜백이라고 함.


- 콜백(CallBack)
    * 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말함.
    * 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용.
    * 자바는 메소드 자체를 파라미터로 전달할 방법은 없어서 메소드가 담긴 오브젝트를 전달해야함. -> 메소드를 호출해서 클라이언트의 특정 행위를 “불러내는” 역할을 하기 때문.


- 템플릿/콜백의 특징
    * 보통 단일 메소드 인터페이스를 사용. 이유는? -> 템플릿의 작업흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적.
    * 전달하는 기능을 한가지 책임으로 제한하여 코드 가독성과 유지보수성 UP!
    * 여러 긴으 필요하면 콜백 여러개의 콜백 오브젝트를 사용하는 방식으로 확장 가능!

￼
    * 복잡해보이지만 DI 방식의 전략 패턴 구조라 보면 간단하다. 
    * 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI.
    * DI작업이 클라이언트가 템플릿의 기능을 호출할때 동시에 일어남.

    * 일반적인 경우 -> 인스턴스 변수를 만들어두고 사용할 의존 오브젝트를 수정자 메소드로 받아서 사용.
    * BUT 매번 메소드 단위로 사용할 오브젝트를 새롭제 전달받음.
    * 콜백 옵젝은 내부 클래스로서 자신이 생성한 클라이언트 메소드 내의 정보에 직접 참조한다는 것이 고유한 특징.

    * 클라이언트와 콜백이 강하게 결합된다는 면에서도 일반적인 DI와 조금 다르다
    * 뭐가 다른데? ->  템플릿/콜백은 콜백 객체가 클라이언트 내부에 익명 클래스로 구현되어 있어 상대적으로 강한 결합이 생기고, DI는 의존 객체가 외부에서 주입되어 느슨한 결합을 지향한다는 점에서 구조적인 차이가 있습니다. 이로 인해 템플릿/콜백은 특정 기능의 즉시 변경과 재활용이 쉬움



- 편리한 콜백의 재활용
    * 템플릿/콜백 방식은 템플릿에 담긴 코드를 여기저기서 반복적으로 사용하는 원시적인 방법에 비해 많은 장점이 있음.
        * 코드 재사용성, 유지보수성 향상, 변경 영역의 분리, 간결성, 유연성.

    * 아쉬운 점 : 매번 익명 내부 클래스 사용 -> 코드를 작성하고 읽기가 조금 불편.(코드가 답답해 보일 수 있음.)



- 콜백의 분리와 재활용
￼
    * StatementStrategy 인터페이스의 makePreparedStatement() 메소드를 구현한 것.
    * 고정된 SQL 쿼리를 담아서 PreparedStatement를 만드는 코드.
    * 콜백 오브젝트가 반복될 가능성이 높음.

    * 반복되는 부분과 자주 바뀌지 않는 부분을 분리하는것이 중요.
￼
* 바뀌지 않는 excuteSql() 메소드를 만들고, 바뀌는 부분은 SQL 문장만 파라미터로 받아서 사용하게 만듬.(재사용성)
* SQL파라미터를 final로 선언 -> 익명 클래스인 콜백안에서 직접 사용하는 것만 주의.



- 콜백과 템플릿의 결합
    * 콜백을 담고있는 메소드를 UserDao만 사용하기보다 DAO가 공유할 수 있는 템플릿에서도 사용가능.
￼
    * 메소드 접근자는 public으로 바꿔서 외부에서 바로 접근이 가능하다.

￼
    * executeSql()메소드가 JdbcContext로 이동했으니 UserDao의 메소드에서도 호출하도록 수정한 것.

    * 이제 모든 DAO 메소드에서 executeSql() 메소드 사용 가능. -> JdbcContext안에 클라이언트 템플릿, 콜백 모두 함께 공존하며 동작하는 구조가 됐당.

￼
    * 위의 그림처럼 성격이 다른 코드들은 분리하는 편이 낫다. 하지만 하나의 목적을 위해 서로 긴밀하게 연결되어있으면 좋기때문.


- 템플릿/콜백의 응용
    * 스프링에서만 사용하는 독점기술 아님. -> 스프링만큼 적극활용하는 프레임워크는 없음.
    * 바뀌는 부분이 한개의 애플리케이션 안에서 동시에 여러 종류가 만들어질 수 있다면 템플릿/콜백 패턴 적용을 고려하자.
    * 전형적인 후보는 try/catch/finally 블록을 사용하는 코드. 예외가 발생할 가능성이 있는 코드는 한두 번 사용되는 것이 아니라 적용하기에 적당하다.


- 테스트와 try/catch/finally
    * 파일을 하나 열어서 모든 라인의 숫자를 던한 합을 돌려주는 코드를 만들어보자.
￼
    * 이렇게 있으면 컴파일도 안되서 Calculator 클래스를 만들어보자.
￼



    *  파일을 읽거나 처리하다 예외가 발생하면, 파일이 정상적으로 닫히지 않고 메소드를 빠져나가는 문제 발생
    * -> try/finally 블록을 적용 -> 그리고 반드시 닫아줘야함. 예외발생시 로그 남기는 기능도 추가.
￼


- 중복 제거와 템플릿/콜백 설계
    * 일단 반복되는 작업의 흐름을 보고, 템플릿이 콜백에게 전달해줄 내부의 정보는 무엇인지, 콜백이 템플릿에게 돌려줄 내용도 생각해본다. 이렇게 템플릿과 콜백에게 각각 전달하는 내용이 무엇인지 파악하는게 가장 중요.
    * 아래 그림은 BufferedReader를 만들어 콜백에게 전달해주고, 콜백이 각 라인을 읽어서 알아서 처리한 후 최종 결과만 템플릿에게 전해주는 코드이다.
￼


    * 이제 메소드 분리. BufferdReaderCallback 인터페이스 타입의 콜백 오브젝트를 받아서 적절한 시점에 실행.
    * 그리고 콜백이 돌려준 결과는 최종적으로 다시 클라이언트에 돌려준다.
￼


￼
    * 템플릿으로 분리한 부분 제외 나머지 코드를 BufferedReaderCallback 인터페이스로 만든 익명 내부 클래스에 담는다.
    * 처리할 파일의 경로와 함께 준비된 익명 내부 클래스의 오브젝트를 템플릿에 전달함. 템플릿이 리턴하는 값을 최종값으로 사용.



    * 파일에 숫자의 곱을 구하는 메소드도 템플릿/콜백을 이용할건데 위에 사용했던 클래스 오브젝트와 파일 이름이 공유되니
    * @Before 메소드에서 미리 픽스처로 만들자.

* —> 픽스처(fixture)는 테스트에 필요한 고정된 상태 또는 환경을 의미하며, 예를 들어 테스트에 공통으로 사용되는 객체나 데이터 등이 이에 포함됩니다. 픽스처를 생성하고 관리하는데 @Before 메서드를 활용해 테스트마다 필요한 객체를 준비해 중복 코드를 줄이고 테스트의 일관성을 확보합니다.
￼


- 템플릿/콜백의 재설계
￼
￼
    * 코드가 아주 유사함. -> 결과를 저장할 변수(multiply, sum)을 초기화하고 BufferedReader를 이용해 파일의 마지막 라인까지 순차적으로 읽고 각 라인에서 읽은 내용을 결과에 저장할 변수의 값과 함께 계산하다, 파일을 다 읽으면 결과를 저장하고 변수의 값을 리턴하는 방식이다.


￼
* LineCallback : 파일의 각 라인을 읽을 때, 템플릿 메서드에서 이 콜백 메서드를 호출해 클라이언트가 원하는 라인별 처리를 수행하도록 위임.
    * LineCallback 인터페이스를 경계로 만든 템플릿.
￼
￼




    * 템플릿에 파일의 각 라인을 읽는 작업이 추가. 계산 결과를 담을 변수를 초기화할값도 파라미터도 받을 수 있음.
    * While 루프 안에서 콜백을 호출한다. -> 콜백 여러번 호출.
￼
    * 순수한 계산 로직만 남아있어 코드의 관심이 무엇인지 명확하게 확인가능.


- 제네릭스를 이용한 콜백 인터페이스
    * 파일을 라인 단위로 처리해서 만드는 결과의 타입을 다양하게 가져가고싶어 -> 제네릭스(Generics).


    * 콜백 메소드의 리턴 값과 파라미터의 값의 타입을 제네릭 타입과 파라미터 T로 선언.
￼
    * 이제 제네릭 메소드를 만들건데 콜백의 타입 파라미터와 초기값인 initVal의 타입, 템플릿의 결과 값 타입을 모두 동일하게 설정하는 것이 중요하다.
￼
* 제네릭스 타입 일관성이 중요한 이유
        * 타입 일관성 유지, 타입 변환 방지, 코드의 명확성.

    * 파라미터 T를 갖는 인터페이스 LineCallback 타입의 오브젝트와 T 타입의 초기값 initVal을 받아서 T 타입의 변수 res를 정의하고, T 타입의 파라미터로 선언된 LineCallback의 메소드를 호출해서 처리한 후 T 타입의 결과를 리턴하는 메소드이다.




￼
    * 모든 라인의 내용을 하나의 문자열로 길게 연결하는 기능을 가진 메소드이다.
    * lineReadTemplate로 템플릿 메소드의 T는 모두 스트링이된다. -> lineReadTemplate()메소드의 결과도 스트링 타입이 되서 concatenate()메소드의 리턴 타입도 스트링으로 정의할 수 있다.




￼
    * 예를들어 Integer타입으로 인터페이스에서 정의해주면 그대로 사용할 수 있다.




- 스프링의 JdbcTemplate
    * JDBC API 복잡성을 추상화하여 DB 작업을 간편하고 효율적으로 수행할 수 있게 해준다.

- 장점
    * 반복 작업 자동 처리
    * 예외 처리 통합
    * 템플릿 콜백 패턴 사용
    * 파라미터 바인딩 지원
        * 순서 기반 파라미터 바인딩(물음표 ? 사용)을 지원하며, NamedParameterJdbcTemplate를 통해 이름 기반 파라미터 바인딩도 가능합니다.
    * 간단한 메서드 제공
        * Query, update, queryForList, queryForMap, execute 등 메서드로 SQL 실행과 결과를 간편히 수행 가능.
    * 자원 관리 자동화
        * Connection, Statement, ResultSet을 자동으로 관리.
    * 스프링 통합
—> 이로 인해 JdbcTemplate은 코드 중복을 줄이고 개발 생산성을 높이며, 안정적인 데이터베이스 접근을 가능하게 함.




￼
    * JdbcTemplate은 위의 그림대로 생성자의 파라미터로 DataSource를 주입하면 된다.



- update()
    * JdbcTemplate의 콜백은 PreparedStatementCreator 인터페이스의 createPreparedStatement()메소드다.  템플릿으로부터 Connection을 제공받아서 PreparedStatement를 돌려준다는 면에서 구조는 동일하다. 메소드는 Update()이다.
￼
￼
    * 아펏서 했던 executeSql()은 SQL 문장만 전달하면 미리 준비된 콜백을 만들어서 템플릿을 호출하는 것까지 한번에 해주는 편리한 메소드였다. JdbcTemplate에서는 콜백을 받는 update()메소드와 이름은 동일한데 파라미터로 SQL 문장을 전달하는 것만 다르다.
￼


    * JdbcTemplate은 add()메소드에 대한 편리한 메소드도 제공된다. -> SQL과 함께 가변인자로 선언된 파라미터를 제공하면 됨.
￼
    * PreparedStatement를 만들때 사용하는 SQL은 동일하고 바인딩 할 파라미터를 순서대로 넣어주면된다.


- queryForInt()
    * JdbcTemplate를 적용하지 않았던 메소드에 적용을 해보자

    * getCount()는 SQL쿼리를 실행하고 ResultSet을 통해 결과 값을 가져오는 코드이다.
￼
￼
    * 첫번째 PreparedStatementCreator 콜백은 템플릿으로부터 Connection을 받고 PreparedStatement를 돌려준다. 
    * 두번째ResultSetExtractor는 템플릿으로부터 ResultSet을 받고 거기서 추출한 결과를 돌려준다.

    * 원래 getCount() 메소드에 있던 코드 중에서 변하는 부분만 콜백으로 만들어져서 제공된다고 생각하면 이해하기 쉽다.
    * 클라이언트/템플릿/콜백의 3단계 구조이니, 콜백이 만들어낸 결과는 템플릿을 걸쳐야만 클라이언트인 getCount() 메소드로 넘어오는 것이다.

    * 또한 여기서 눈여겨볼 것 -> ResultSetExtractor는 제네릭스 타입 파라미터를 갖는다는 점이다.
    * 사용한 이유 : ResultSet에서 추출할 수 있는 값의 타입은 다영하기 때문에 타입 파라미터를 사용했음.




    * JdbcTemplate은 queryForInt()라는 편리한 메소드를 통해 SQL 문장만 전달해주면 된다.
￼
    * 메소드가 한줄로 변함 WOW~




- queryForObject()
    * get()메소드에 JdbcTemplate를 적용할 것.
    * SQL은 바인딩 치환자를 가지고 있고, 복잡한 User 오브젝트 만들고 ResultSet결과를 User 오브젝트를 만들어 프로퍼티로 넣어줘야한다. 
    * queryForObject()는 단일 행을 조회하는데 특화된 메소드로, 쿼리 실행 결과가 정확히 1개일때 사용된다.
￼
    * 적용 결과 Connection, PreparedStatement, ResultSet의 생성 및 해제, 예외 처리 등 반복 코드가 모두 제거된다.
    * queryForObject() 메소드 파라미터
        * SQL 쿼리문
        * 파라미터터 배열(SQL의 물음표(?)에 바인딩 될 값들)
        * RowMapper : ResultSet을 자바 객체로 변환하는 매퍼.
    * RowMapper의 역할
        * mapRow()메소드는 SQL 실행 결과로 얻은 ResultSet에서 한 행의 데이터를 읽어와 자바 객체로 변환한다.
        * 그리고 예외 처리는 성능 오버헤드가 있으므로, 예상 가능한 경우라면 LIMIT 1을 사용하는 것이 효율적.


- query()
* 기능 정의와 테스트 작성
    * RowMapper를 getAll()메소드로 사용해보면. List<User> 타입으로 하는 것이 낫다.
    * User 타입의 오브젝트인 user1, user2, user3 세 개를 DB에 등록하고 getAll()을 호출하면 List<User>타입으로 돌려받아야한다. 저장할때는 동일성 비교가 아니라 동등성 비교를 해야한다.
￼
    * 이때 Id 순서대로 정렬된다. 그래서 user3은 가장 마지막에 추가되지만 getAll()결과에서는 가장 첫번째이다.
    * User의 값을 비교하는 코드가 반복되기 떄문에 별도의 메소드로 분리한다. 


- query() 템플릿을 이용하는 getAll() 구현
￼
    * 첫 번째 파라미터에는 실행할 SQL 쿼리를 넣는다. 마지막 파라미터는 RowMapper 콜백이다. SQL을 실행해서 얻은 ResultSet의 모든 로우를 열람하면서 로우마다 RowMapper 콜백을 호출한다. 로우의 개수만큼 호출될 것이다.
    * 이렇게 만들어진 User 오브젝트는 List<User> 컬렉션에 추가된다. 그리고 로우에 대한 작업 마치면 List<User> 오브젝트가 리턴됨.



- 테스트 보완
    * 네거티브 테스트는 항상 중요 -> 예외상황에 대한 테스트를 빼먹기 쉽기 때문


- DI를 위한 코드 정리
    * JdbcTemplate를 이용하니 DataSource를 직접 사용할 일은 없다.
    * 하지만 DI를 쓰기위해 DataSource를 전달받아야하는 수정자 메소드는 남겨둔다.
￼
    * JdbcTemplate을 직접 스프링 빈으로 등록하는 방식을 사용하고 싶다면 setDataSource를 setJdbcTemplate으로 바꿔주기만하면된다.


- 중복 제거
    * get()과 getAll() 사용한 것으로 보면 RowMapper내용이 똑같다. 지금은 두번 중복이지만 앞으로 추가될 사용자 검색 기능, 다양한 조건으로 검색 기능이 추가될 수 있기 때문에 동일한 RowMapper를 매번 쓰는 것 보다 분리해주는게 좋을 것 이다.

    * 그래서 메소드에서 분리하고 재사용하게 만들어야한다. 
    * 아래 그림처럼 userMapper라는 이름으로 인스턴스 변수를 만들고 사용할 매핑용 콜백 오브젝트를 초기화한다. 익명 내부 클래스는 클래스 안에서라면 어디서든 만들 수 있다.
￼



    * 그리고 userMapper 콜백 오브젝트 사용한 그림이다.
￼



    * UserDao에는 User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담겨 있다.
    * 만약 사용할 테이블과 필드정보가 바뀌면 UserDao의 거의 모든 코드가 함께 바뀐다 -> 응집도가 높다
    * IoC로 인해 JDBC API 사용하는 방식, 예외처리, 리소스의 반납, DB연결은 모두 JdbcTemplate에 있다.

    * 만약 더 낮은 결합도를 유지하고 싶다면 JdbcTemplate를 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI 받아 사용하면 된다.
