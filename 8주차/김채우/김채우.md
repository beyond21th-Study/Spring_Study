# 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션
- 스프링으로는 자바 엔터프라이즈 시스템 개발이나 독립형 프로그램도 개발 가능
- 주로 엔터프라이즈 환경에서 동작하는 애플리케이션을 개발하는 목적으로 사용
- 다른 형태의 애플리케이션에 스프링을 제대로 적용하기 위해서는 SpringRCP 프로젝트나 Spring.me같은 스프링 지원 기술 필요

## 클라이언트와 백엔드 시스템
- 엔터프라이즈 애플리케이션은 자신이 클라이언트가 되어 또 다른 엔터프라이즈 시스템에 서비스 요청 가능 
- 또는 엔터프라이즈 정보 시스템이라 불리는 백엔드 시스템의 기능을 이용해 동작하기도 함
- 클라이언트-웹 브라우저, 백엔드-DB인 구성을 가장 많이 사용
  - DB를 사용하는 웹 애플리케이션
- 스프링의 주요 기능은 웹 브라우저를 클라이언트로 하고 DB에 데이터를 저장, 조회하는 데 집중되어 있음
- 자바 서버가 받아들일 수 있는 방식으로 요청을 보내기만 한다면 꼭 클라이언트가 웹 브라우저일 필요는 없음
![img.png](img.png)
## 애플리케이션 서버
- 스프링 애플리케이션을 자바 서버환경에 배포하려면 JavaEE 서버 필요
- 웹 애플리케이션 서버(WAS)와 경량급 WAS 또는 서블릿/JSP 컨테이너
### 경량급 WAS/서블릿 컨테이너
- 스프링은 기본적으로 톰캣이나 제타같은 가벼운 서블릿 컨테이너만으로 충분
- 분산 서비스 등이 굳이 필요하지 않다면 서블릿 컨테이너로도 충분
### WAS
- 장점
  - 고도의 안정성
  - 안정적인 리소스 관리
  - 레거시 시스템의 연동
  - 자바 엔터프라이즈 버전 표준을 최대한으로 활용
  - WAS 사용할 것을 권장

## 스프링소스 tcServer
- 가장 많이 사용되는 것은 아파치 톰캣
- 톰캣 기반으로 엔터프라이즈 스프링 애플리케이션에 최적화된 경량급 애플리케이션 서버가 tcServer
- 고급 서버 관리 기능, 배포 기능과 진단 기능, 기술 지원 등 제공

## 스프링 애플리케이션의 배포 단위
### 독립 웹 모듈
- 보통 war로 패키징된 웹 모듈로 배포
- 톰캣 같은 서블릿 컨테이너를 쓴다면 독립 웹 모듈이 유일한 방법
- 가장 단순하고 편리한 방법
### 엔터프라이즈 애플리케이션
- 확장자가 ear인 엔터프라이즈 애플리케이션으로 패키징해 배포 가능
- EJB 모듈과 연결해야 한다면 EJB와 스프링 웹 모듈을 엔터프라이즈 애플리케이션으로 통합해야 함 
- 하나 이상의 웹 모듈과 별도로 분리된 공유 가능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶기도 함
### 백그라운드 서비스 모듈
- rar 패키징 방법
- rar는 리소스 커넥터를 만들어 배포할 때 사용하는 방식
- 스프링으로 만든 애플리케이션이 UI를 가질 필요가 없고 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있다면 rar 모듈로 만들어 배포 가능 
- J2EE 1.4나 그 이상 표준을 따르는 WAS가 반드시 필요

# 개발도구와 환경
## JavaSE와 JavaEE
### JavaSE/JDK
- 기본적으로 JDK 5.0 또는 그 이상을 필요
- 일부 기능은 JDK 6.0의 API를 이용해 개발된 것도 있음
- JDK 5.0이나 그 이후 버전을 사용하는 것이 좋음
### JavaEE/J2EE
- J2EE 1.4버전 서버를 사용할 대는 JDK 5.0에서 동작하는지 반드시 확인

## IDE
- 이클립스, IntelliJ 등

## SpringSource Tool Suite
- 이클립스의 확장판
- 이클립스 기반으로 스프링 지원 플러그인과 관련 도구를 모아 스프링 갲발에 최적화되도록 만들얼진 IDE
- 플러그인 방식을 지원하는 툴을 사용하면 원하는 기능을 필요에 따라 추가 가능
- 각 플러그인 과 이클립스 버전을 호환이 되도록 맞춰야 하는 불편함도 있음
- 따라서 플러그인 조합이 완료된 STS를 사용하는 편이 유리
### SpringIDE 플러그인
- 다양한 기능 제공
- XML 설정파일 에디터롤 클래스 이름이나 참조하는 빈의 이름 실시간 검증해 오류 줄여줌
### SpringIDE의 XML 에디터의 자동완성 기능
- 빈 클래스 이름 자동완성
  - 자동완성 해줌 
- 빈 설정 오류 검증
  - 빈 설정 내용을 작업하다가 존재하지 않는 클래스 이름이거나 잘못된 프로퍼티를 입력하면 알려줌
- 프로젝트 생성, 설정파일 생성, 빈 등록 위저드
  - 스프링 프로젝트 생성을 위해 스프링 프로젝트 위저드 이용 가능
  - 스프링 프로젝트를 만드는 데 필요한 라이브러리 선정이나 빌드 스크립트 추가, 프로젝트 구조 등을 지정할 수 있는 고급 기능은 지원 안 함
- 빈 의존관계 그래프
  - ![img_1.png](img_1.png)
- AOP 적용 대상 표시
  - AOP가 어려운 이유는 부가기능을 담은 어드바이스가 어느 오브젝트에 적용될지 한 눈에 보이지 않기 때문
  - 직접 AOP 적용 클래스나 인터페이스에 어노테이션을 추가하는 방법을 사용한면 좀 나음
  - XML 설정 파일 편집기를 사용하면 편함 
  - 포인트컷이 적용되는 대상 빈을 설정파일 안에서 한 눈에 확인할 수 있게 도와줌
### STS 플러그인
- 서버 배치와 같은 추가 기능 제공
- 가상화와 클라우드 서비스에도 손쉽게 스프링 애플리케이션을 배치할 수 있도록 지원
### 기타 플러그인
- M2Eclipse
  - Maven 지원하는 이클립스 플러그인
  - Maven은 의존 라이브러리 관리에 뛰어남
  - 외부 레포지토리에 번들이라 불리는 라이브러리와 의존정보를 두고 이를 프로젝트 모델 정보를 이용해 쉽게 가져다 씀
- AJDT
  - AspectJ Development Tool
  - AspectJ AOP를 이용한 개발을 지원하는 툴
- VMCI
  - VMWare 서버 또는 워크스테이션과의 연동 지원
  - STS의 VMWare 배치 기능에 주로 사용되기 위해 추가된 것
- 이클립스 표준 플러그인
  - WTP, EMP, Mylyn, DSDP 등
# 라이브러리 관리와 빌드 툴
## 라이브러리 관리의 어려움
- 필요 라이브러리는 정말 많음
- 하지만 전부 당장 필요한 라이브러리는 아님
- 라이브러리의 버전도 중요 
- 라이브러리끼리 서로 다른 버전에 의존하고 있을 수도 있음 
- 자바의 jar는 압축 패키징 방법일 뿐이지 구분 가능한 독립된 모듈이 아님 
- 재패키징으로 다양한 버전에 따른 호환성 문제 해결
  - 한쪽 버전의 클래스를 다른 패키지로 옮겨 서로 구별되는 클래스로 만들어주는 방법
  - 이에 의존하던 라이브러리 코드도 수정해야 함
  - 재패키징은 간단하지 않음
  - 재패키징을 지원해 주는 툴도 존재
## 라이브러리 선정
### 스프링 모듈
- 스프링에는 총 20개의 모듈 존재 
- 일부는 거의 모든 애플리케이션에서 공통적으로 사용되는 필수 모듈 
- 그 외 모듈은 애플리케이션의 아키텍처와 사용 기술에 따라 선택적으로 적용 가능
- 스프링 모듈 사이에도 의존관계 존재
- 필수냐 아니냐에 따라 넣을지 말지 결정
### 라이브러리
- 스프링 모듈은 오픈소스 라이브러리 또는 표준 API를 필요로 하기도, 상용 제품의 라이브러리에 의존하기도 함
- 스프링 모듈과 그에 의존하는 라이브러리의 종류와 특징을 살펴보고 그 중 적절한 라이브러리 선택 
## 빌드 툴과 라이브러리 관리
- Maven과 ANT는 자바의 대표적인 빌드 툴
- 일관된 빌드가 가능하도록 만드는 것이 중요
- 애플리케이션을 직접 빌드해야 하는 경우 IDE에서와 동일하게 애플리케이션 빌드 작업이 수행되어야 함 
- 자동빌드를 지원하는 IDE를 이용하며 ANT나 Maven 같은 환경에 독립적인 빌드 툴을 함께 사용하는 것이 바람직 
- Maven
  - 빌드, 테스트, 배치, 문서화, 리포팅 등 다양한 작업 지원 
  - 선언적
  - 애플리케이션이 필요로 하는 의존 라이브러리를 선언해 두기만 하면 원격 서버에서 이를 자동으로 다운로드 받아 사용 가능 
  - 전이적 의존 라이브러리 추적 기능
    - 의존정보에 하나의 라이브러리를 지정하면 지정된 라이브러리가 동작하는데 필요한 여타 라이브러리까지 함께 다운로드해줌
    - 잘 정의된 의존정보를 가진 라이브러리들을 갖고 있으면 한두 개의 최상위 의존 라이브러리를 지정해줌으로써 그에 필요한 모든 라이브러리를 간단히 추가 가능
    - 의존 라이브러리 정보만 갖게 하고 필요한 라이브러리는 Maven 빌드 과정 중 자동으로 다운로드 받거나 로컬 공통 레포지토리에서 가져오게 하면 프로젝트 파일의 크기도 줄어들고 코드 관리도 단순
  - 스프링의 모든 모듈은 POM 정보를 가짐
    - 이 정보로 모듈을 사용하는데 필요한 라이브러리와 그 버전을 알 수 있음
    - 하지만 선택 라이브리는 Maven의 전이적 의존 라이브러리 추적 기능의 적용을 받지 못 함
    - 사용하려면 명시적으로 POM에 선언해 줘야 함 
  - 라이브러리의 효과적인 관리를 위해 Maven과 같은 툴을 사용해 주는 것이 좋음
  - 공통 기술 POM을 만들고 공유, Maven POM 파일에 해당 POM 자체를 의존정보로 넣으면 모든 라이브러리가 프로젝트에 자동으로 등록됨
  - 의존 라이브러리의 그룹을 만들고 이를 POM과 같은 빌드 툴이 활용할 정보로 생성해 두면 다음부터 편하게 조합해 모듈과 라이브러리 지정 가능

## 스프링 모듈의 두 가지 이름과 레포지토리
![img_2.png](img_2.png)
- 동일하지만 배포되는 기술에 따라 관롈적으로 다른 이름을 사용할 뿐
- spring-core-3.0.7.RELEASE.jar는 Maven에서 사용하는 명명 규칙을 따르는 것
- Maven은 그룹 아이디, 아티팩트 아이디, 버전 세 가지로 라이브러리를 정의
  - 그 중 아티팩트 아이디와 버전을 조합해 파일 이름으로 사용
- org.springframework.core-3.0.7.RELEASE.jar는 OSGi의 모듈 명명 규칙을 따르는 것
  - 스프링의 모든 모듈은 OSGi 호환 모듈로 만들어져 있음
  - 스프링 배포 버전의 dist 폴더에 들어 있는 모듈 이름도 전부 OSGi 스타일의 이름

# 애플리케이션 아키텍처
## 계층형 아키텍처
- 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업 필요
### 아키텍처와 SoC
- 지금까지는 오브젝트 레벨의 분리를 생각해옴
- 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용 가능 
- 데이터 엑세스 로직, 비즈니스 서비스 로직 등으로 묶을 수 있음 
  - 기준에 따라 나눠두지 않으면 여러 분야에 대한 로직이 혼재되어 있어 복잡함 
  - 성격이 다른 것은 아키텍처 레벨에서 분리하는 것이 좋음 
  - 분리된 각 오브젝트는 독자적으로 개발과 테스트 가능 
  - 또한 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연 
- 성격이 다른 것을 크게 그룹으로 만들어 분리해 두는 것을 계층형 아키텍쳐라고 부름 (aka 멀티 티어 아키텍처)
- 웹 기반 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 하여 3계층 애플리케이션이라고도 함 
### 3계층 아키텍처와 수직 계층 
- 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 엑세스 계층
- 비즈니스 로직을 담고 있는 서비스 계층
- 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분 
- ![img_3.png](img_3.png)
- 데이터 엑세스 계층
  - DAO 패턴을 보편적으로 사용하기 때문에 DAO 계층이라고도 불림
  - ERP, 레거시 시스템, 메인프레임 등에 접근하기 때문에 EIS(Enterprise Information System) 계층이라고도 함
  - 하지만 대부분 DB가 가장 메인 
  - 외부 시스템을 호출해 서비스를 이용하는 것은 기반 계층으로 따로 분류하기도 함
  - 사용 기술에 따라 분리
  - 추상화에 가깝기 때문에 그림으로 표현할 때는 세로로 배열하여 표현 
  - ![img_4.png](img_4.png)
  - JdbcTemplate이 추상화를 위한 계층으로 사용돼서 로우레벨 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 함 
  - JdbcTemplate이 없어도 강제로 접근은 가능하지만 추상화 계층구조를 따르는 것이 합리적 
  - 새로운 계층을 추가하면 영향이 크기 때문에 주의 
- 서비스 계층
  - 구조로 보면 가장 단순
  - 이상적인 POJO로 작성됨
  - POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 담아내고 쉽게 테스트하고 유연하게 확장 가능 
  - 서비스 계층은 DAO 계층을 호출하고 이를 활용해 만들어짐
  - 데이터 엑세스를 위한 기능 외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있음 
  - 기반 서비스는 3계층 어디에서나 접근이 가능하도록 만들 수도, 제한할 수도 있음
    - 코드의 특징과 장단점, 활용 예를 살펴 결정하면 됨 
  - 추상화 수직 계층 구조를 가질 필요 없음
    - 단순 상속 구조를 만들 수는 있어도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문
    - 기반 서비스 계층을 사용하는 경우에도 독립된 계층의 서비스를 이용하는 것으로 봐야함 
    - 기반 서비스 계층에서 서비스 계층의 코드를 실행시키는 경우가 있음
      - 스케쥴링이 대표적 
      - 미리 정해진 시각에 특정 서비스 계층의 로직이 동작하게 만드는 백그라운드 서비스가 필요하다면 기반 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있음
    - 원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안 됨
      - 서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근 가능하도록 만들어 특정 구현과 기술에 대한 종속성을 제거해야 함
    - ![img_5.png](img_5.png)
- 프레젠테이션 계층
  - 가장 복잡한 계층
  - 다양한 기술과 프레임워크의 조합을 가질 수 있음
  - 사용할 기술을 선택하는 것이 까다로움 
  - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕 
  - 다른 계층과 달리 클라이언트까지 범위가 확장될 수 있음 
  - 모든 프레젠테이션 로직은 서버의 프레젠테이션 계층 컴포넌트에서 처리됨
### 계층형 아키텍처 설계 원칙
- 대부분의 객체지향 설계 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용되어야 함 
- 각 계층은 응집도가 낮으며 다른 계층과는 낮은 결합도를 유지해야 함 
- 각 계층은 자신의 계층의 책임에만 충실해야 함
  - 데이터 엑세스 계층은 데이터 엑세스에 관한 모든 것을 스스로 처리
  - 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 함
- 자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 낮아짐 
- 다른 계층에 작업을 요청할 때 인터페이스를 통해 하게 되고 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 함 
- ![img_6.png](img_6.png)
  - 데이터 엑세스 계층의 기술과 그 역할을 다른 계층에 노출
  - ResultSet 오브젝트를 서비스 계층에서 직접 다뤄야 함
  - 데이터 엑세스 계층에 종속되는 서비스 계층이 되는 것
  - SQLException이라는 예외도 기술 종속적
- ![img_7.png](img_7.png)
  - 이렇게 수정되어야 함 
  - User는 사용자 정보를 담는 단순 객체이기 때문에 특정 계층의 기술이나 구현에 종속되지 않음 
  - DataAccessException처럼 런타임 예외로 해야 함
- 계층의 경계를 넘어갈 때는 특정 계층에 종속되지 않는 오브젝트 형태로 변환해 줘야 함
- 특정 기술에 종속된다면 해당 코드의 재사용은 불가능함
  - 같은 로직이지만 클라이언트의 종류에 따라 비즈니스 로직 코드가 달라져야 할 수도 있음 

# 애플리케이션 정보 아키텍처
- 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지
- 애플리케이션의 주요 사앹 정보는 클라이언트나 백엔드 시스템에 분산되어 보관 
- 애플리케이션에서 사용하는 정보들을 어떻게 다룰지를 결정하는 일도 아키텍처를 결정하는 중요한 기준 
- 데이터 중심 아키텍쳐
  - 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조
  - DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현, 값을 그대로 사용자 화면으로 전송
  - 객체지향 기술을 사용하기 전과 다를바 없음
## DB/SQL 중심의 로직 구현 방식
- 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있음 
  - 검색 조건은 SQL로 만들어짐
  - SQL의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 조회 페이징 ㅔ필요한 네 가지 정보를 담을 수 있는 단순한 오브젝트에 저장돼서 전달됨
- 업무의 내용이 바뀌면 모든 계층의 코드가 전부 변경됨 
- 대용량 데이터를 다루며 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 프로시저 형태로 만들기도 함 
  - 조회 로직이 조건이 많고 복잡하다면 그만큼 복잡한 SQL이 만들어짐
- 대부분 코드는 대응되는 작업 단위에 1:1로 매핑
  - 여러 작업엣 ㅓ반복되는 기능이 있다면 그에 대한 코드는 중복되기 쉬움 
  - 하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러 개의 DAO 메소드로 구성 
  - 서비스 계층이 프레젠테이션 계층에 전달하는 결과의 포맷은 보통 DAO의 SQL 결과와 동일
  - ![img_8.png](img_8.png)
- 개발하기 쉽다는 장점
- 하지만 이렇게 복잡한 로직의 SQL을 작성하는 방식을 따르면 자바의 이점을 살리지 못 함 
- DB 중심 업무 단위로 코드를 만들면 정보가 항상 단순한 포맷임 
  - 결과가 SQL에 종속됨 
- 스프링을 사용하면 이런 데이터 중심 코드가 많아짐 
  - 변화에 취약 
  - 객체지향 장점이 활용되지 않고 각 계층의 코드가 긴밀히 연결되어 있음 
  - 중복 제거 쉽지 않음 
  - 로직을 DB와 SQL에 많이 담을수록 확장성 떨어짐 
## 거대한 서비스 계층 방식 
- 프로시저 사용 자제하고 복잡한 SQL을 피하면서 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것 
- 여전히 SQL의 결과를 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받음
- 대신 애플리케이션 코드의 비중이 커짐
- 구조는 단순해지고 객체지향 개발의 장점 살릴 기회 많아짐 
- DAO에서 단순한 결과를 돌려줌 
- 해당 정보를 분석, 가공하는 것은 서비스 계층 코드의 책임
- 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 복잡해짐
  - 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어지는데 메소드가 커지기도 함
  - 따라서 거대한 서비스 게층을 만들게 됨 
  - 로직 대부분이 서비스 계층 코드에 집중되기 때문 
- 코드의 중복도 적지 않게 발생 
  - 트랜잭션 단위로 만들어지기 때문 
- ![img_9.png](img_9.png)
- 장점
  - 자바 언어의 장점 활용 가능
  - 테스트 수월
  - 일부 DAO 코드는 여러 비즈니스 로직에서 고융해 사용 가능 
  - 독립적인 개발 가능하기 때문에 초기 개발 속도 빠름
- 하지만 데이터 엑세스 계층과의 결합도 여전히 큼 
- 또 중복 코드가 많음
  - 제공해 주는 값에 대한 일반화가 어려움
  - 필요한 정보를 한 번에 가져오고 그 값을 저장하는 방식이 매번 달라질 수 있기 때문

# 오브젝트 중심 아키텍처
- 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는데 사용 
- 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메일 몬델을 오브젝트 모델로 활용 
- 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성 높음 
- 오브젝트 구조 안에 정보를 담아 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처
## 데이터와 오브젝트
- ![img_10.png](img_10.png)
- 일관된 형식의 도메인 정보를 담음 
- 정보의 가공에 유리 
- 레퍼런스를 통한 상호 참조가 가능하기 때문에 다른 테이블의 내용도 확인 가능 
- 도메인 모델을 따르는 오브젝트 구조를 만들기 위해서는 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있음 
## 도메인 오브젝트를 사용하는 코드 
![img_11.png](img_11.png)
- 도메인 모델을 알고 있다면 해당 메소드의 작업을 이해하기도 쉬움 
- 테스트 수월, 코드 수정도 수월
- Category는 독립된 객체이기 때문에 서비스 계층 어디에서든지 사용 가능 
- DAO 방식에서는 중복이 발생할 것
## 도메인 오브젝트 사용의 문제점
- 최적화된 SQL을 매번 만드는 것에 비해 성능 쪽은 부족할 수 있음 
- 보통 도메인 오브젝트의 모든 필드 값을 채워 전달하는 경우가 대부분
  - 낭비일 수 있음 
- 연관되어 있는 두 도메인의 경우 불필요한 정보까지 가져오게 될 수 있음
  - 그렇다고 null로 채워 오자니 불안 
  - 따라서 오브젝트를 어디까지 사용해야 할 지를 알아야 하는데 이러면 DAO와 비즈니스 로직의 결합도가 높아짐 
### 해결법
- 지연된 로딩
  - 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 DB에서 다시 읽어올 수 있음
  - 도메인 오브젝트를 사용하는 코드는 처음부터 전부 제공된다고 생각하면 됨 
- 자주 사용되는 것을 골라 별도의 오브젝트로 정의한 뒤 필요에 따라 구분해 사용 
  - DAO 메소드가 추가되어야 하고 어느 DAO를 사용할지 서비스 계층에서 알고 있어야 하기 때문에 약한 결합 발생
- 가장 이상적인 방법은 JPA나 JDO, Hibernate 같은 오브젝트/RDB 매핑(ORM) 기술을 사용하는 것
  - 기본적으로 지연된 로딩 기법 제공 
  - 복잡한 DAO 코드를 만들지 않아도 됨 
  - 내부적으로 최적화된 SQL을 사용하도록 튜닝도 가능 
  - 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블은 오브젝트 캐시에 담아두고 사용 가능 
- 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 엑세스 기술을 사용하는 것을 권장 
  - 쉽고 직관적이고 코드의 양도 줄음 
## 빈약한 도메인 오브젝트 방식
- 빈약한 오브젝트: 도메인 오브젝트에 정보만 담겨있고 정보를 활용하는 기능 없을 때
- 스프링에서 자주 사용되긴 함 
- 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷 
- ![img_12.png](img_12.png)
- 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성 떨어지고 중복 문제 발생하기 쉬움
- 비즈니스 로직이 복잡하지 않다면 괜찮음
## 풍성한 도메인 오브젝트 방식
- 도메인 오브젝트의 객체지향적인 특성을 잘 사용할 수 있도록 개선한 것 
- 특정 도메인 오브젝트와 관련이 깊은 비즈니스 로직을 해당 오브젝트에 넣어주고 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것 
- ![img_13.png](img_13.png)
- 이 로직을 서비스 계층의 메소드에 따로 만드는 것보다 응집도 높음
  - 데이터와 그걸 사용하는 기능이 한 데 있으니까
- ![img_14.png](img_14.png)
  - 간결하고 직관적이고 이해하기 쉽고 객체지향적
- 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 비즈니스 로직을 담고 있던 서비스 계층 오브젝트가 필요 없어지는 건 아님 
- 도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해당 오브젝트나 긴밀한 연관관계를 맺고 있는 오브젝트의 정보와 기능만을 활용 
- 여러 도메인 오브젝트의 기능을 조합해 만들었다면 특정 도메인 오브젝트에 넣기 애매함 
- 도메인 오브젝트는 다른 계층에 직접 접근이 불가하기 때문에 서비스 계층이 필요하기도 함 
- 도메인 오브젝트는 스프링이 관리하는 빈이 아니기 때문에 DI 불가능함 
  - 결국 DB에 결과를 저장하거나 메일로 발송하거나 DB를 검색해 원하는 정보를 가져와 활용하는 것은 도메인 오브젝트에서 불가능 
- DAO와 기반계층 오브젝트를 DI받아 사용할 수 있는 서비스 계층의 코드 필요함 
- 서비스 계층은 도메인 오브젝트의 기능을 활용해 비즈니스 로직 처리 
- ![img_15.png](img_15.png)
- 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드 간결 
## 도메인 계층 방식
- 변경된 정보가 저장되려면 서비스 계층 오브젝트의 부가적인 작업이 필요 
- 도메인 계층 방식은 도메인 오브젝트가 기존 3계층과 같은 레벨로 올라오는 것 
- 서비스 계층과 데이터 액세스 계층 사이에 도메인 계층이 위치 
### 특징 1: 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아닌 도메인 계층의 오브젝트 안에서 진행
- 해당 도메인 오브젝트를 중심으로 만들어진 로직이라면 그 이후의 작업은 도메인 오브젝트와 그 관련 오브젝트 사이에서 진행
### 특징 2: 도메인 오브젝트가 기존 데이터 엑세스 계층이나 기반 계층의 기능을 직접 활용 가능 
- DI 사용해서 가능하게 함 
- 스프링이 직접 관리하지 않는 오브젝트에 대한 DI 서비스가 일종의 AOP 부가기능으로 도메인 오브젝트에 적용
- 스프링의 빈 오브젝트를 DI받게 할 수 있음 
- 서비스 계층의 비중과 규모는 단순히 도메인 오브젝트를 사용하는 방식에 비해 작음 
  - 복잡하지 않으면 아예 도메인 오브젝트 계층만 있는 경우도 있음 
- 도메인 오브젝트를 독립적인 계층으로 만들 때
  - 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 함 
    - 1. 모든 계층에서 도메인 오브젝트 사용
      - 가장 편함 
      - 도메인/비즈니스 로직을 담고 있기 때문에 프레젠테이션 계층으로 나가면 위험할 수 있음 
      - 가이드라인을 만들어두고 적용
    - 2. 도메인 오브젝트가 도메인 계층을 벗어나지 못하게
      - 밖으로 내보낼 때는 내용을 복사해서 넘겨줘야 함 
      - DTO 사용하는 것 
- ![img_16.png](img_16.png)