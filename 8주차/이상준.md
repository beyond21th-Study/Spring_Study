[ week8 Spring-Study  ]

[ 애플리 케이션 아키텍처 ]

{ 계층형 아키텍처 }
* 성격이 다른 모듈이 강하게 결합되어 한데 모여 있으면 한 가지 이유로 변경이 일어날 때 다른 요소도 함께 영향을 받게 된다. 그래서 인터페이스와 같은 겨예를 만들어두고 분리하거나 모아주는 작업이 필요하다.

- 아키텍처와 SoC
* 오브젝트 레벨에서의 분리의 문제를 다뤘다.
    * 성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리하고, 그 사이에 유연한 결합을 가질 수 있도록 인터페이스를 두고, 그 관계를 맺어주는 제 3의 존재인 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 지금까지 해온 DI를 기반으로한 유연한 설계와 구현 전략이었다.

* 이런 원리는 아키텍쳐 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.
    * 오브젝트를 하나의 모듈이라 생각해보자. 하나의 메소드 안의 코드에도 가능하고 반대로 모듈의 단위를 크게 확장해 볼 수 도 있다.
    * 서비스 오브젝트들은 특정 기술과 환경에 종속되지 않으면서 도메인의 업무에는 밀접하게 관련을 갖고 있는 POFO로 만들어진다.

    * 이렇게 애플리케이션 오브젝트들이 나뉘어 지지 않았다면 어떻게 될까? -> 손대기 싫을 만큼 지저분한 것은 당연해진다.
    * 그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 게 좋다.
    * 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있음.
    * 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.

    * 이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍쳐 차원에서는 계층형 아키텍쳐라고 한다.




{ 3계층 아키텍처와 수직 계층 }
* 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 액세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.
￼



- 데이터 액세스 계층
    * DAO 계층이라고 불린다. DB외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS계층이라고도 한다.
    * 하지만 대개는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다.

    * 데이터 액세스 계층 안에서 다시 세분화하는 경우 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 한다.
    * 기본 3계층은 기술 계층 보다는 역할에 따라 구분한 것으로 가로로 배열하지만, 반면에 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열한다.
￼
    * JdbcTemplate을 사용하는 데이터 액세스 계층의 특징은 JdbcTemplate이 추상화를 위한 계층으로 사용되서 로우레벨의 기반에 존재하는 JDBC 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것이다.


￼
    * 위의 그림은 새로운 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 만들어주는 구조이다.
    * 새로운 계층 추가는 개발자의 애플리케이션 코드에 지대한 영향을 주기 때문에 매우 신중하게 결정해야 한다.


- 서비스 계층
    * 가장 단순하다. 이상적인 POJO로 작성된다. 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연ㄴ하게 확장가능.
    * DAO 계층을 호출하고 이를 화룡ㅇ해서 만들어진다. 때론 데이터 액세스를 위한 기능외에 서버나 시스템 레벨에서 제공하는 기반 서비스를 활용할 필요도 있다.
        * ex. 웹 서비스와 같은 원경 호출을 통해 정보를 가져오거나 메일 또는 메세징 서비슬르 이용하는 것.
    * 이런 기반의 서비스는 3계층 어디에서나 접근이 가능하도록 제한할 수도 있다.

    * 특별한 경우가 아니라면 추상화 수직 계층 구조를 가질 필요가 없다. WHY? 기술 API를 직접 다루는 코드가 아니기 떄문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 떄문이다.

    * 비즈니스 로직을 담은 서비스 계층과 엔터프라이즈 서비스를 제공하는 기반 서비스 계층은 이름 때문에 혼동되기 쉬우므로 주의해야한다.
￼
    * 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다. 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어 있는 서비스 계층이어야 한다.




- 프레젠테이션 계층
    * 가장 복잡한 계층. 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다. -> 웹가 프레젠테이션 기술은 귾임없이 발전하고 새로운 모델이 등장하기 때문.
    * 이 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다. 
    * 다른 계층과 달리 클라이언트까지 그 범위르 확장될 수 있다.
    * 예전에는 로직은 서버의 프레젠테이션 계층의 컴포넌트에서 처리됐다. 하지만 최근에는 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다.
    * RIA(Rich Internet Application), SPFEA(Service Oriented Front End Architecture )아키텍처가 대표적인 예이다.’

    * 스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공한다. 동시에 다양한 서드파티 웹 기술을 지원한다.



[ 계층형 아키텍처 설계의 원칙 ]
    * 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 잇어야 한다.
    * 각 계층은 자신의 계층의 책임에만 충실해야 한다. 데이터 액세스 계층은 데이터 액세스에 관한 모든 것을 스스로 처리해야 한다. 만약 비즈니스 로직을 담거나 웹 파라미터를 파싱하는 코드나 결과를 화면에 어떻게 뿌릴지 결정하는 코드가 있으면 응집도가 낮아진다.
    * 이러면 변화에 대한 유연성이 떨어지고 이해하기 힘든 코드를 가진 계층이 되고 말 것이다. 

    * 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다.


￼
    * 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출식킨다. 이러면 서비스 계층의 코드는 오브젝트를 직접 다뤄야하고 종속되는 서비스 계층의 코드가 된다.




￼
    * 인터페이스 메소드는 이렇게 수정되어야한다.
    * User는 사용자 정보를 담고 있는 단순한 오브젝트이다. 그래서 특정 계층의 기술이나 구현에 종속되지 않는다. 
    * 결과는 이렇게 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달해야한다. 

    * 흔히 저지르는 실수 중 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것이다. 서블릿의 HttpServletRequest,Response, HttpSession 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안된다. 
    * 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야한다.


    * 스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경ㄱㄲ꼐나 그 관계에 직접적으로 관여하지 않는다. 하지만 모든 경계에는 오브젝트가 존재하고 그 사이에도 오브젝트 대 오브젝트로 정의되기 마련이다. 그런 면에서 스프링의 DI가 계층 사이의 관계에도 적용 된다 볼 수 있다.
    * 하지만 DI는 계층을 구분해주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다.
        * 한 계층의 내부에서만 사용되도록 ㅂ만든 빈 오브젝트가 있는데, 이를 DI를 통해 다른 계층으로 함부로 가져다 쓰는 일은 X.
        * 또한 중간 계층을 건너 뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI하지 않도록 주의해야한다.



[ 애플리케이션 정보 아키텍처 ]
* 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과는 달리 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지함.
* 주요 상태정보는 클라이언트나 백엔드 시스템에 분산되서 보관된다. 비교적 장기간 보관되는 상태정보는 주로 DB나 메인프레임 같은 EIS백엔드 시스템에 저장된다.
    * 임시 상태정보는 클라이언트에 일시적으로 보관되기도 하고 서버의 사용자별 세션 메모리에 저장되기도 한다.

* 이렇게 애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다.
* 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우 두가지로 구분해볼 수 있다.

* 데이터 중심 아키텍처는 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기위한 목적의 오브젝트 형태로 취급하는 구조이다.
* 이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절과 다를게 없다.


- DB/SQL 중심의 로직 구현 방식
    * 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 
    * 검색조건은 SQl로 만들어진다.
    * 이러한 업무는 내용이 바뀌면 모든 계층의 코드가 함께 변경되고, 종속적일 뿐 아니라 배타적이여서 다른 단위 업무에 재사용되기 힘들다.
    * 대부분의 코드는 대응되는 작업 단위에 1:1로 매핑된다. 여러 작업에서 반복되는 기능이 있따면 그에 대한 코드는 중복되기 쉽다. 
    * 즉 업무 트랜잭션 단위로 코드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문이다.
￼
    * 이런 식의 개발 방법과 아키텍처는 사실 자바 기술 발전 이전의 시스템에서 흔히 발견되었다.
    * 이런 방식은 개발하기 쉽다는 장점이 있다.
    * But 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것이다.
    * 이렇게 DB중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터이다.
    * 데이터를 분석하거나 조작하는 간단한 비즈니스 로직을 추가할 수는 있다. 하지만 이런 코드는 결과에 종속되기 떄문에 SQL의 변화가 일어나면 같이 변경되어야한다.



[ 거대한 서비스 계층 방식 ]
* DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다.
    * DB에 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것.
* 여전히 SQL의 결과를 그대로 담고 있는 단순한 오브젝트 또는 맵을 이용해 데이터를 주고받는다. 대신 많은 비즈니스 로직을 DB의 저장 프로시저나 SQL에서 서비스 계층의 오브젝트로 옮겨왔기 떄문에 애플리케이션 코드의 비중이 커진다. -> 구조 단순, 객체지향 개발의 장점을 살릴 기회 UP!

* 데이터의 분석, 처리화 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문에 이러한 접근 방법은 “ 거대한 서비스 계층 ”이 된다.
￼
    * 장점 : 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 떄문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트도 수월하다.
        * 또한 여러 비즈니스 로직에서 공유해서 사용할 수 있음.

    * 하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다 그래서 계층 간의 결합도가 여전히 크다.
    * 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 떄문에 비슷한 기능의 코드가 여러 메소드중에서 중복되어 나타나기 쉽다.
    * 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아내는 일도 불가능하진 않지만 일반화하기 힘들다.

    * 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고, 개발자 사이에 간섭 없이 독립적인 개발이 가능하다는 장점이 있다.



[ 오브젝트 중심 아키텍처 ]
    * 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다.
    * 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.


[ 데이터와 오브젝트 ]
    * 예를들어, 카테고리 하나에는 여러 개의 상품이 포함되고, 각 상품은 하나의 카테고리에 소속된다.
￼


    * 배열 대신 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 만들어서 돌려주는게 편리하다. 이것을 DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 서비스 계층으로 아래 그림처럼 넘겨줄 것이다.
￼
    * 서비스 계층에 전달되는 것은 List<Map<String, Object>>타입이다.
    * 하지만 가져온 정보를 웹 페이지 내에서 수정해서 DB에 다시 반영해야 한다면. 사용자가 수정한 정보는 다시 맵이나 배열 등에 담겨서 전달될 것이다.
    * 수정 작업 담당하는 DAO는 이렇게 전달되는 데이터의 구조를 알고 있어야 한다. -> 데이터 중심 아키텍처에서는 SQL의 결과에 모든 계층의 코드가 의존함.


    * 반면 오브젝트 방식에서는 도메인 모델의 구조를 반영해 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다.
    * 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.
￼
    * 애플리케이션 어디에서도 사용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.
    * SQL 결과를 가져온 값을 그대로 사용하는 경우와는 다르게, 도메인 모델을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보 가공 가능!

    *  Product 클래스에는 Product 테이블처럼 categoryid라는 외래키가 없다. 대신 Category 오브젝트를 가리키는 레퍼런스 변수를 가지고있다. 아래 그림처럼.
￼
    *  오브젝트 중식 방식에서는 테이블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되는 Product 오브젝트로 만들어 사용한다.
    * 테이블에 카테고리가 하나이고 그에 대응되는 Product 열이 5개라면 오브젝트도 하나의 Category 오즈젝트와 이에 연결된 5개의 Product가 만들어질 것이다.
    * 두 오브젝트는 레퍼런스 변수를 통해 서로 연결되어 있기 떄문에 메소드 파라미터나 리턴 값으로 전달할 때 Category 오브젝트 하나를 전달하더라도 그에 연결된 5개가 함께 전달된다.



[ 도메인 오브젝트를 사용하는 코드 ]
* 오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자.
￼
    * 도메인 모델을 알고 있따면 calcTotalOfProductPrice()메소드가 무슨 작업을 하는지 이해하기 어렵지 않다.
    * 테스트 검증도 간단, 로직 변경 시 코드 수정 굿, 상품가격을 계산해야 할 때 이 메소드를 사용하면 됨. 만약 상품 가격을 계산하는 코드가 여러 개의 업무 트랜잭션에서 필요하다해도 코드의 중복이 일어나지 않음.

    * 반면 데이터 중심 방식은 재사용 가능한 메소드 만들어 사용하기 쉽지 않음. -> 적지않은 for문, if문 나올거임.
    * 오브젝트 구조로 정보를 갖고 있을때 Product의 Category에는 상품이 모두 몇개 있는지 알고싶다면 아래 그림처럼 간단하게 코드로 사용가능.
    * ￼





[ 도메인 오브젝트 사용의 문제점 ]
* 최적화된 SQL을 ㅂ매번 만들어 사용하는 경우에 비해 성능 면에서 조금 손해가 있다.
* 오브젝트 관계에도 문제가 있음.
    * 오브젝트에 담긴 정보가 모두 오기 때문에 상당한 낭비.
    * 필요한 정보만 가져올 순 있지만 그럼 Category 필드에는 null값이 들어간다는 점이다.ㅓㅓ

* 문제해결 방법 1 (지연된 로딩 : lazy loading)
    * 최소한의 오브젝트 정보만 읽고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 읽어올 수 있음.
    * 또한 자주 사용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라도 가능! -> 계층 사이의 결합이 발생할 수 있음.

* 이상적인건 JPA나 JDO, 하이버네이트와 같은 오브젝트/RED 매핑(ORM)을 사용하는 것이다.
* 코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB의 부하 다운, 성능 업!
* 그래서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용을 권장.



[ 빈약한 도메인 오브젝트 방식 ]
* 도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트는 아니다.
* 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층 구조와 비슷하다.
￼




[ 퓽성한 도메인 오브젝트 방식 ]
* 풍성한 도메인 오브젝트 방식 or 영리한 도메인 오브젝트 방식은 빈약의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있게 개선한것이다.
* 객체지향적인 특징을 잘 사용할 수 있게 앞에서 봤던 Category 클래서 안의 메소드에 넣을 수 있다.
￼
* 이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다. 



* 같은 기능의 코드를 중복하지 않고 최적화해서 이미 만들어진 비즈니스 로직을 재활용하는 것인데도 제법 번거로울 수 있따.
￼
* 이런 식으로 여러 개의 도메인 오브젝트에 대한 로직을 사용해하 하는 복잡한 코드라면 오브젝트를 DI 해서 로직을 담은 메소드를 호출해야 한다.



* BUT Category 안에 계산 로직을 넣었다면 DI할 필요도 없고 로직에 중복도 나타나지 않는다.
￼





* 왜 도메인 오브젝트는 DAO 오브젝트를 받을 수 없을까?
    * 도메인 오브젝트는 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문이다.
    * 서비스 계층, 데이터 액세스 계층의 오브젝트는 모두 스프링 빈으로 등록되어 있기 때문에 필요에 따라 서로 DI 할 수 있따.


￼
* 스프링빈으로 관리되는 3계층의 오브젝트들은 도메인 오브젝트를 자유롭게 이용할 수 있지만 그 반대는 안된다는 사실을 주의해야한다.


* 풍성한 방식은 빈약한 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기 쉬움.





[ 도메인 계층 방식 ]
* 도메인 모델을 따르는 오브젝트를 만들고 이를 활용하는 방법에는 한계가 있다.
* 그래서 등장한 것이 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식(하나의 독립적인 계층)
* 기존 방식과는 다름
    * 첫 번째. 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점.
        * 서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 처리를 요청 할 수 있다.

    * 두번째, 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용 가능.
        * 도메인 오브젝트는 스프링에 등록되서 DI를 받을 수 없다 했다. 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다.
        * 적용 대상도 빈 오브젝트 뿐이지만. 이 부가 기능을 ㄷ통해 도메인 오브젝트에 적용될 수 있따.
        * 물론 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정되긴함.

* 도메인 오브젝트를 독립적인 계층으로 만들려고할때 고랴사항 -> 도메인 계층을 벗어나도 사용되게 할지 말지 결정해야돼.
    * 첫번째 : 모든 계층에서 도메인 오브젝트를 사용하게함.
        * 가장 쉽고 편리한 방법. 하지만 주의하지 않으면 심각한 혼란 초래.
        * 중요한 도메인/비즈니스 로직을 담당하고 있어 DB나 백엔드 시스템에 작업 결과를 반영할 수 있음.
        * 해결법 : 철저한 개발 가이드 라인 만들고 강력하게 적용. 어길 수 있는데 코딩정책의 적용을 분석할 수 있는 툴이나 정책/표준 강제화기능 사용하면 됨.

    * 두번째 : 못벗어나
        * 이런 구조는 데이터 전달을 위해 DTO를 사용. 상태 변화를 허용 X, 읽기전용.
        * 기능을 갖지 않아서 사용하기 안전. 외부 계층의 코드로부터 보호. 반면에 따로 만들어줘야되고 이를 매번 변환해야되서 번거로움 있음.
￼
    * 도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만 그 특성은 확연히 다르다. 서비스를 제공하는 싱글톤으로 계속 존재하는 다른계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 매우 짧은 시간만 존재 했다가 사라지는 것을 반복한다.

    * 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문에 여러 스레드가 공유하는 싱글톤이 될 수 없다.



[ DTO와 리포트 쿼리 ]
* 대표적인건 리포트 쿼리라고 불리는 DB쿼리의 실행 결과를 담는 경우다.  리포트를 출력하기 위해 생성되는 쿼리라는 의미.
* DB쿼리의 실행 결과를 담을만한 적절한 도메인 오브젝트를 찾을 수 없다. 그래서 이런 리포트 쿼리의 결과는 DTO라고 불리는 단순한 자바빈이나 아니면 키와 값 쌍을 갖는 맵에 담아서 전달해야 한다.


[ 스프링 애플리케이션을 위한 아키텍처 설계 ]
{ 계층형 아키텍처 }
* 가장 많이 사용되는 구조. 3계층을 단순화해서 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층으로 통합하는 편이 낫다.
* 프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴을 주로 사용한다.
* SOFEA(Service Oriented Front End Architecture)라고 불리는 아키텍처는 프레젠테이션 계층 코드가 서버에서 클라이언트로 다운로드되서 클라이언트 장치 안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠테이션 계층과 통신하는 구조로 만들어진다.
￼



{ 정보 전송 아키텍처 }
* 오브젝트 중심 아키텍처의 도메인 오브젝트 방식, 일단인 빈약하게 시작하는게 쉽다.
* 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고, 이를 각 계층의 코드에서 활용한다.
* 정보를 일관된 형태로 유지하는게 스프링에 가장 잘 들어맞는 방식이다.


{ 상태 관리와 빈 스코프 }
* 상태관리에도 신경써야된다. 크게는 로그인 세션 관리부터 작게는 하나의 단위작업이지만 http 요청의 범위를 넘어서 유지해야하는 상태정보가 있다.
* 엔터프라이즈 애플리케이션은 특정 사용자가 독접해서 배타적으로 사용되지 않는다. -> 서버 자원이 특정 사용자에게 일정 할당X.
* 그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태 갖지 X 다는 특정이 있다.

* 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다. 웹에 잘 맞고 개발하기 쉽고, 서버를 여러 대로 확장하기 쉽기때문.
* 반면에 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등 작업을 위해서 HTTP 세션을 적극 활용하기도 함.

 { 서드파티 프레임워크, 라이브러리 적용 }
* 스프링이 지원하는 기술이란?
- 첫째, 해당 기술을 스프링 DI패턴을 따라 사용할 수 있따. 
￼


- 둘쨰, 스프링의 서비스 추상화가 적용됐다.
- 셋째, 스프링이 지지하는 프로그래밍 모델을 적용했다.
- 넷째, 템플릿/콜백이 지원된다.
















