# 애플리케이션 아키텍쳐
- 아키텍처 : 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것.
- 단순히 정적인 구조를 나타내는 것으로만 생각하기 쉽지만 실제로 그 구조에서 일어나는 동적인 행위와 깊은 관계가 있음.

## 9.3.1 계층형 아키텍쳐
- 성격이 다른 모듈이 강하게 결합되어 한 곳에 모여있으면 한 가지 이유로 변경이 일어날때 그와 관계없는 요소도 함께 영향을 받게 됌.
- 따라서 불필요한 부분까지 변경이 일어나고 그로 인해 작업은 더뎌지고 오류가 발생할 가능성이 높아짐 + 어느 부분을 수정해야할지 파악하기 쉽지않음
- 따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업이 필요함.

### 아키텍처와 SoC
- 애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책음을 가진 것들끼리 묶을 수 있다. 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각해보자면 어떤 DAO든 비슷한 성격을 띠고 유사한 방식으로 다른 오브젝트와 관계를 갖는다.
- 비즈니스 로직을 구현해놓은 비즈니스 서비스 오브젝트들도 같은 성격으로 묶을 수 있다. 서비스 오브젝트들은 특정 기술과 환경에 종속되지 않으면서 도메인의 업무에는 밀접하게 관련을 갖고 있는 POJO로 만들어진다. 주로 DAO를 이용해 정보의 저장과 검색 등을 하고 DB의 엔티티 모델과 유사한 도메인 오브젝트를 이용해 데이터를 저장하고 가공하고 주고 받는다.
- 웹을 처리하는 코드 또한 독자적인 성격으로 분류가 가능한데, 서블릿 컨테이너로부터 받은 사용자의 요청정보를 해석해서 그것을 POJO기반의 서비스 오브젝트에 전달해주고, 결과를 받아서 다시 웹 사용자 인터페이스에 표시 가능한 형태로 변환해주는 일을 한다. 

-> 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나눌 수가 있는데 이렇게 나뉘어 있지 않다면 어떻게 될까?
- DB에서 정보를 어떻게 가져오는지에 대한 로직을 담은 SQLrhk, JDBC코드와 HTML 태그 사이에 읽어오느정보를 넣는 코드가 함께 존재할 수 있다.
- 이러면 성격과 책임이 분명ㅎ ㅣ다른 것들이 한데 모여 얽혀 있게 되고 문제가 발생하게 된다.
-> 그래서 성격이 다른 것은 아키텍쳐 ㅔ벨에서 분리해주는게 좋다. 이렇게 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수 있다. + 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하다.
- [계층형 아키텍처] : 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것. 계층이라는 의미를 가진 영어단어닌 티어를 써서 '멀티 티어 아키텍처'라고도 하고, 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 '3계층 애플리케이션'이라고도 한다.

### 3계층 아키텍처와 수직 계층
### [3계층 아키텍처]
- 데이터 액세스 계층 : 3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할
- 서비스 계층 : 비즈니스 로직을 담는 역할
- 프레젠테이션 계층 : 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 역할

<img width="485" height="102" alt="image" src="https://github.com/user-attachments/assets/18ee4ca4-00e4-4d0c-9bcb-98aa4f485acb" />

### [데이터 액세스 계층]
- DAO 계층이라고도 불림. 왜? DAO패턴을 보편적으로 사용하기 때문.
- DB이외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS계층이라고도 한다.
- 하지만 장기적인 데이터 저장을 목적으로 하는 DB이용이 주된 책임
- 애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 한다.
- 
<img width="651" height="213" alt="image" src="https://github.com/user-attachments/assets/55080e43-8122-4912-bc4a-81c2ab0dc7b7" />

- JdbcTemplate을 사용하는 데이터 액세스 계층의 특징
  - JdbcTemplate이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 것. = JdbcTemplate은 우리가 직접 JDBC 코드를 다루지 않아도 되게 해주는 중간 추상화 계층이라서, 내부적으로는 JDBC와 DB 드라이버를 사용하면서 동시에 Spring의 트랜잭션 관리(@Transactional)와도 자동으로 연결되게 해준다는 뜻.
  - 추상화 계층은 필요하다면 얼마든지 추가할 수 있다. 새로운 계층을 추가하면 개발자의 애플리케이션 코드에 큰 영향을 주기 때문에 매우 신중하게 결정해야 한다
  - 한번 새로운 계층과 API를 만들어 적용하면 이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응해야하는 책임도 갖게 됨.

### [서비스 계층]
- 잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성된다. POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있다. 서비스 계층은 DAO계층을 호출하고 이를 활용해서 만들어진다.
- 서비츠 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없다. 왜? 단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 순 있을지 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일괄된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.

<img width="685" height="217" alt="image" src="https://github.com/user-attachments/assets/240a9e53-9ce2-428b-96ea-777693ec108b" />

- 기반 서비스 계층이 서비스 계층의 오브젝트를 호출하는 경우를 잘 살펴봐야하는데, 일반적으로는 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출해서 가져다 쓴다.
- 하지만 반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우가 있다. 이경우는 스케줄링이 대표적인 경우이다.
- 미리 정해진 시간에 특정 서비스 계층의 로직이 동작하게 만다는 백그라운드 서비스가 필요하다면 그때는 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있다.
- 이상적인 서비스 계층은 백엔드 시스템과 연결되는 데이터 액세스 계층이 바귀고, 클라이언트와 연결되는 프레젠테이션 계층이 모두 바뀌어도 그대로 유지될 수 있어야 한다.
- 엔터프라이즈 애플리케이션에서 가장 중요한 자산은 도메인의 핵심 비즈니스 로직이 들어 있는 서비스 계층이어야 한다.

### [프레젠테이션 계층]
= 프레젠테이션 계층은 가장 복잡한 계층
- 프레젠테이션 계층은 매우 다양한 기술과 프레임워크의 조합을 가질 수 있다 -> 웹과 프레젠테이션 기술은 끊임없이 발전하ㅗㄱ 진보하고 새로운 모델이 등장하기 때문.
엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류과 상관 없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.
대부분의 엔터프라이드 애플리케이션을 사용하는 클라이언트들은 HTTP 프로토콜을 선호한다. 따라서 이런 클라이언트와 연결돼서 동작하는 프레젠테이션 계층은 자바에서 HTTP 프로토콜을 처리하는 가장 기본엔진이 서블릿 기술을 바탕으로 한다.
- 초기 클라이언트 모델은 단순이 사람이 볼 수 있도록 그려주고 입력받은 값을 전달하는 데에 그쳤고, 화면을 어떻게 그릴지에 대한 로직 등이 모두 서버에서 처리됐다.
- 최근에는 많은 프레젠테이션 로직이 클라이언트로 이동하고 있다. RIA라고 불리는 기술이나 SOFEA아키텍쳐가 대표적인 예이다.

<img width="482" height="257" alt="image" src="https://github.com/user-attachments/assets/359c6c19-9443-418b-afe4-059fa6896d19" />

<img width="678" height="526" alt="image" src="https://github.com/user-attachments/assets/74d5c721-9944-405a-8dd4-d19c1590a65a" />


<img width="522" height="344" alt="image" src="https://github.com/user-attachments/assets/b80f57e4-ae54-4369-a580-8cf8c458b90d" />

<img width="669" height="403" alt="image" src="https://github.com/user-attachments/assets/62ad8cee-c6d5-450a-b99a-68bd4fe6114b" />



### 계층형 아키텍처 설계의 원칙
- 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.
  - ex) 데이터 액세스 계층은 데이터 액세스에 관한 모든 것을 스스로 처리해야한다. 비즈니스 로직을 담거나 웹 파라미터를 파싱하는 코드나, 결과를 화면에 어떻게 보이게 할지 결정하는 코드가 들어간다면 응집도가 낮아진다.
 
<img width="516" height="48" alt="image" src="https://github.com/user-attachments/assets/808a7c5e-3ef8-4942-a283-d21f29d2163b" />

- findUserByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다르 계층에 노출한다는 점. 결과를 JDBC의 ResultSet오브젝트로 돌려주면 이를 사용하는 서비스 계층의 코드는 ResultSet이라는 데이터 액세스 계층에서 만들어진 오브젝트를 직접 다뤄야하만 한다.
- SQLexception이라는 JDBC 기술 종속적인 예외를 체크예외로 던져버리면 이를 사용하는 서비스 계층에서는 SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다. 특정 데이터 액세스 계층의 구현에 종속되는 강한 결하비 만들어진다.
- 계층 간에 강한 결합이 생기면 유연성이 떨어지기 때문에 각 계층의 내부 구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다.
- 코드의 중복이 일어날 가능성이 높고 전체 코드를 이해하기 힘들어진다

<img width="548" height="53" alt="image" src="https://github.com/user-attachments/assets/66033be8-9a41-4861-a935-6fe41cc5a188" />

- User는 사용자 정보를 담고 있는 단순한 오브젝트이다. 따라서 특정 계층의 기술이나 구현에 종속되지 않는 단순한 오브젝트의 형태로 전달해야한다.
- 데이터 액세스 예외와 같이 특별한 경우에만 전달될 가능성이 있는 것은 스프링의 DataAccessException처럼 런타임 예외로 만들어야 한다.
- [인터페이스]의 역할 : 어떤 경우에라도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다. 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다. 인터페이스를 하나 더 만드는 것이 번거롭다고 그냥 클래스를 이용해서는 안된다. 인터페이스를 사용하게 한다는 건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미이다.


## 9.3.2 애플리케이션 정보 아키텍처

### 데이터 중심 아키텍처
- 애플리케이션에 흘러다니는 정보를 단순히 값이나, 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조.
- DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고, 그 값을 취급하는 코드를 만들어 로직을 구현하고, 값을 그대로 프레젠테이션 계층의 뷰와 연결해주는 것
- 비즈니스 로직이 DB내부의 저장프로시저나 SQL에 담겨 있는 경우가 많음
- 하지만 계층사이의 결합도가 높은 편이고 응집도는 떨어짐. + 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음에는 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다느 단점이 있다.

[DB/SQL중심의 로직 구현 방식]

- 데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 것.
- 사용자으 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호, 이름, 가입일자만 보여주는 작업이 있다고 생각해보면, 이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회라는 단위 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻.
- 검색조건은 SQL로 만들어진다. 사용자 정보를 웹 페이지에 나타낼 때 가입일자 중에서 연도만 보여줘야 한다면, 가입일자 필드에서 연도를 추출하는 것은 SQL의 날짜처리 펑션을 이용해야 한다. 그래야 SQL 결과를 그대로 웹 페이지의 정보 필드에 1:1로 매핑해서 넣어줄 수 있기 때문이다. 결국 SQL은 이미 화면에서 어떤 식으로 출력이 될지 알고 있는 셈이다.
- SQL의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 조회 페이지에 필요한 네 가지 정보를 담을 수 있는 단순한 오브젝트를 저장해서 전달된다. 프레젠테이션 계층의 JSP뷰는 DAO의 SQL에서 정확히 어떤 필드 값을 리턴할지, 어떤 포맷으로 전달할지 알고 있다. SQL의 SELECT절에 나오는 컬럼 이름을 그대로 사용해서 전달된 맵이나 결과를 저장하는 오브젝트에서 값을 가져와 화면에 출력한다. 만약 새로운 필드가 추가되거나 DB 테이블의 컬럼 이름이 변경됐다면, 그에 따라서 맵이나 오브젝트에 저장된 엔트리 또는 프로퍼티 이름이 바뀌거나 추가될 것이고 그에 맞게 뷰의 내용도 변경된다.

<img width="803" height="267" alt="image" src="https://github.com/user-attachments/assets/9f35e480-6108-48ee-9703-d399340e2fa3" />

- 대부분의 코드는 대응되는 작업 단위에 1:1로 매핑된다. 여러 작업에서 반복되는 기능이 있다면 그에 대한 코드는 중복되기 쉽다. 보통 작업 단위, 즉 업무 트랜잭션 단위로 코드를 묶어서 만들지, 기능을 세분화해서 분리하고 재사용하지 않기 때문이다.
- 하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러 개의 DAO메소드로 구성된다.
- 서비스 계층이 프레젠테이션 계층에 전달하는 결과의 포맷은 보통 DAO의 SQL결과와 같고, 웹 페이지의 출력 내용과도 1:1로 대응된다.
- 이런식의 방식은 개발하기 쉽다는 장점이 있지만, 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시킨디-라는 결함이 있다.
- DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 플러다니는 정보는 항상 단순한 포맷의 데이터다. 이런 코드들은 항상 SQL과 그 결과에 종속되기 때문에 SQL 변화가 일어나면 같이 변경돼야 한다. 이런 경우 강한 결합을 만들게 된다.
- 스프링을 사용하면 이런 데이터 중심의 코드를 만들 수 있지만, 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.
- 또한 로직을 DB와 SQL에 많이 담으면 담을수록 점점 확장성이 떨어진다. DB는 확장에 한계가 있을뿐 아니라 확장한다 하더라도 매우 큰 비용이 든다.

## 거대한 서비스 계층 빙식
- DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만들면 DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높일 수 있다.

- 비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다. 업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데, 그러다 보면 하나의 메소드가 매우 거대해지도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로이다.
- 상대적으로 단순한 DAO로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 결국 거대한 서비스 계층을 만들게 된다. 데이터의 분석, 처리와 함꼐 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다. 서비스 계층의 코드는 여전히 업무 트랜잭션 단위로 집중돼서 만들어지기 때문에 DAO를 공유할 수 있는 것을 제외하면 코드의 중복도 적지 않게 발생한다.

<img width="798" height="246" alt="image" src="https://github.com/user-attachments/assets/a87c316b-5ee0-4333-900b-ee07e01029ac" />

- 윗 사진은 거대 서비스 계층 방식의 아키텍처를 나타낸 것이다. 데이터 액세스 계층이나 DB는 비즈니스 로직을 직접 담고 있지 않기 때문에 이전보다 훨씬 가벼워진다. 대신 DB가 돌려주는 데이터를 가지고 비즈니스 로직을 구현하는 서비스 계층이 매우 두터워진다.

- 거대 서비스 계층 방식의 장점 :
  - 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할 수 있고 테스트하기도 수월하다
  - DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.
- 거대 서비스 계층 방식의 한계 : 
  - 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다 서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 매소드에서 중복돼서 나타나기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.
  - DAO가 제공해주는 값의 포맷에 따라 이를 취급하는 방법이 달라지기 때문에 자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아내는 일도 불가능하진 않지만 일반화하기는 힘들다.
 

## 9.3.3 오브젝트 중심 아키텍처
- 오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서 정보를 전송하는 데 사용한다는 것.
- 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.
- 대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다.


### 데이터와 오브젝트

<img width="773" height="296" alt="image" src="https://github.com/user-attachments/assets/a89f3f03-2fb3-4fa0-a808-caca8674085a" />

- DAO에서는 JDBC로 SQL을 실행하고 받은 결과를 위 사진과 같이 담아서 서비스 계층으로 넘겨준다.
- 서비스 계층에 전달되는 것은 List<Map<String, Object>> 타입이다.
- 이 타입만 봐서는 안에 담긴 내용이 어떤것인지 알 수 없기 때문에 이 결고를 사용하는 서비스 계층이나 프레젠테이션 계층의 코드에서는 DAO 메소드에서 두 개의 테이블을 조인해서 다섯가지 필드의 값을 가져오고, 필드 이름을 키로 갖는 맵에 값을 저장했음을 알아햐 사용할 수 있다.
- 만약 DAO에서 SQL을 변경하거나 필드 개수, 순서, 이름 등을 바꾼다면 서비스 계층과 프레젠테이션 계층의 코드도 같이 변경돼야 한다.
- 반면에 오브젝트 방식에서 애플리케이션에서 사용되는 정보가 도메인 모델의구조를 반영해서 만들어진 오브젝트 안에 담긴다.
- 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다.
- SQL이나 웹 페이지의 출력 포맷, 입력 폼 등에 종속되지 않는 일관된 형식의 애플리케이션의 정보를 다룰 수 있게 된다. 

<img width="856" height="584" alt="image" src="https://github.com/user-attachments/assets/cb4c6762-4dc7-4a51-bd1b-8abb8164d9d8" />

- 이 구조는 단순히 특정 SQL에 대응되는 맵과 배열, 매번 달라지는 SQL결과를 담기 위해 만든 오브젝트와는 달리, 애플리케이션 어디에서도 사용될 수 있는 일관된 형식의 도메인 정보를 담고 있다.

[데이터 중심 방식]에서는 Category와 그에 대응되는 Product를 찾아 SQL을 이용해 조인한 다음 하나의 맵에 뭉뜽그려서 가져왔다면
<br> [오브젝트 중심 방식]에서는 테이블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되는 Product 오브젝트로 만들어 사용한다.
<br> 따라서 테이블에 Category가 하나이고 그에 대응되는 Product열이 5개라면, 오브젝트도 하나의 Category 오브젝트와 이에 연결된 5개의 Product가 만들어질 것이다.
<br> 이 두가지 오브젝트는 레퍼런스 변수를 통해 서로 연결되어 있기 때문에 메소드 파라미터나 리턴 값으로 전달 할 때 Category 오브젝트 하나를 전달하더라도 그에 연결된 Product 5개가 함께 전달된다. 반대로 Product의 컬렉션을 전달해도 된다. 

### 도메인 오브젝트를 사용하는 코드

<img width="804" height="283" alt="image" src="https://github.com/user-attachments/assets/109cfcce-731a-4f50-9692-617ac4cac9f4" />
- 입력값 : Category cate
- 출력값 : int (총가격)
- cate.getProducts()
<br> DB에서 직접 Product를 조회하지 않는다 + Category 객체가 이미 Product 목록을 알고 있다.

### 도메인 오브젝트 사용의 문제점
- 일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 많은 장점이 있다. 코드는 이해하기 쉽고 로직을 작성하기도 수월하다.
<br> 프레젠테이션 영역에서도 이미 정의된 도메인 오브젝트 구조만 알고 있다면 아직 DAO가 작성되지 않아도 뷰를 미리 만들 수도 있다. 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들수 있다.
- 하지만 성능면에서는 한계가 있다. DAO는 비즈니스 로직의 사용방식을 알지 못하기때문에 도메인 오브젝트의 모든 피드 값을 다 채워서 전달하는 경우가 대부분이다.
<br> 그런데 하나의 오브젝트에 담긴 필드의 개수가 많아지다보면 그중에는 드물게 사용되는 필드도 있을 수 있다.
<br> 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드뿐이라면 DAO에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달하는 것은 낭비일 수도 있다. 비즈니스 로직에 따라서 필요한 정보가 달라질 수 있기 대문에 발생하는 문제다.
<br> 또한 내가 필요한 오브젝트만 쏙 빼올 수 없고, 다른 오브젝트까지 다 조회해서 오브젝트로 만들어서 가져와야한다.
- DAO와 비즈니스 로직 코드의 결합도가 높아지는 문제가 발생할 수도 있는데, 프레젠테이션 계층에서도 마찬가지로 이러한 문제가 생긴다. Product 오브젝트를 전달받아서 Product 내의 필드 값만 사용할 수도 있고 연결된 Category의 정보까지 출력할 수도 있기 때문이다.
  - [지연된 로딩]기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 다이내믹하게 DB에서 다시 읽어올 수 있다.
  - 필드가 너무 많은 테이블이 있다면 그중에서 자주 사용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다.
  - [오브젝트/RDB 매핑]기술도 하나의 방법이다. 사용하기 쉽고 직관적이며 코드의 양도 대폭 줄기 때문이다.
  <br>
  <img width="438" height="317" alt="image" src="https://github.com/user-attachments/assets/ec69be7c-adb8-4584-a6af-8f6c18a3141e" />
  <br>
  <img width="378" height="294" alt="image" src="https://github.com/user-attachments/assets/845bc3f6-64d7-4fb4-810b-b8dfe1384515" />


  ### 빈약한 도메인 오브젝트 방식
  - 빈약한 오브젝트 : 도메인 오브젝트에 정보만 담겨 있고 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다. 이런 오브젝트들을 빈약한 오브젝트라고 부른다.
    
<img width="785" height="333" alt="image" src="https://github.com/user-attachments/assets/74af378b-f9b2-42ab-b1c9-8785ade367d3" />
- 윗 사진을 설명해보자면, 도메인 오브젝트는 존재하지만, 비즈니스 로직은 거의 다 서비스 계층에 있는 구조이다.
<br> 그리고 이 모든 계층에서 공통으로 사용하는 것이 도메인 오브젝트 이다. 단순정보만 담고있고, 비즈니스 판단 로직은 없다.

<img width="346" height="245" alt="image" src="https://github.com/user-attachments/assets/79663034-3d6c-4218-9e5b-94d21eecf044" />

- 프레젠테이션 계층 (controller/view)
<img width="348" height="247" alt="image" src="https://github.com/user-attachments/assets/cbcd9313-f776-4ef1-b199-04e7368735d9" />

- 서비스 계층 : 여전히 핵심 비즈니스 로직은 서비스 계층에 모두 담겨 있다
<img width="517" height="226" alt="image" src="https://github.com/user-attachments/assets/46fbc8c3-ff09-4184-82ca-addd23be596e" />
<img width="517" height="226" alt="image" src="https://github.com/user-attachments/assets/ce8ffa08-ea1d-4ea6-aeac-9eacc6ce5e28" />
<br> -> 판단, 규칙, 정책 모두 서비스 계층에 있다.

- 데이터 액세스 계층 (DAO/ Respository) : SQL을 직접 쓰면 도메인 오브젝트로 변환해야 하고 ORM을 쓰면 매핑만으로 가능하다
  
<img width="425" height="72" alt="image" src="https://github.com/user-attachments/assets/9e861330-8af5-4d7a-b809-d5f83de6edfb" />
<br> DB에서 id에 해당하는 DietPlan 데이터를 찾아서 DietPlan 객체로 만들어서 plan 변수에 담는다
- SQL을 직접 쓰면 도메인 오브젝트로 변환해야 하고 ORM을 쓰면 매핑만으로 가능하다


### 풍성한 도메인 오브젝트 방식

<img width="786" height="383" alt="image" src="https://github.com/user-attachments/assets/4e3ad57d-d524-498f-a982-a016c0d0c590" />

- 풍성한 도메인 오브젝트 또는 영리한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트이 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다.
- 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다. -> 데이터와 그것을 사용하는 기능이 한곳에 모여있기 때문이다.

<img width="650" height="345" alt="image" src="https://github.com/user-attachments/assets/26305031-deed-4ffb-879a-efd43014c746" />
- 여러 개의 도메인 오브젝트에 대한 로직을 사용해야 하는 복잡한 코드라면 각 비즈니스 로직을 담고 있는 서비스 오브젝트를 DI해서 로직을 담은 메소드를 호출해야 한다. 이미 정보를 담고 있는 오브젝트가 있지만, 그 정보를 다루는 메소드는 별개의 서비스 오브젝트에 부린되어 있기 때문이다.

<img width="653" height="219" alt="image" src="https://github.com/user-attachments/assets/f4cc27b5-8acb-4ee9-9b8c-f1fb300a1620" />

- Category에 대한 계산 로직을 Category오브젝트 안에 직접 넣어뒀다면 이런 번거로운 작업이 필요 없다.
<br> 그냥 Category 오브젝트에게 직접 필요한 계산 작업을 요청하면 되는 것이다. CategoryService를 DI할 필요도 없다. 비슷한 코드가 여기저기 비즈니스 로직에 중복돼서 나타나지도 않는다.
<br> 특정 도메인 오브젝트에 종속되는 비즈니스 로직은 서비스 계층의 오브젝트가 아니라 도메인 오브젝트 안에 넣으면 된다. InventoryService의 코드는 불필요한 DI 없이 간결하게 만들 수 있다.

- 그렇다고 해서 서비스 계층 오브젝트가 아예 필요 없는건 아니다. 여전히 서비스계층은 필요하며 중요한 역할을 한다. <br> 도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용한다.
<br> 도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다르 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 하다.
- 왜 도메인 오브젝트는 DAO 오브젝트를 DI받을 수 없을까? 그것은 도메인 오브젝트는 스피링 컨테이너가 관리하는ㄴ 오브젝트, 즉 빈이 아니기 때문이다.
  - 서비스 계층의 오브젝트나 데이터 액세스 계층의 오브젝트는 모두 스프링의 빈으로 등록되기 때문에 필요에 따라 서로 DI할 수 있다. DI받으려면 자신도 역시 스프링 컨테이너에서 관리되는 빈이어야 한다.
  - 그런데 도메인 오브젝트는 스프링의 빈이 아니고, 도메인 오브젝트는 필요할때마다 새롭게 만들어진다.
  - 따라서 스프링이 생성하거나 관리하는 오브젝트가 아니므로 DI를 받을 수 없다.
 
  - 수식 계산이나 조건에 따른 데이터 변경 또는 자신이 가진 정보에 대한 분석같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지만, 그 결과를 DB에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가져와 활용하는 작업은 도메인 오브젝트에서 불가능한다.
  <br> 그래서 DAO 기반 계층 오브젝트를 DI받아 사용할 수 있는 서비스 계층의 코드가 필요하다.
- 풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하다.
- 비즈니스 로직 코드를 이해하기도 쉽다.

### 도메인 '계층' 방식
- 도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.
- 그래서 등장한 것이 바로 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식이다.
- 도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하는 것이다.
- 도메인 오브젝트가 독립된 계층을 이뤘기 때문에 기존 방식과는 다르 두 가지 특징을 갖게 된다.
  - 첫째는 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점.
  <br> 서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다. -> 일단 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뜻.
  - 두 번째 특징은 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기느을 직접 활용할 수 있다는 것.
    - 도메인 오브젝트는 스프링에 등록돼서 싱글톤으로 관리되는 빈이 아니기 때문에 다른 빈을 DI받을 수 없다고 했는데, 도메인 계층의 도메인 오브젝트들은 어떻게 다른 빈을 이용할 수 있을까? -> 이것또한 DI 방법을 사용한다. 스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다.
    - 물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다.
      
<img width="633" height="272" alt="image" src="https://github.com/user-attachments/assets/7d59f6fe-f8af-4aa7-a361-20019283934d" />

- AspectJ AOP를 쓰면, 스프링이 관리하지 않는 “일반 객체”가 만들어지는 순간에도 AOP랑 DI를 적용할 수 있다는 말이다.
- 스프링 AOP는 스프링 빈에만 적용되는데, AspectJ AOP는 객체가 생성되는 순간 (생성자 호출 시점) 도 조인 포인트(개입 지점) 로 쓸 수 있다. 그래서 스프링 빈이 아닌 객체에도 AOP 적용이 가능하다. 

- 이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받게 할 수 있다. 결국 도메인 오브젝트가 데이터 액세스 계층이나 기반 계층의 오브젝트를 이용하도록 만들 수 있다.

[도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야할 중요한 사항]
- 모든 계층에서 도메인 오브젝트를 사용한다.
  <br> 도메인 계층은 물론이고 서비스 계층이나 그 앞의 프레젠테이션 계층, 화면 출력을 위한 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 해야한다.
- 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것
  <br> 도메인 계층 밖응로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다.

- 도메인 계층 방식

<img width="648" height="355" alt="image" src="https://github.com/user-attachments/assets/b4b67e83-872a-453d-a736-3ab49f038a20" />

-> 도메인 계층은 사용자 요청마다 잠깐 생성됐다가 사라지는 객체들이며, 복잡한 비즈니스 로직이 있을 때 가장 큰 장점을 발휘하지만, 단순한 앱에서는 오히려 과할 수 있다.

### DTO와 리포트 쿼리
- 도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 사용하기도 한다.
- [리포트 쿼리]라고 불리는 DB 쿼리의 실행 결과를 담는 경우. 리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리. 리포트를 위해서라기보다는 종합분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결과를 생성하는 쿼리.
- 이런 쿼리의 결과는 DB 테이블에 담긴 필드의 내용보다는 그 합께, 평균과 같은 계산 값이거나 아니면 여러 테이블의 필드를 다양한 방식으로 조합해서 만들어진다.


## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처
- 3계층 구조는 기본이지만, 비즈니스 로직이 단순하면 2계층으로 통합해도 되고, 다만 서비스 계층을 프레젠테이션에 흡수하는 건 권장되지 않는다.
- 프레젠테이션 계층은 MVC를 기반으로 세분화·확장될 수 있고, 최근에는 일부 프레젠테이션 로직이 클라이언트로 이동하는 SOFEA 구조가 빠르게 확산되고 있다.

### 정보 전송 아키텍처
- 스프링에서는 계층 간 정보 전달을 도메인 객체로 통일하는 ‘도메인 객체 중심 아키텍처’가 가장 잘 맞는다

### 상태 관리와 빈 스코프
- 웹 애플리케이션은 기본적으로 stateless가 유리하지만, 필요한 경우에만 상태를 저장하고 스프링의 빈 스코프를 이용해 안전하게 관리해야 한다.
- ex)
  - Controller / Service -> 싱글톤, stateless
  - 회원가입·폼 작성 중 데이터 -> session / request 스코프 객체

### 서드파티 프레임워크, 라이브러리 적용

- [해당 기술을 스프링의 DI 패턴을 따라 사용할 수 있다]
  - 서드파티 기술의 핵심 객체를 스프링 빈으로 등록
  - 설정만으로 객체 생성·초기화 가능
  - DI로 어디서든 사용 가능

- [스프링의 서비스 추상화가 적용됐다]
  - 트랜잭션, OXM, 메일, 메시징 등
  - 기술별 API 차이를 숨기고 공통 인터페이스 제공
  - 구현 기술을 바꿔도 코드 변경 최소화
 
- [스프링이 지지하는 프로그래밍 모델을 적용했다]
  - 데이터 액세스 예외를 일관된 예외 계층으로 변환
  - DAO 코드가 특정 기술에 종속되지 않음
  - 불필요한 try/catch 제거
  - 서비스 계층이 깔끔해짐

- [템플릿/콜백이 지원된다]
  - JDBC, JMS, JCA 등 반복 코드 많은 기술
  - 스프링 템플릿이: 리소스 열고 닫기, 예외 처리, 공통 흐름 담당, 개발자는 핵심 로직만 작성

  

















  



















