# 9장 애플리케이션 아키텍처

아키텍처는 여러 가지 방식으로 정의되고 이해될 수 있는 용어다.

가장 단순한 정의를 보자면 어떤 경계 안에 있는 내부 구성요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는지를 규정하는 것이라고 할 수 있다.

## 9.3.1 계층형 아키텍처

### 아키텍처와 SoC

지금까지는 성격이 다른 코드가 얽혀 있는 것을 두 개의 오브젝트로 분리

→ 그 사이에 유연한 결합을 가질 수 있도록 인터페이스를 두고, 그 관계를 맺어주는 제 3의 존재인 DI 컨테이너를 둬서 오브젝트끼리는 직접적인 관계를 알지 못하도록 만드는 것이 DI를 기반으로 한 유연한 설계와 구현 전략.

이런 원리는 아키텍처 레벨에서 좀 더 큰 단위에 대해서도 동일하게 적용할 수 있다.

오브젝트를 하나의 모듈 단위로 생각해보자, 때론 그보다 작은 단위, 예를 들면 하나의 클래스 안에 있는 메소드 레벨에서 같은 원리를 적용할 수 있다.

심지어 하나의 메소드안의 코드에도 같은 방식의 접근이 가능하다.

애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진것들끼리 묶을 수 있다.

ex) 데이터 액세스 로직을 담당하는 DAO들은 하나의 단위로 생각 가능

만약 이렇게 나뉘어 있지 않다면 어떻게 될까?

DB에서 정보를 어떻게 가져오는지에 대한 로직을 담은 SQL과, JDBC 코드와 HTML 태그 사이에 읽어온 정보를 넣는 코드가 함께 존재할 수 있다.

성격과 책임이 분명히 다른 것들이 한데 모여 얽혀 있으면 많은 문제가 발생한다.

ex) 스파게티 코드

따라서 성격이 다른 것은 아키텍처 레벨에서 분리해주는게 좋다.

→ 분리된 각 오브젝트는 독자적으로 개발과 테스트가 가능해서 개발과 변경 작업이 모두 빨라질 수있다.

또한 장점으로 구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연하고, 전체를 이해하기도 상대적으로 쉽다.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을

계층형 아키텍처 또는 멀티 티어 아키텍처라고도 한다.

보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 갖는다고 해서 3계층 애플리케이션이라고도 한다.

물론 반드시 모든 엔터프라이즈 애플리케이션을 3계층으로 만들어야만 하는 것은 아니다.

경우에 따라서 다른 구분 방법을 선택하기도 하고, 각 계층을 좀 더 세분화해서 더 작은 단위의 계층으로 나눌 수도 있다.

### 3계층 아키텍처와 수직 계층

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image.png)

3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 데이터 액세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 그 흐름을 관리하는 프레젠테이션 계층으로 구분한다.

- 데이터 액세스 계층

데이터 액세스 계층은 DAO 계층이라고도 불린다. DAO 패턴을 보편적으로 사용하기 때문이다.

또한 데이터 액세스 계층은 DB 외에도 ERP, 레거시 시스템, 메인프레임 등에 접근하는 역할을 하기 때문에 EIS(Enterprise Information System) 계층이라고도 한다.

대개는 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임이다.

또 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(Infrastructure) 계층으로 따로 분류하기도 한다.

데이터 액세스 계층은 사용 기술에 따라서 사용 기술에 따라서 다시 세분화된 계층으로 구분될 수 있다.

애플리케이션에서 담당하는 역할에 따라 분류한 3계층 구조와 달리, 데이터 액세스 계층 안에서 다시 세분화하는 경우는 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고 부르기도 한다.

기본 3계층은 기술 계층보다는 역할에 따라 구분한 것이므로 보통 그림으로 나타낼때 가로로 배열한다. 반면에 같은 책임을 가졌지만 추상화 레벨에 따라 구분하는 경우는 세로로 배열해서 표현한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%201.png)

JdbcTemplate을 사용하는 데이터 액세스 계층의 특징은 JdbcTemplate이 추상화를 위한 계층으로 사용돼서 로우레벨의 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만드는 것이다.

그럼 그냥 강제적으로 JDBC API를 사용하거나 트랜잭션 동기화 API로 접근하는것이 좋지 않냐?

→ 추상화 계층구조를 따른다면 항상 JdbcTemplate을 통해 접근하도록 코드를 작성하는 것이 바람직하다.

추상화 계층은 필요하다면 얼마든지 추가할 수 있다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%202.png)

새로운 추상 계층을 도입해서 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근할 수 있게 만들어주는 구조.

새로운 계층 추가 → 개발자의 애플리케이션 코드에 지대한 영향을 줌.

따라서 계층 추가는 매우 신중하게 결정해야 함.

한번 새로운 계층과 API를 만들어 적용하면 이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응해야 하는 책임을 가져야 함.

- 서비스 계층

구조로 보면 가장 단순함.

잘 만들어진 스프링 애플리케이션의 서비스 계층 클래스는 이상적인 POJO로 작성됨.

POJO로 만든다면 객체지향적인 설계 기법이 적용된 코드를 통해서 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장할 수 있음.

서비스 계층은 DAO 계층을 호출하고 이를 활요해서 만들어짐.

서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층구조를 가질 필요가 없음.

단순히 POJO 레벨에서 비즈니스 로직을 모델링하다가 상속구조를 만들 수 있을진 몰라도 기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근하게 하거나 편하게 사용하게 해주는 추상화는 필요 없기 때문이다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%203.png)

위 그림은 서비스 계층과 기반 서비스 계층, DAO 계층의 관계를 나타낸 것.

주목할 부분은 기반 서비스 계층이 서비스 계층의 오브젝트를 호출하는 경우.

일반적으로 서비스 계층의 코드를 기반 서비스 계층의 API를 호출해서 이용함. 하지만 반대로 서비스 계층의 코드를 기반 서비스 계층에서 실행시키는 경우가 있음

→ 대표적으로 스케줄링이 대표적인 경우. 미리 정해진 시간에 특정 서비스 계층의 로직이 동작하게 만드는 백그라운드 서비스가 필요하다면 기반 서비스 계층에서 서비스 계층의 오브젝트를 이용하게 할 수도 있음.

원칙적으로 서비스 계층의 코드가 기반 서비스 계층의 구현에 종속되면 안 됨.

서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성을 제거해야 함. 또는 AOP를 통해서 서비스 계층의 코드를 침범하지 않고 부가기능을 추가하는 방법을 활용해야 함.

이상적인 서비스 계층 : 백엔드 시스템과 연결되는 데이터 엑세스 계층이 바뀌고, 클라이언트와 연결되는 프레젠테이션 계층이 바뀌어도 그대로 유지될 수 있어야 함.

- 프레젠테이션 계층

프레젠테이션 계층은 가장 복잡한 계층이다.

웹과 프레젠테이션 기술은 끊임없이 발전하고 진보하고 새로운 모델이 등장하기 때문에 이 계층에서 사용할 기술과 구조를 선택하는 일은 간단하지 않다.

엔터프라이즈 애플리케이션의 프레젠테이션 계층은 클라이언트의 종류와 상관없이 HTTP 프로토콜을 사용하는 서블릿이 바탕이 된다.

 HTTP 외의 프로토콜을 사용하는 엔터프라이즈 서비스가 전혀 없는 것은 아니지만, 방화벽 문제라든가 통합된 보안의 문제 등으로 인해 HTTP로 모두 수렴되는 추세다.

현재는 프레젠테이션 로직이 클라이언트로 이동하고 있다. RIA라고 불리는 기술이나 SOFEA 아키텍처가 대표적인 예다.

스프링은 웹 기반의 프레젠테이션 계층을 개발할 수 있는 전용 웹 프레임워크를 제공한다.

### 계층형 아키텍처 설계의 원칙

오브젝트와 그 관계에 적용했던 대부분의 객체지향 설계의 원칙은 아키텍처 레벨의 계층과 그 관계에도 동일하게 적용할 수 있다. 각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지할 수 있어야 한다.

각 계층은 자신의 계층의 책임에만 충실해야 한다. 데이터 액세스 계층은 데이터 액세스에 관한 모든 것을 스스로 처리해야 한다.

각 계층은 자신의 역할에만 충실해야 하고 자신과 관련된 기술이 아닌 다른 기술 API의 사용을 삼가해야 한다.

자신의 역할과 기술에만 충실한 계층을 만들면 각 계층 사이의 결합도는 자연스럽게 낮아진다. 각 계층이 자신의 책임에 충실하게 작성되어 있다면 필요한 그 밖의 작업은 다른 계층에 요청하게 될 것이다. 이때는 계층 레벨에 정의한 인터페이스를 통해서 요청을 하게 되고, 계층 간에 사용되는 인터페이스 메소드에는 특정 계층의 기술이 최대한 드러나지 않게 만들어야 한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%204.png)

위 코드는 종종 실수하는 계층 간 설계의 예다. 서비스 계층이 DAO를 호출할 때 사용하도록 정의한 인터페이스의 메소드다.

findUserByName() 메소드의 문제는 데이터 액세스 계층의 기술과 그 역할을 다른 계층에 노출한다는 점이다. 결과를 JDBC의 ResultSet 오브젝트로 돌려주면 이를 사용하는 서비스 계층의 코드는 ResultSet이라는 데이터 액세스 계층에서 만들어진 오브젝트를 직접 다뤄야 함.

결국 JDBC라는 특정 데이터 액세스 계층 기술에 종속되는 서비스 계층의 코드가 되고 맘.

ResultSet을 다루는 예외처리도 해야하고, 경우에 따라서 리소스를 반환하거나 DB 커넥션을 종료시키는 등의 데이터 액세스 작업도 맡아야 한다.

예외도 마찬가지다. SQLException이라는 JDBC 기술 종속적인 예외를,그것도 체크 예외로 던져버리면, 이를 사용하는 서비스 계층에서는 SQLException을 해석해서 예외상황을 분석하고 이를 처리하는 코드를 만들어야 한다. 특정 데이터 애겟스 계층의 구현에 종속되는 강한 결합이 만들어짐.

→ 유연성이 떨어지기 때문에 각 계층의 내부구현이 변화되면 다른 계층의 코드도 함께 수정해줘야 한다. 코드의 중복이 일어날 가능성이 높고 전체 코드를 이해하기는 힘들어진다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%205.png)

따라서 이렇게 수정되어야 한다.

User는 사용자 정보를 담고 있는 단순한 오브젝트다. 따라서 특정 계층의 기술이나 구현에 종속되지 않음 → 결과를 특정 계층에 종속되지 않는 단순한 오브젝트의 형태로 전달되어야 함. 또 데이터 액세스 예외와 같이 특별한 경우에만 전달될 가능성이 있는 것은 스프링의 DataAccessException처럼 런타임 예외로 만들어야 함. → 그 존재를 무시해도 되도록.

특별한 이유로 데이터 액세스 예외로 다뤄야 하는 경우에라도 JDBC, JPA, JDO, Hibernate처럼 특정 구현 방식에 종속되지 않는 추상적인 형태로 만들어줘야 함. → 낮은 결합도 유지, 유연한 변경 가능

또, 흔히 저지르는 실수 중의 하나는 프레젠테이션 계층의 오브젝트를 그대로 서비스 계층으로 전달하는 것. 서블릿의 HttpServletRequest나 HttpServletResponse, HttpSession 같은 타입을 서비스 계층 인터페이스 메소드의 파라미터 타입으로 사용하면 안된다. 계층의 경계를 넘어갈 때는 반드시 특정 계층에 종속되지 않는 오브젝트 형태로 변환해줘야 한다.

만약 서비스 계층의 코드에 웹 프레젠테이션 계층의 기술을 노출했다고 가정해보자.

웹 방식의 클라이언트가 아닌 다른 시스템에서 요청을 받아서 처리해야 하는 경우에는웹 기술에 종속된 코드는 재사용이 불가능해진다. 결국 같은 로직을 가졌지만 클라이언트의 종류에 따라서 비즈니스 로직 코드가 달라지는 결과를 초래할 수도 있다.

서비스 계층에서 웹과 관련된 예외가 발생할 경우 문제의 원인을 찾기 어려움.

어떤 경우에라도 계층 상의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.

당연히 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다. 인터페이슬르 하나 더 만드는 것이 번거롭다고 그냥 클래스를 이용해서는 안 된다. 인터페이스를 사용하게 한다는 건 각 계층의 경계를 넘어서 들어오는 요청을 명확히 정의하겠다는 의미다.

여기서 말하는 인터페이스란 단지 자바의 interface 키워드를 사용하라는 의미가 아니다. 인터페이스에 아무 생각 없이 클래스의 모든 public 메소드를 추가한다면 인터페이스를 사용하는 가치가 떨어진다.

한번 정의돼서 다른 계층에서 사용하기 시작한 인터페이스 메소드는 변경이 매우 까다롭고 비용이 많이 든다. 따라서 매우 신중하게 결정해야 하며 계층 내부의 예상되는 변화에도 쉽게 바뀌지 않도록 주의해서 만들어야 한다.

당연히 다른 계층에서 꼭 필요한 메소드만 노출해야 한다.

스프링의 DI는 기본적으로 오브젝트 사이의 관계를 다룬다. 따라서 계층 사이의 경계나 그 관계에 직접적으로 관여하지 않는다. 하지만 모든 경계에는 오브젝트가 존재하고 그 사이의 관계도 오브젝트 대 오브젝트로 정의되기 마련이다. 그런 면에서 스프링의 DI가 계층 사이의 관계에도 적용된다고 볼 수 있다. 하지만 DI는 계층을 구분해주지 않기 때문에 빈 사이의 의존관계를 만들 때 주의해야 한다. 한 계층의 내부에서만 사용되도록 만든 빈 오브젝트가 있는데, 이를 DI를 통해 다른 계층에서 함부로 가져다 쓰는 일은 피해야 한다는 말. 또, 중간 계층을 건너뛰어서 관계를 갖지 않는 계층의 빈을 직접 DI하지 않도록 주의해야 한다.

## 9.3.2 애플리케이션 정보 아키텍처

엔터프라이즈 시스템은 본질적으로 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다. 사용자의 작업 상태를 오래 유지할 수 있는 독립 애플리케이션과 달리 엔터프라이즈 애플리케이션은 일반적으로 사용자의 요청을 처리하는 동안만 간단한 상태를 유지한다.

애플리케이션의 주요 상태정보는 클라이언트나 백엔드 시스템에 분산돼서 보관된다.

애플리케이션을 사이에 두고 흘러다니는 정보를 어떤 식으로 다룰지를 결정하는 일도 아키텍처를 결정할 때 매우 중요한 기준이 된다. 엔터프라이즈 애플리케이션에 존재하는 정보를 단순히 데이터로 다루는 경우와 오브젝트로 다루는 경우, 두 가지 기준으로 구분해볼 수 있다.

데이터 중심 아키텍처: 애플리케이션에 흘러다니는 정보를 단순히 값이나 값을 담기 위한 목적의 오브젝트 형태로 취급하는 구조.

DB나 백엔드 시스템에서 가져온 정보를 값으로 다루고 그 값을 취급하는 코드를 만들어 로직을 구현하고 값을 그대로 프레젠테이션 계층의 뷰, 즉 사용자가 보는 화면과 연결해주는 것이다.

이런 방식은 객체지향 기술이나 언어를 사용하지 않던 시절의 엔터프라이즈 애플리케이션과 크게 다를 바 없다.

데이터 중심 설계의 특징은 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 담겨 있는 경우가 많다는 점.

데이터 중심 아키텍처는 핵심 비즈니스 로직을 어디에 많이 두는지에 따라서 DB에 무게를 두는 구조와 서비스 계층의 코드에 무게를 두는 구조로 구분할 수 있다.

### DB/SQL 중심의 로직 구현 방식

데이터 중심 구조의 특징은 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다는 점이다. 예를 들어 사용자의 이름으로 사용자 정보를 검색해서 일치하는 사용자의 아이디, 비밀번호, 이름, 가입일자만을 보여주는 작업이 있다고 하자. 이것이 하나의 업무 단위가 되면 모든 계층의 코드가 이 기준에 맞춰서 만들어진다. 사용자 조회라는 업무를 위해서만 존재하는 각 계층의 코드가 만들어진다는 뜻이다.

검색조건은 SQL로 만들어 진다.

SQL의 결과는 컬럼 이름을 키로 갖는 맵에 저장되거나 조회 페이지에 필요한 네 가지 정보를 담을 수 있는 단순한 오브젝트를 저장돼서 전달된다. 서비스 계층은 별로 할 일이 없다.

모든 계층의 코드는 ‘이름을 이용한 고객 조회’라는 업무에 종속된다. 또한 업무의 내용이 바뀌면 모든 계층의 코드가 함께 변경된다. 종속적일 뿐 아니라 배타적이어서 다른 단위 업무에 재사용되기 힘들다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%206.png)

대용량 데이터를 다루면서 빠른 처리가 필요한 경우에는 일부 로직을 DB 내에 존재하는 PL/SQL과 같은 저장 프로시저 형태로 만들기도 한다. 조회 로직이 조건이 많고 복잡하다면 그만큼 복잡한 SQL이 만들어질 것이다. 자바 코드의 로직은 기껏해야 사용자 요청에 따라서 어떤 SQL을 가진 DAO를 실행할지를 결정하는 정도일 것이다.

대부분의 코드는 대응되는 작업 단위에 1:1로 매핑된다. 여러 작업에서 반복되는 기능이 있다면 그에 대한 코드는 중복되기 쉽다. 보통 작업 단위, 즉 업무 트랜잭션 단위로 코드를 묶어서 만들지 기능을 세분화해서 분리하고 재사용하지 않기 때문이다. 하나의 업무 트랜잭션을 모두 담은 서비스 계층 코드와 해당 업무에 특화된 SQL을 담은 하나 또는 여러개의 DAO메소드로 구성된다. 서비스 계층이 프레젠테이션 계층에 전달하는 결과의 포맷은 보통 DAO의 SQL 결과와 같고, 웹 페이지의 출력 내용과도 1:1로 대응된다.

이런 식의 개발 방법과 아키텍처는 사실 자바 기술이 발전하기 이전의 엔터프라이즈 시스템에서 흔히 발견할 수 있다.

굳이 자바라는 객체지향 언어와 프로그래밍 기술을 사용하지 않더라도 3계층 구조로 만드는 전통적인 개발 방법에서, 또는 서비스 계층이 별 의미가 없으므로 클라이언트의 독립 프로그램에 담아두고 DB 처리 로직만 DB에 분리해둔 2계층 구조에서도 비슷하게 발견할 수 있다.

이런 방식은 개발하기 쉽다는 장점이 있다.

하지만 이런 방식은 자바 코드를 단지 DB와 웹 화면을 연결해주는 단순한 인터페이스 도구로 전락시키는 것이다. 자바의 오브젝트는 단지 HTTP 서비스 채널을 만들어주고 JDBC를 이용해 DB 기능을 사용하게 하는 스크립트 정도로 축소된다.

이렇게 DB 중심의 업무 단위로 코드를 만들면 애플리케이션 내에서 흘러다니는 정보는 항상 단순한 포맷의 데이터다. 

하지만 이런 코드는 항상 SQL과 그 결과에 종속되기 때문에 SQL의 변화가 일어나면 같이 변경돼야 한다. 겉으로 보기에는 각 계층이 독립적으로 보이지만, 그 사이를 이동하는 데이터가 일종의 접착제 역할을 해서 강한 결합을 만들게 된다.

스프링을 사용하면 이런 데이터 중심의 코드를 만들 수 있을 뿐만 아니라, 실제로 매우 흔하게 발견된다. 데이터와 업무 트랜잭션 중심의 개발에 익숙한 사람들이 많고 이런 아키텍처를 의도적으로 선호하는 개발자도 많기 때문이다.

개발자들끼리 서로 간섭 없이 자신에게 할당된 기능을 독립적으로 만드는 데도 편하다. 최소한의 공통 모듈 정도만 제공되는 것을 사용하고, 그 외의 기능은 단위 업무 또는 웹 화면 단위로 만들어 준다.

하지만 이런 개발 방식은 변화에 매우 취약하다. 객체지향의 장점이 별로 활용되지 못하는데다 각 계층의 코드가 긴밀하게 연결되어 있기 때문이다.

중복을 제거하기도 쉽지 않다.

로직을 DB와 SQL에 많이 담으면 담을수록 확정성이 떨어지고, DB는 확장헤 한계가 있을 뿐 아니라 확장한더 하더라도 매우 큰 비용이 든다.

상대적으로 애플리케이션 서버와 그 안에 담긴 오브젝트는 비용이 적게 든다. 서버를 늘려 쉽게 확장할 수도 있다.(Scale ?) 또 손쉽게 여러 대의 서버를 클러스터로 묶어서 하나의 서버처럼 동작하게 만들 수 있다. 오브젝트를 만들고 코드를 동작시키는 비용은 DB에서 비슷한 작업을 할 때에 비해 저렴하다.

또한 SQL이나 저장 프로시저에 담긴 로직은 테스트하기 힘들다. 

반면 오브젝트에 담긴 로직은 간단히 검증할 수 있다. 또한 요즘 주행하는 객체지향 분석과 모델링의 결과로 나온 모델을 가져다 쉽게 오브젝트로 만들어낼 수 있다.

따라서 DB에는 부하를 가능한 한 주지 않는 간단한 작업만 하고 복잡한 로직은 오브젝트에 담아서 애플리케이션 내에서 처리하도록 만드는 편이 낫다.

단순히 익숙하고 편하다는 이유로 스프링 애플리케이션 개발에도 여전히 DB 중심의 아키텍처를 선택한다면 스프링의 장점을 제대로 누릴 수 있는 기회를 얻지 못할 것이 분명함.

### 거대한 서비스 계층 방식

DB에서 가져온 데이터가 애플리케이션에 흘러다니는 정보의 중심이 되는 아키텍처이긴 하지만 DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이는 방법이 있다. DB에는 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것이다.

비즈니스 로직을 DB나 SQL에 담는 경우에는 항상 최종 결과만 DAO에서 서비스 계층으로 전달된다. 반면에 거대 서비스 계층 방식에서는 DAO에서 좀 더 단순한 결과를 돌려준다. DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 된다.

DAO와 SQL은 상대적으로 단순해지고, 그중 일부는 여러 서비스 계층 코드에서 재사용이 가능해진다.

비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커진다.

업무 트랜잭션 단위로 서비스 계층의 메소드가 만들어질 가능성이 높은데, 그러다 보면 하나의 메소드가 매우 거대해지기도 한다. 이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄겠지만 전체 클래스 코드의 양은 그대로다.

상대적으로 단순한 DAO 로직을 사용하고, 비즈니스 로직의 대부분을 서비스 계층에 집중하는 이런 접근 방법은 거대한 서비스 계층을 만들게 된다.

데이터의 분석, 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문이다.

서비스 계층의 코드는 여전히 업무 트랜잭션 단위로 집중돼서 만들어지기 때문에 DAO를 공유할 수 있는 것을 제외하면 코드의 중복도 적지 않게 발생한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%207.png)

거대 서비스 계층 방식의 장점은 애플리케이션의 코드에 비즈니스 로직이 담겨 있기 때문에 자바 언어의 장점을 활용해 로직을 구현할  수 있고 테스트하기도 수월하다는 점이다.

또한 DAO가 다루는 SQL이 복잡하지 않고 프레젠테이션 계층의 뷰와 1:1로 매핑되지 않아도 되기 때문에 일부 DAO 코드는 여러 비즈니스 로직에서 공유해서 사용할 수 있다.

하지만 데이터 액세스 계층의 SQL은 서비스 계층의 비즈니스 로직의 필요에 따라 만들어지기 쉽다. 그래서 계층 간의 결합도가 여전히 크다.

서비스 계층의 메소드는 크기가 큰 업무 트랜잭션 단위로 만들어지기 때문에 비슷한 기능의 코드가 여러 메소드에서 중복돼서 나타나기 쉽다.

자주 사용되는 세부 로직을 추출해서 공통 기능으로 뽑아내는 일도 불가능하진 않지만 일반화하기는 힘들다. → DAO가 제공해주는 값의 포맷에 따라 이를 취급하는 방법이 달라지기 때문이다.

예를 들어 사용자 정보를 간단히 조작해주는 공통적인 기능이 있다고 가정했었을때, 어떤 비즈니스 로직에서는 DAO로부터 사용자 정보를 다른 정보와 조인해서 함께 맵에 담아 가져오고, 또 어떤 로직에서는 사용자 정보 중 일부만 데이터 저장 오브젝트에 담아서 가져온다고 해보자.

이런 경우 사용자 정보가 담겨 있는 포맷과 타입이 다르기 때문에 공통적인 사용자 정보 처리 기능을 만들어 사용하기가 힘들다. 비록 DAO에 복잡한 조건의 로직을 넣지는 않더라도 서비스 계층에서필요한 정보를 한 번에 SQL을 통해 가져오고,그 값을 저장하는 방식이 일관성 없이 매번 달라질 수 있기 때문에 서비스 계층의 코드나 DAO에 적지 않은 중복이 발생한다.

→ 반면에 각 단위 업무별로 독립적인 개발이 가능하므로 초기 개발 속도가 빠르고, 개발자 사이에 간섭 없이 독립적인 개발이 가능하다는 장점이 있다.

또한 핵심 로직이 자바 코드 안에 담겨 있으므로 테스트하기가 상대적으로 수월하다.

하지만 본격적인 객체지향적 설계를 적용하기 힘들고, 개발자 개개인의 코딩 습관이나 실력에 따라서 비슷한 로직이더라도 전혀 다른 스타일의 코드가 나오기 십상이다.

또한 계층별로 독립된 설계와 개발이 어렵고, 개발이 진행되면서 구혀할 비즈니스 로직이나 설계에 변경이 생기거나 유지보수 중에 수정할 필요가 있을 경우 코드를 손대기가쉽지 않을 수도 있다 → 만약 테스트가 불충분하거나 아예 없다면 스파게티 코드가 될 수 있다.

데이터 중심 아키텍처의 특징은 계층 사이의 결합도가 높은 편이고 응집도는 떨어진다는 점이다. 화면을 중심으로 하는 업무 트랜잭션 단위로 코드가 모이기 때문에 처음엔 개발하기 편하지만 중복이 많아지기 쉽고 장기적으로 코드를 관리하고 발전시키기 힘들다는 단점이 존재한다.

## 9.3.3 오브젝트 중심 아키텍처

오브젝트 중심 아키텍처가 데이터 중심 아키텍처와 다른 가장 큰 특징은 도메인 모델을 반영하는 오브젝트 구조를 만들어두고 그것을 각 계층 사이에서

정보를 전송하는 데 사용한다는 것이다. 그래서 오브젝트 중심 아키텍처는 객체지향 분석과 모델링의 결과로 나오는 도메인 모델을 오브젝트 모델로 활용한다.

대개 도메인 모델은 DB의 엔티티 설계에도 반영되기 때문에 관계형 DB의 엔티티 구조와도 유사한 형태일 가능성이 높다. 물론 DB에는 없지만 비즈니스 로직에만 존재하는 모델도 있기 때문에 항상 일치하는 것은 아니다.

이렇게 오브젝트를 만들어두고 오브젝트 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만드는 것이 오브젝트 중심 아키텍처이다.

### 데이터와 오브젝트

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%208.png)

어떤 업무를 분석해보니 카테고리와 상품이라는 두 가지 엔티티가 나온다고 해보자.

카테고리 하나에는 여러 개의 상품이 포함된다. 각 상품은 하나의 카테고리에 소속된다. 전형적인 1:N 관계.

이를 DB 테이블로 만들면 두 테이블 사이의 관계를 위해서 Product 쪽에 Category와 관계를 만들어주는 외래키를 하나 둬야 한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%209.png)

조건에 맞는 모든 카테고리와 상품 정보를 가져와서 화면에 출력하는 기능을 만든다고 해보자. 이때 데이터 중심 아키텍처에서는 SQL과 DB 관점에서 생각한다. 이 두 개의 정보를 조합해서 가져오는 방법은 JOIN을 이용해 2차원 구조의 정보를 만드는 것이다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2010.png)

SQL 실행 결과는 맵이나 배열에 담는다.

배열에 담으려면 인덱스별로 필드 이름을 일일이 기억해야 하기 때문에 불편하다. 배열대신 맵에 필드 이름과 값을 함께 담고 맵의 리스트를 만들어 돌려주는 게 편리하다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2011.png)

DAO → SQL을 실행한 결과를 담아서 서비스 계층으로 전달

서비스 계층에 전달되는 것은 List<Map<String, Object>> 타입이다.

이 타입만 봐서는 안에 담긴 내용이 어떤 것인지 알 수 없다. 따라서 이 결과를 사용하는 서비스 계층이나 프레젠테이션 계층의 코드에서는 DAO 메소드에서 두 개의 테이블을 조인해서 다섯가지 필드의 값을 가져오고, 필드 이름을 키로 갖는 맵에 값을 저장했음을 알아야 사용할 수 있다.

만약 SQL의 변경이나 필드 개수, 순서 이름을 바꾼다면?

→ 서비스 계층과 프레젠테이션 계층의 코드도 같이 변경돼야 한다.

1:N 관계에 있는 두 개의 테이블을 조인해서 2차원 구조로 풀어놓은 데이터이기 때문에 이 안에는 원래 Category와 Productrk 1:N의 관계를 맺고 있었고 어떻게 서로 참조할 수 있는지에 대한 정보는 없다. SQL을 통해서 가공된 데이터의 구조를 알고, 이를 활용하는 것이 전부다.

데이터 중심 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 된다. 도메인 분석을 통해 작성된 모델정보는 DB에 대한 SQL을 작성할 때 외에는 코드에 반영되는 일이 없다.

반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담긴다. 도메인 모델은 애플리케이션 전 계층에서 동일한 의미를 갖는다. 따라서 도메인 모델이 반영된 도메인 오브젝트도 전 계층에서 일관된 구조를 유지한 채로 사용될 수 있다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2012.png)

이 구조는 단순히 특정 SQL에 대응되는 맵과 배열,매번 달라지는 SQL 결과를 담기 위해 급조해서 만든 오브젝트와는 달리, 애플리케이션 어디에서도 사용될 수 있는 일관된 형식의 도메인 정보를 담고 있다. DB에서 SQL 결과로 가져온 값을 그대로 사용하는 경우와는 다르게, 도메인 모델을 반영하는 오브젝트를 사용하면 자바 언어의 특성을 최대한 활용할 수 있도록 정보를 가공할 수 있다. 대표적으로 오브젝트 사이의 관계를 나타내는 방법을 들 수 있다.

RDB에서는 테이블 간의 관계를 직접 명시하는 방법은 없다.

대신 키의 조합을 통해 그때그때 테이블을 조인해서 의미 있는 관계를 만들어내야 한다. 반면에 자바에는 관계하고 있는 다른 오브젝트와 직접 연결하는 방법이 있다. 레퍼런스 변수를 이용해서 다른 오브젝트를 참조하는 것이다. 하나 이상의 오브젝트와 관계를 가지려면 컬렉션을 이용할 수도 있다.

Product 클래스에는 Product 테이블 처럼 categoryid라는 외래키가 없다. 대신 Category 오브젝트를 기리키는 레퍼런스 변수를 갖고 있다. 반대로 하나의 Category는 여러개의 Product와 관계를 가질 수 있으므로 Set이라는 컬렉션을 이용해 여러 개의 Product 오브젝트를 참조하게 만들 수 있다. DB의 카테고리 테이블에는 Product 테이블과 어떻게 연결되는지에 대한 정보가 없다. 하지만 자바에서는 레퍼런스 변수를 통한 상호 참조가 가능하기 때문에 원한다면 Category 오브젝트에서 다음과 같은 코드로 Category에 속한 Product를 간단히 가져올 수도 있다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2013.png)

데이터 중심 방식에서는 Category와 그에 대응되는 Product를 찾아 SQL을 이용해 조인한 다음 하나의 맵에 뭉뚱그려서 가져왔다. 반면에 오브젝트 중심 방식에서는 테이블의 정보와 그 관계를 유지한 채로 정확한 개수의 Category 오브젝트와 그에 대응되는 Product 오브젝트로 만들어 사용한다.

따라서 테이블에 Category가 하나이고 그에 대응되는 Product 열이 5개라면, 오브젝트도 하나의 Category 오브젝트와 이에 연결된 5개의 Product가 만들어질 것이다. 이 두 가지 오브젝트는 레퍼런스 변수를 통해 서로 연결되어 있기 때문에 메소드 파라미터나 리턴 값으로 전달할 때 Category 오브젝트 하나를 전달하더라도 그에 연결된 Product 5개가 함께 전달된다. 반대로 Product의 컬렉션을 전달해도 된다. 어차피 레퍼런스를 따라가면 서로 참조할 수 있기 때문.

이렇게 도메인 모델을 따르는 오브젝트 구조를 만들려면 DB에서 가져온 데이터를 도메인 오브젝트 구조에 맞게 변환해줄 필요가 있다. 한 번 변환되면 그 이후의 작업은 수월해진다. 서비스 계층에서 필요한 정보를 조건에 맞게 조회해서 도메인 모델 오브젝트 형태로 돌려주는 DAO를 이용하기만 하면 된다. 그리고 가져온 도메인 오브젝트에 담긴 정보를 활용해서 비즈니스 로직을 처리하면 된다. 프레젠테이션 계층에 전달할 때도 마찬가지다. 어떤 DAO가 사용됐고, 어떤 비즈니스 로직을 거쳤는지에 관해선 프레젠테이션 계층은 알 필요가 없다.

### 도메인 오브젝트를 사용하는 코드

오브젝트 중심 방식에서 비즈니스 로직의 구현이 얼마나 간단하고 명확한지 살펴보자.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2014.png)

어떤 카테고리에 포홤된 상품의 모든 가격을 계산해야 하는 로직이 필요하다면 서비스 계층의 오브젝트안에 위와 같은 메소드를 만들어 사용하면 된다.

어떤 DAO를 이용해서 Category를 가져왔는지는 중요하지 않다. 조건을 가지고 Category를 하나 검색했을 수도 있고, 모든 Category 목록을 가져왔을 수도 있다. 어떻게든 Category 오브젝트를 갖고 있다면 calcTotalOfProudctPrice() 메소드를 호출해서 카테고리에 담긴 모든 상품 가격의 합을 계산할 수 있다.

도메인 모델을 알고 있다면 calcTotalOfProudctPrice() 메소드가 무슨 작업을 하는지 이해하기 어렵지 않다. 테스트를 만들어 검증하기도 간단하고, 로직이 변경될 때 코드를 수정하기도 수월하다. Category 자체가 독립된 오브젝트이므로 서비스 계층 어디에서든지 Category의 상품 가격을 계산할 때는 이 메소드를 사용하면 된다. Category 내의 상품 가격을 계산하는 코드가 여러 개의 업무 트랜잭션에서 필요하다고 해도 코드의 중복이 일어나지 않을 수 있다.

반면에 데이터 중심 방식에서라면 이런 식의 재사용 가능한 메소드를 만들어 사용하기가 쉽지 않다. DAO에 메소드를 추가해서 select sum(p.price)로 시작하는 SQL을 실행해 DB가 계산해주는 결과를 한 번에 가져오는 방법을 사용하려고 할지 모름. 아니면 주어진 카테고리에 포함된 상품의 가격 값의 목록을 배열 등에 담아서 돌려주는 DAO를 만들고 배열을 이용해서 합계를 계산하는 코드를 만들 수 있다.

문제는 하나의 Cateogory에 대해 상품 가격의 합을 계산하는 로직이라면 문제가 없는데, 이미 DAO 여러 개의 Category와 Product를 조인해서 가져온 경우라면 별도의 합계 계산 코드를 만들어야 한다는 점.

같은 기능의 여러 코드가 생기기 때문에 코드에 중복이 발생

오브젝트 구조로 정보를 갖고 있으면 어떤 식으로든 활용하기 편리하다.

자바에서는 참조 연산자(.)을 이용해 레퍼런스 변수를 따라가면 관련된 정보를 손쉽게 이용할 수 있다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2015.png)

위 코드는 Product 오브젝트가 하나 주어졌을 때, 해당 Product의 Category에는 상품이 모두 몇 개가 있는지 알고 싶을때 사용하는 간단한 코드이다.

만약 SQL을 이용해 Product와 Category를 조인해서 통째로 가져왔다면, 적지않은 if문을 사용해야만 이와 동일한 코드를 만들 수 있음.

SQL에 담긴 로직을 테스트하는 건 복잡하고 불편하다. 반면에 도메인 오브젝트를 사용하는 코드는 간단히 테스트 값을 담은 도메인 오브젝트를 생성해서 쉽게 검증이 가능하다.

### 도메인 오브젝트 사용의 문제점

일관된 의미를 가지고 유연하며 애플리케이션 전반에 공유 가능한 도메인 모델을 따르는 오브젝트로 정보를 다루면 장점이 많다. 코드는 이해하기 쉽고 로직을 작성하기도 수월하다. 이미 정의된 도메인 오브젝트 구조만 알고 있다면 아직 DAO가 작성되지 않았어도 뷰를 미리 만들 수도 있다. 코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 만들어질 수 있다.

하지만 단점도 있다. 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 감수해야 할 수도 있다. DAO는 비즈니스 로직의 사용 방식을 알지 못하므로, 도메인 오브젝트의 모든 필드 값을 다 채워서 전달하는 경우가 대부분이다. 그중에는 드물게 사용되는 필드도 있을 수 있다. 어떤 비즈니스 로직에서 필요한 정보가 몇 개의 필드 뿐이라면 DAO에서 도메인 오브젝트의 모든 필드 정보를 채워서 전달하는 것은 낭비일 수도 있다.

비즈니스 로직에 따라서 필요한 정보가 달라질 수 있기 때문에 발생하는 문제다.

오브젝트 관계에도 문제가 있다. 만약 단순히 Product 정보만 필요한 비즈니스 로직이 있다고 가정했었을 때, DAO가 돌려준 Product 오브젝트에는 관계를 갖고 있는 Category 오브젝트도 함께 존재하는데 만약 Product의 정보만 필요하다면 ? → Category 오브젝트까지 다 조회해서 오브젝트로 만들어서 가져오는 것은 상당한 낭비.

그냥 Product만 가져오면 되지않냐? → category의 필드에 null이 들어가기 때문에 NPE 발생 우려.

결국 최적화를 고려해서 DAO를 작성하려면 DAO는 비즈니스 로직에서 각 오브젝트를 어디까지 사용해야 하는지 알고 있어야 한다.

그래서 데이터 중심 접근 방법의 단점이라고 봤던 DAO와 비즈니스 로직 코드의 결합도가 높아지는 문제점이 발생할 수도 있다

그럼 문제를 어떻게 해결할건데?

→ Lazy loading( 지연된 로딩) 기법을 이용하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 동적으로 DB에서 다시 읽어올 수 있다.

물론 도메인 오브젝트를 사용하는 코드는 이런 사실을 전혀 의식하지 않고 처음부터 모든 오브젝트의 정보가 다 제공된다고 생각하고 작성하면 된다.

필드에 너무 많은 테이블이 있다면 그중에서 자주 사용되는 것을 골라내서 별도의 오브젝트로 정의해두고 필요에 따라 구분해서 사용하게 할 수 있다.

물론 그에 따라 DAO 메소드가 추가돼야 하고, 어느 DAO를 사용할지를 서비스 계층에서 알고 있어야 하기 때문에, 약하긴 하지만 계층 사이의 결합이 발생한다.

사실 가장 이상적인 방법은 JPA나 JDO, 하이버네이트와 같은 RDB 매핑 기술(ORM)을 사용하는 것이다.

이런 데이터 액세스 기술은 기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 번거로운 코드를 만들지 않고도 도메인 오브젝트의 생성을 최적화할 수 있다. 또한 SQL 결과를 가지고 도메인 오브젝트를 만들고 값을 채우는 등의 복잡한 DAO 코드를 만들지 않아도 되고, 내부적으로 최적화된 SQL을 사용하도록 세밀히 튜닝도 가능하다.

또, 자주 변경되지 않으면서 많은 로직에서 참조하는 레퍼런스 테이블이 있다면 이를 ORM이 제공하는 오브젝트 캐시에 담아두고 사용할 수도 있다.

코드 테이블처럼 자주 참조되는 것은 오브젝트 캐시로 만들어두면 매번 DB에서 읽어오지 않고 메모리 캐시에 가져오게 해주기 때문에 DB의 부하를 줄여줘서 성능이 많이 향상된다.

따라서 도메인 오브젝트를 사용하는 오브젝트 중심 아키텍처에서는 가능하다면 ORM과 같은 오브젝트 중심 데이터 액세스 기술을 사용하는 것을 권장한다.

ORM을 사용하지 않고 JDBC를 이용하는 경우라면 지연된 로딩 기법을 제공하는 코드를 추가나 여러개의 DAO 메소드를 추가해서 해결할 수 있다. 이 경우에 DAO 코드나 도메인 오브젝트 코드의 중복이 일부 발생하고 계층 사이의 결합도도 증가될 수는 있지만, 데이터 중심 아키텍처에 비하면 미미한 정도다.

따라서 정리하자면, 오브젝트 중심의 아키텍처는 도메인 모델을 따르는 오브젝트를 사용해 각 계층 사이에 정보를 전달하고, 이를 이용해 비즈니스 로직이나 프레젠테이션 로직을 작성한다. 계층 간의 결합도는 낮아지고 일관된 정보 모델을 사용하기 때문에 개발 생산성과 코드의 품질, 테스트 편의성도 향상시킬 수 있다.

그런데 도메인 오브젝트는 자바오브젝트다. 오브젝트느 원래 데이터를 저장하기 위해서만 사용하는 것이 아니다. 내부의 정보를 이용하는 기능도 함께 갖고 있어야 한다. 클래스는 속성과 행위의 조합이다. 필드와 그에 대한 접근자, 수정자만 갖고 있는 오브젝트는 반쪽짜리다. 가능하다면 이를 더 적극적으로 활용하게 만들어야 한다.

### 빈약한 도메인 오브젝트 방식

도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않다면 이는 온전한 오브젝트라고 보기 힘들다. 그래서 이런 오브젝트를 빈약한 오브젝트라고 부른다.

→ 이렇게라도 도메인 모델을 반영한 오브젝트에 정보를 담아 활용하는 편이 안하는 것보다는 낫다.

계층 사이의 독립성을 확보하기 위해서는 특정 계층에 종속되지 않으면서 애플리케이션 전반에서 사용될 수 있는 정보를 담은 오브젝트가 필요하기 마련이고, 그래서 이러한 방식도 실제로 많이 사용된다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2016.png)

오브젝트 자체는 복잡한 도메인 모델을 따라서 잘 만들어져 있고 이 구조를 그대로 모든 계층이 활용하도록 하고 있기 때문에 깔끔하고 유연한 코드로 만들어져 있다. 하지만 도메인 오브젝트는 데이터를 저장해두는 것 외에는 아무런 기능이 없다.

그럼 도메인 오브젝트에 넣을 수 있는 기능은 어떤 것 일까? 도메인 모델을 반영해서 만들어진 도메인 오브젝트이니 그 기능이라고 하면 도메인의 비즈니스 로직은 서비스 계층에 존재한다. 사실 다루는 정보의 구조가 다를 뿐이지 빈약한 도메인 오브젝트 방식은 데이터 중심 아키텍처의 거대 서비스 계층구조와 비슷하다.

거대 서비스 계층 방식의 하나라고 보면 된다.

비록 도메인 오브젝트라는 일관된 오브젝트를 활용하기 때문에 SQL에 의존적인 데이터 방식보다는 훨씬 유연하고 간결하지만, 여전히 서비스 계층의 메소드에 대부분의 비즈니스 로직이 들어 있기 때문에 로직의 재사용성이 떨어지고 중복의 문제가 발생하기 쉽다.

하지만 비즈니스 로직이 복잡하지 않다면 가장 만들기 쉽고 3계층 구조의 특징을 잘 살려서 개발할 수 있는 유용한 아키텍처다.

### 풍성한 도메인 오브젝트 방식

풍성한 도메인(영리한 도메인) 오브젝트 방식은 빈약한 도메인 오브젝트의 단점을 극복하고 도메인 오브젝트의 객체지향적인 특징을 잘 사용할 수 있도록 개선한 것이다. 어떤 비즈니스 로직은 특정 도메인 오브젝트나 그 관련 오브젝트가 가진 정보와 깊은 관계가 있다. 이런 로직을 서비스 계층의 코드가 아니라 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 것이다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2017.png)

위 코드는 앞에서 서비스 계층의 코드로 만들었던 calcTotalOfProductPrice()는 Category라는 오브젝트와 그 관련 Product의 정보만을 사용하는 간단한 로직이다.

이렇게 도메인 오브젝트 안에 로직을 담아두면 이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높다.

→ 데이터와 그것을 사용하는 기능이 한곳에 모여있기 때문이다.

만약 Category에 대해 상품 가격을 계산하는 작업이 CategoryService 외의 서비스 계층 오브젝트에서 필요하다고 해보자. 그때마다 Category 오브젝트를 파라미터로 해서 CategoryService의 메소드를 호출하는 것은 번거롭다. CategoryService를 사용하기 위해 DI도 해줘야 한다.

현재 재고에 대한 비즈니스 로직을 담고 있는 InventorySerivce가 있다고 하자.

여기서 특정 카테고리의 상품에 대한 현재 가격의 합을 계산할 필요가 생겼다.

그리고 혹시 만들어둔 관련 기능이 있는지 CategoryService를 뒤져보고 calcTotalOfProductPrice(Category c) 메소드를 찾았다고 하자 그러면 이 기능을 사용하기 위해

InventoryService에 CategoryService 를 DI해줘야 한다. 그렇게 주입받은 CategoryService를 호출해서 그 메소드를 이용해야 한다.

중복이 아닌 최적화된 로직을 재활용하는 것인데도 번거로울 수 있다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2018.png)

이런 식으로 여러 개의 도메인 오브젝트에 대한 로직을 사용해야 하는 복잡한 코드라면 각 비즈니스 로직을 담고 있는 서비스 오브젝트를 DI 해서 로직을 담은 메소드를 호출해야 한다. 이미 정보를 담고 있는 오브젝트가 있지만, 그 정보를 다루는 메소드는 결개의 서비스 오브젝트에 분리되어 있기 때문이다.

만약 Category 오브젝트 안에 Cateogory에 대한 계산 로직을 넣어뒀다면?

→ 번거로운 작업 감소, 그냥 직접적 요청, DI 받을 필요 없음, 비즈니스 로직 코드 중복 X

한번 코드로 살펴보자

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2019.png)

무엇보다 깔끔하다.

풍성한 도메인 오브젝트 방식은 도메인 오브젝트를 사용한다는 면에서 빈약한 오브젝트 방식과 비슷하지만, 실제 작성된 코드를 살펴보면 훨씬 간결하고 객체지향적이라는 사실을 알 수 있다. 객체지향 분석과 설계를 통해 만들어진 도메인 모델의 정보를 정적인 구조뿐 아니라 동적인 동작 방식에도 적극 활용할 수 있다.

물론 도메인 오브젝트에 비즈니스 로직을 넣는다고 해서 서비스 계층의 오브젝트가 필요없어지는 건 아님.

여전히 서비스 계층은 필요하며 중요한 역할을 하고 있음.

도메인 오브젝트 안에 메소드로 들어가는 로직들은 대부분 해당 오브젝트나, 긴밀한 연관관계를 맺고 있는 관련 오브젝트의 정보와 기능만을 활용함.

그리고 여러 종류의 도메인 오브젝트의 기능을 조합해서 복잡한 비즈니스 로직을 만들었다면 특정 도메인 오브젝트에 넣기 힘듦.

또한 도메인 오브젝트는 직접 뎅이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요하기도 함. 대개는 비즈니스 로직을 처리하는 중에 DB에 담긴 정보를 가져와서 활용하거나 결과를 다시 DB나 외부 시스템에 전송하는 등의 작업이 필요하다. 그러려면 서비스 계층의 오브젝트와 같이 DAO 오브젝트를 DI 받아서 사용할 수 있어야 함. 하지만 도메인 오브젝트는 그럴 수 없음.

why?

→  도메인 오브젝트는 스프링 컨테이너가 관리하는 오브젝트, 즉 빈이 아니기 때문

서비스 계층의 오브젝트나 데이터 액세스 계층의 오브젝트는 모두 스프링 빈, 따라서 서로 DI가 가능

DI의 전제 조건은 스프링 컨테이너에서 관리되는 빈이어야 함.

도메인 오브젝트는 애플리케이션의 코드 또는 기타 프레임워크나 라이브러리, JDBC 템플릿 등에 의해 필요할 때마다 새롭게 만들어짐. 따라서 DI를 받을 수 없음.

그래서 수식 계산이나 조건에 따른 데이터의 변경 또는 자신이 가진 정보에 대한 분석 같은 도메인 오브젝트 자신에 국한된 로직은 도메인 오브젝트 안에 추가할 수 있지만, 그 결과를 DB에 저장하거나 메일로 발송하거나 DB를 검색해서 원하는 정보를 가져와 활용하는 작업은 도메인 오브젝트에서 불가능하다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2020.png)

서비스 계층은 도메인 오브젝트를 DB나 외부 리소스에서 가져오고 변경된 정보나 새로 등록된 정보를 DB에 반영하는 등의 작업과 함께 도메인 오브젝트가 갖고 있는 기능이 있다면 이를 활용해서 비즈니스 로직을 처리해야 한다.

풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하다. 비즈니스 로직 코드를 이해하기도 쉽다. 따라서 빈약한 도메인 오브젝트를 피하고 도메인 오브젝트가 스스로 처리 가능한 기능과 도메인 비즈니스 로직을 갖도록 만드는 것이 바람직하다.

빈약한 도메인 오브젝트 방식이 항상 나쁘고 피해야할 것은 아님

도메인 모델링과 기능 분석을 통해 이상적인 도메인 오브젝트를 설계, 사전에 내부 기능을 충분히 구현해두지않았다면 도메인 오브젝트를 활용해서 비즈니스 로직을 구현해야 하는 개발자는 혼란을 느낄 수 있음.

그래서 충실한 도메인 모델링과 도메인 오브젝트 개발이 선행되고 그 내용이 개발자에게 사전에 충분히 공유되지 않았다면 차라리 데이터 구조만 오브젝트 방식으로 정의해놓은 빈약한 도메인 오브젝트 방식이 혼란을 피할 수 있고 쉽게 접근할 수 있는 대안이 될 수도 있음

### 도메인 계층 방식

지금까지는 살펴본 바로는 도메인 모델을 따르는 오브젝트르 만들고 이를 활용하는 방법에는 한계가 있음

도메인 오브젝트에 담을 수 있는 비즈니스 로직은 데이터 액세스 계층에서 가져온 내부 데이터를 분석하거나, 조건에 따라 오브젝트 정보를 변경, 생성하는 정도

이렇게 변경된 정보가 다시 DB 등에 반영되려면 서비스 계층 오브젝트의 부가적인 작업이 필요하다.

만약 도메인 오브젝트가 스스로 필요한 정보를 DAO를 통해 가져올 수 있고, 생성이나 변경이 일어났을 때 직접 DAO에게 변경사항을 반영해달라고 요청할 수는 없을까? 3계층의 오브젝트를 DI 받아서 직접 이용하게 된다면?

도메인 계층의 역할과 비중을 극대화하려다 보면 기존의 풍성한 도메인 오브젝트 방식으로는 만족할 수 없다.

→ 도메인 오브젝트가 기존 3계층과 같은 레벨로 격상되어 하나의 계층을 이루게 하는 도메인 계층 방식

도메인 오브젝트들이 하나의 독립적인 계층을 이뤄서 서비스 계층과 데이터 액세스 계층의 사이에 존재하게 하는 것이다.

두 가지 장점이 있는데,

- 도메인에 종속적인 비즈니스 로직의 처리는 서비스 계층이 아니라 도메인 계층의 오브젝트 안에서 진행된다는 점이다.

서비스 계층에서 사용자가 입력한 정보를 바탕으로 새로운 도메인 오브젝트를 만들었든 데이터 액세스 계층을 통해 도메인 오브젝트를 가져왔든 상관없이 도메인 오브젝트에게 비즈니스 로직의 처리를 요청할 수 있다.해당 도메인 오브젝트를 중심으로 만들어진 로직이라면 그 이후의 작업은 도메인 오브젝트와 그 관련 오브젝트 사이에서 진행된다. 일단 도메인 계층으로 들어가면 서비스 계층의 도움 없이도 비즈니스 로직의 대부분의 작업을 수행할 수 있다는 뜻이다.

- 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것이다.

도메인 오브젝트는 빈이 아니기 때문에 다른 빈을 DI 받을 수 없다 그럼 어떻게 해야할까?

물론 방법은 DI다. 하지만 이런 스프링이 관리하지 않는 오브젝트에 도 DI를 적용할 수 있다. 물론 그에 따른 간단한 설정이 추가돼야 한다.

스프링이 관리하지 않는 도메인 오브젝트에 DI를 적용하기 위해서는 AOP가 필요하다.

물론 스프링 AOP는 부가기능을 추가할 수 있는 위치가 메소드 호출 과정으로 한정되고 AOP의 적용 대상도 스프링의 빈 오브젝트뿐이다.

→ AsepctJ AOP를 사용하면 클래스의 생성자가 호출되면서 오브젝트가 만들어지는 시점을 조인 포인트로 사용할 수 있고 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가기능을 적용할 수 있다.

이를 이용해 도메인 오브젝트에 특별한 부가기능을 추가하는 것.

이 부가기능은 오브젝트의 수정자 메소드나 DI용 어노테이션을 참고해서 DI 가능한 대상을 스프링 컨테이너에서 찾아 DI 해주는 기능이다. 스프링이 직접 관리하지 않는 오브젝트에 대한 DI 서비스가 일종의 AOP. 부가기능으로 도메인 오브젝트에 적용 될 수 있다. 이 덕분에 도메인 오브젝트 기능의 제약이 사라진다.

물론 도메인 오브젝트에 담긴 기능은 자신과 관련 오브젝트에 대한 작업으로 한정.

도메인 계층 방식은 이전의 어떤 방식보다 도메인 오브젝트에 많은 비즈니스 로직을 담아낼 수 있다. 그럼에도 서비스 계층의 역할이 완전히 사리지는건 아니다.

때로는 여러 도메인 오브젝트의 기능을 조합해서 복잡한 작업을 진행햐야 하는 경우가 있다.

대신 서비스 계층의 비중과 규모는 단순히 도메인 오브젝트를 사용하는 방식에 비해 훨씬 작다.

도메인 오브젝트를 독립적인 계층으로 만들려고 할 때 고려해야할 중요한 사항이 있다. 도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지 말지 결정해야 한다.

도메인 오브젝트가 계층을 이루기 전에는 모든 계층에 걸쳐 사용되는 일종의 정보전달 도구 같은 역할을 했다. 하지만 독자적인 계층을 이뤘을 때는 상황이 달라질 수 있다.

선택할 수 있는 방법은 두 가지다.

- 여전히 모든 계층에서 도메인 오브젝트를 사용한다.

도메인 계층은 물론이고 서비스 계층이나 그 앞의 프레젠테이션 계층, 화면 출력을 위한 뷰에서도 직접 도메인 오브젝트를 전달받아 사용할 수 있게 하는 것이다. 가장 손쉽고 편한 방법.

도메인 모델을 따르는 오브젝트 구조를 활용하는 면에서 오브젝트 중심 아키텍처의 장점을 그대로 누릴 수 있다.

하지만 주의하지 않으면 심각한 혼란을 초래할 수 있다.

도메인 오브젝트의 메소드는 이제 단순한 값의 조작이나 분석, 변환 정도가 아니라 중요한 도메인/비즈니스 로직을 담당하고 있다.

중요한 비즈니스 로직을 담은 메소드를 함부로 호출한다면 심각한 문제가 일어날 수도 있다.

오브젝트를 넘겨받은 이상 그것을 사용하는 데 제약이 없기 때문에 함부로 조작하거나 실행해버릴 위험이 있다.

그럼 이런 문제를 피하려면? → 철저한 개발 가이드라인을 만들어두고 이를 강력하게 적용하는 것.

ex) 프레젠테이션 계층에서는 도메인 오브젝트를 전달받아 접근자를 사용해서 정보를 가져오는 경우와 폼의 결과를 반영할 새로운 도메인 오브젝트를 만들어 수정자를 호출하는 경우 외에는 다른 메소드를 이용하지 않는 개발 정책을 만들어 둠.

문제는 이런 규정을 어기는 개발자가 있다는 점인데, 이런 문제는 코딩 정책의 적용을 분석할 수 있는 툴을 이용해 검증하거나 AsepctJ의 정책/표준 강제화 기능을 사용하면 된다.

- 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 것이다.

도메인 계층 밖으로 전달될 때는 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사해서 넘겨줘야 한다. → DTO 사용

DTO는 상태의 변화를 허용하지 않고 읽기전용으로 만들어지기도 한다.

DTO는 기능을 갖지 않으므로 사용하기 안전하다. 또, 도메인 오브젝트를 외부 계층의 코드로부터 보호해준다.

반면에 도메인 오브젝트와 비슷한 구조를 가진 오브젝트를 따로 만들어야 하고 이를 매번 변환해줘야 하는 번거로움이 있다. 따라서 AOP와 같은 방법을 이용해 변환을 자동으로 해주도록 만들 필요가 있다.

두 가지 방법에서 어느 것이 낫다고 말하기 힘듦 → 번거로운 작업은 최소화하고 싶고 대신 표준 개발 정책을 잘 따라서 개발하도록 개발팀을 관리할 수 있다면 전자의 방법이 편리하다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2021.png)

도메인 계층은 기존 3계층과 비슷한 수준에서 독립적인 역할을 담당하고 있긴 하지만 그 특성은 확연히 다르다.

서비스를 제공하는 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복한다.

따라서 생명주기는 짧다고 할 수 있겠다.

도메인 오브젝트는 사용자별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문에 여러 스레드가 공유하는 싱글톤이 될 수가 없다.

또, DAO나 컨트롤러, 또는 스프링 외의 라이브러리를 통해 오브젝트가 만들어지는 경우가 많기 때문에 스프링이 관리하는 빈으로 등록조차 불가능하다. 

그럼 이런 제약과 불편을 감수하면서도 이 방식을 택해야 하는 경우는 뭘까?

→ 매우 복잡하고 변경이 잦은 도메인을 가졌을 때.

복잡한 도메인의 구조와 로직을 최대한 도메인 계층의 오브젝트에 반영하고, 도메인 모델과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서다. 도메인 계층은 응집도가 매우 높기 때문에 단위 테스트를 작성하기가 편리하다.

반면에 그만큼 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가 오히려 과도한 부담을 줄 수도 있다.

### DTO와 리포트 쿼리

오브젝트 중심 아키텍처는 애플리케이션 내의 모든 정보를 항상 도메인 오브젝트에 담고 다녀야 할까? → 꼭 그렇지는 않다.

도메인 계층 방식의 경우 도메인 계층을 벗어난 정보를 DTO라 불리는 특정 계층에 종속되지 않는 정보 전달의 목적을 가진 단순 오브젝트에 담아 사용하기도 한다. 그 외의 방법에서도 DTO의 사용이 꼭 필요할 때가 있다.

대표적인 예는 리포트 쿼리라고 불리는 DB 쿼리의 실행 결과를 담는 경우다. 리포트 쿼리는 리포트를 출력하기 위해 생성하는 쿼리라는 의미인데, 단지 리포트를 위해서라기보다는 보통 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 자료를 분석하고 그에 따른 분석/통계 결과를 생성하는 쿼리라는 의미다. 이런 쿼리의 결과는 DB 테이블에 담긴 필드의 내용보다는 그 합계, 평균과 같은 계산 값이거나 아니면 여러 테이블의 필드를 다양한 방식으로 조합해서 만들어진다.

그래서 이런 리포트 쿼리의 결과는 DTO라고 불리는 단순한 자바빈이나 아니면 키와 쌍을 갖는 맵에 담아서 전달해야한다.

## 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

3계층 구조는 스프링을 사용하는 엔터프라이즈 애플리케이션에서 가장 많이 사용되는 구조다. 스프링의 주요 모듈과 기술을 살펴보면 3계층 구조에 적합하도록 설계되어 있다는 사실만 봐도 알 수 있다.

단, 3계층이라는 것은 논리적이고 개념적인 구분이지 꼭 오브젝트 단위로 딱 끊어져서 만들어지는 게 아님을 염두에 둬야 한다. 때로는 하나의 계층이 다시 수평으로 세분화될 수도 있다. 반대로 3계층에서 두 개의 계층의 통합돼서 하나의 오브젝트에 담기는 일도 얼마든지 가능하다.

서비스 계층을 굳이 도입하지 않아도 될 만큼 비즈니스 로직이 단순한 애플리케이션리아면 서비스 계층과 데이터 액세스 계층을 통합할 수도 있다.

CRUD라는 약자로 표현되는 기능을 간단한 조건을 이용한 검색만으로 수행할 수 있는 복잡하지 않은 애플리케이션이라면 서비스 계층을 데이터 액세스 계층으로 통합하는 것도 나쁘지 않고, 이때는 트랜잭션 경계설정 위치를 DAO 메소드로 삼으면 된다.

반대로 프레젠테이션 계층에 서비스 계층을 통합하는 방법도 가능하다. DAO는 순수한 DB 인터페이스 역할을 하는 데이터 액세스 기능만 갖게 하고 조건에 따른 간단한 로직의 적용은 프레젠테이션 계층의 컨트롤러에 넣는 것이다. 이 방법은 불가능하진 않지만 스프링에서는 그리 권장되지 않는다.

스프링 AOP를 이용해 트랜잭션의 경계를 설정하기가 애매하기 때문이다.

DAO가 트랜잭션 경계가 되는 경우에는 트랜잭션 전파 기법을 이용해 여러 개의 DAO 처리를 하나의 트랜잭션으로 조합해서 간단히 묶을 수 있다. 반면에 프레젠테이션 계층의 오브젝트는 트랜잭션 단위로 삼기에는 너무 크고 트랜잭션 전파를 통해 조합하기가 애매하다. TranscationTemplate을 이용해 해결할 수 있지만 번거롭다.

따라서 3계층을 단순화해서 2계층으로 만든다면 서비스 계층과 데이터 액세스 계층을 통합하는 편이 낫다. 물론 이때도 논리적으로는 서비스 계층과 데이터 액세스 계층의 경계를 분명하게 하는 게 좋다.

프레젠테이션 계층은 보통 MVC라는 이름으로 잘 알려진 패턴 또는 아키텍처를 주로 사용한다. 프레젠테이션 계층은 특히 그 경계를 애플리케이션이 배치된 서버를 떠나서 클라이언트 까지 확장하기도 한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2022.png)

SOFEA라고 불리는 아키텍처는 프레젠테이션 계층의 코드가 서버에서 클라이언트로 다운로드돼서 클라이언트 장치안에서 동작하면서 서버에 존재하는 서비스 계층 또는 부분 프레젠테이션 계층과 통신하는 구조로 만들어진다. 프레젠테이션 계층이 가졌던 상뇽자와의 인터페이스. 화면 흐름에 대한 제어, 서비스 계층과의 통신, 상태정보의 유지 등을 클라이언트에 다운로드된 코드에서 대부분 담당하게 된다.

스프링을 처음 학습하고 도입하는 입장이라면 3계층 구조에 익숙해지는 것이 좋다.

### 정보 전송 아키텍처

스프링의 기본 기술에 가장 잘 들어맞고 쉽게 적용해볼 수 있는 것은 오브젝트 중심 아키텍처의 도메인 오브젝트 방식이다. 일단은 빈약한 도메인 오브젝트 방식으로 시작하는게 가장 쉽다. 도메인 오브젝트를 계층 간의 정보 전송을 위해 사용하고, 이를 각 계층의 코드에서 활용한다.

DAO는 그 기술이 어떤 것이든 상관없이 서비스 계층의 비즈니스 로직 또한 도메인 오브젝트를 이용해 작성한다. 프레젠테이션 계층에서도 이 도메인 오브젝트를 직접 활용하도록 만든다. 프레젠테이션 계층의 MVC 아키텍처에서도 모델은 도메인 오브젝트를 그대로 사용한다.

이렇게 도메인 오브젝트를 사용해 애플리케이션의 정보를 일관된 형태로 유지하는 게 스프링에 가장 잘 들어맞는 방식이다.

DB와 SQL에 많은 비즈니스 로직을 담고 있는 레거시 시스템을 스프링으로 전환하는 경우라면, 일단 데이터 중심의 아키텍처를 사용해도 무방하다.

3계층의 기본 구조로 잘 분리할 수만 있다면 DB 중심의 접근 방법을 사용해서 기존에 만들어 사용해봤던 SQL을 재사용한다. 그리고 전환 작업을 맞치고 검증이 끝난 후에 단계적으로 로직을 DB에서 애플리케[이션으로 가져오고, 오브젝트 중심으로 전환하는 시도를 하면 된다.

레거시 시스템의 기능은 가져오되 구현은 새롭게 처음부터 시작할 수 있다면 스프링의 철학과 개념에 가장 잘 들어맞는 도메인 오브젝트 중심의 아키텍처에 도전해보는 편이 나을 것이다.

객체지향적인 도메인 분석과 모델링에 자신이 있고 도메인 오브젝트 설계와 구현, 독립적인 테스트를 자유롭게 적용할 수 있다면 과감하게 도메인 계층 방식을 도입할 수도 있다.

하지만 고려할 점이 많으므로 충분한 사전 학습과 검증이 먼저 진행돼야 한다.

### 상태 관리와 빈 스코프

아키텍처 설계에서 한 가지 더 신경 써야 할 사항은 상태 관리다. 크게는 사용자 세션 관리부터, 작게는 하나의 단위 작업이지만 여러 페이지에 걸쳐 진행되는 위저드 기능까지 애플리케이션은 하나의 HTTP 요청의 범위를 넘어서 유지해야 하는 상태 정보가 있다.

엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않는다. 하나의 애플리케이션이 동시에 수많은 사용자의 요청을 처리하게 하기 위해 매번 간단한 요청을 받아서 그 결과를 돌려주는 방식으로 동작한다. 그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않는다(stateless)는 특징이 있다. 클라이언트로부터의 요청을 처리하는 매우 짧은 시간 동안만 도메인 오브젝트와 같은 정보저장소에 현재 상태정보가 보관되지만, 이는 요청 결과를 클라이언트에 돌려주고 나면 바로 폐기된다.

→ 그 덕분에 수많은 동시 사용자의 요청을 제한된 서버 리소스를 가지고 처리할 수 있다.

하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업정보는 유지돼야한다. 이를 위해서 웹 클라이언트에 URL, 파라미터, 폼 히든 필드,. 쿠키 등을 이용해 상태정보 또는 서버에 저장된 상태정보에 키 값을 전달해야 한다. 클라이언트와 서버 사이에서 많은 양의 정보를 계속해서 주고받을 수는 없으므로 중요한 상태정보는 파일 시스템, 데이터그리드, DB 등에 저장되기도 한다. 또는 제약이 있기는 하지만 HTTP 세션과 같은 서블릿 컨테이너가 제공하는 저장 공간을 활용하기도 한다.

이렇게 상태를 저장, 유지하는 데 어떤 방식을 사용할지 결정하는 일은 매우 중요하다. 스프링은 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장한다.

→ 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문, 또 scale out 하기 매우 쉽다.

반면에 웹 클라이언트에 폼 정보를 출력하고 이를 수정하는 등의 작업을 위해서는 HTTP 세션을 적극 활용하기도 한다.

상태는 클라이언트, 백엔드에 저장해두거나 서블릿의 HTTP 세션 정도에 일시적으로 저장해두는 것이 대부분이지만 경우에 따라서는 장기간 유지되며 중첩될 수 있는 상태를 다루는 고급 상태 관리 기법을 이용할 수도 있다.

애플리케이션의 특징에 따라서 스프링을 이용해서 상태유지 스타일의 애플리케이션을 얼마든지 만들 수 있다.

빈의 스코프를 잘 활용하면 스프링이 관리하는 빈이면서 사용자별로 또는 단위 작업별로 독립적으로 생성되고 유지되는 오브젝트를 만들어 상태를 저장하고 이를 DI를 통해 서비스 빈에서 사용하게 만들 수 있다.

### 서드파티 프레임워크, 라이브러리 적용

스프링은 거의 대부분의 자바 표준 기술과 함께 사용될 수 있다.

표준 기술 이외에도 많이 사용되는 오픈소스 프레임워크, 라이브러리나 상용 제품도 스프링과 함께 사용할 수 있다.

그렇다면 스프링이 지원하느 기술이란 무슨 의미일까?

- 첫째, 해당 기술을 스프링의 DI 패턴에 따라 사용할 수 있다.

프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록할 수 있게 지원해주는 것이라고 생각해도 좋다.

예를 들어 하이버네이트의 기능을 사용하려면 SessionFactory 오브젝트가 먼저 만들어져야 한다. sessionFactory가 만들어지려면 설정파일에 대한 정보, 설정 값을 담은 프로퍼티와 DB 연결에 대한 정보가 필요하다.

스프링에서는 빈으로 등록하는 것만으로도 간단히 생성할 수 있게 해주는 LocalSessionFactoryBean이라는 클래스를 제공한다.

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2023.png)

![image.png](9%EC%9E%A5%20%EC%95%A0%ED%94%8C%EB%A6%AC%EC%BC%80%EC%9D%B4%EC%85%98%20%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/image%2024.png)

이처럼 스프링 외의 기술을 접목할 때는 가장 먼저 스프링의 빈으로 등록해서 DI방식을 통해 사용 가능한지 살펴봐야 한다. 만약 빈으로 등록해서 바로 사용할 수 있는 구조로 핵심 API나 클래스가 만들어져 있지 않은 경우라면, 위의 예처럼 스프링 빈으로 등록돼서 사용하기에 적합하도록 만들어주는 팩토리 빈을 도입해야 한다.

- 둘째, 스프링의 서비스 추상화가 적용됐다.

이미 트랜잭션이나 OXM 등의 예에서 다양한 오픈소스 프레임워크 또는 표준 기술에 대한 스프링의 서비스 추상화 기술을 살펴봤다. 첫번째는 위처럼 사용할 기술을 스프링의 빈으로 등록하고 설정 가능하도록 지원

서비스 추상화를 적용하는 경우는 이보다 한 발 더 나아가서 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해준다.

자바의 표준 기술이란 JCP를 통해 제정된 표준 스펙일 뿐이다. 다양한 벤더와 프로젝트 그룹이 이 스펙을 따라서 실제 구현을 만든다.

이와 비슷한 원리를 다양한 비표준 기술과 영역에 확장해서 적용한 것이 바로 스프링의 서비스 추상화라고 볼 수 있따.

상세한 스펙을 따라서 엄밀하게 적용되는 표준과는 다르지만, 개발자에게는 표준 기술을 사용하듯이 일관된 방법으로 코드를 작성하게 해준다는 것은 중요한 의미가 있다. 스프링이 제공하는 서비스 추상화가 표준 기술 스펙과는 다르지만, 개발자에게 표준 기술을 사용하듯이 일관된 방법으로 코드를 작성하게 해준다는 것은 중요한 의미가 있다.

스프링이 제공하는 서비스 추상화가 표준 기술 스펙과 다른 것은, 서비스 추상화는 이미 존재하는 다양한 기술의 공통점을 분석해서 추상화를 했다는 점이다. 따라서 추상 서비스 인터페이스를 구현해서 각 기술과 연동하게 해주는 어댑터 클래스가 필요하다.

- 셋째, 스프링이 지지하는 프로그래밍 모델을 적용했다.

스프링이 지지하는 프로그래밍 모델이 적용된 대표적인 예는 스프링의 데이터 액세스 기술에 대한 일관된 예외 적용이다. 스프링의 데이터 액세스 지원 기능을 사용하면 데이터 액세스 기술의 종류에 상관없이 일관된 예외 계층구조를 따라서 예외거 던져진다. 이를 통해 서비스 계층의 비즈니스로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어준다.

- 넷째, 템플릿/콜백이 지원된다.

스프링은 JDBC, JMS, JCA를 비롯한 20여 가지 기술을 지원하는 템플릿/콜백을 제공한다. 이런 기술은 그대로 사용하면 등장하는 판에 박힌 코드 때문에 전체 코드가 지저분해지고 이해하기 힘들고 추상화하기도 어려운 구조가 돼버린다. 스프링은 이런 기술을 간편하게 사용할 수 있도록 템플릿/콜백 기능을 제공한다. 대부분의 템플릿 클래스는 빈으로 등록해서 필요한 빈에서 DI 받아 사용할 수 있다.

스프링이 어떤 기술을 지원한다는 건, 결국 스프링이 지지하는 개발철학과 프로그래밍 모델을 따르면서 해당 기술을 사용할 수 있다는 의미다.

→ 물론 이런 방법을 따르지 않고도 스프링에서 여타 프레임워크를 사용하거나 라이브러리를 이용할 수는 있다. 그 대신 스프링의 장점을 포기해야 하고, 일관된 구조의 유연하고 확장 가능한 코드를 만들기가 힘들 수 있다.

스프링은 세상에 나와 있는 모든 기술과 프레임워크를 지원하진 않는다.

스프링에 새로운 기술을 연동하려면 이 책에서 설명했던 스프링의 프로그래밍 모델과 지지하는 개발철학을 따르면서 앞에서 설명한 네 가지 방법을 이용하면 된다.

스프링이 직접 지원 기능을 제공해주지 않으면 무엇인가 시도해볼 생각도 없이 스프링 이전의 방식대로 코드를 만들어서 외부 기술을 사용하는 건 부끄러운 일이다. 스프링을 사용하려면 스프링의 프로그래밍 모델과 그에 담긴 개발 철학을 따르는 일관된 코드를 만드는 데 많은 관심을 기울여야 한다.