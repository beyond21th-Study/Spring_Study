# 아키텍쳐

어떤 경계 안에 있는 내부 구성 요소들이 어떤 책임을 갖고 있고, 어떤 방식으로 서로 관계를 맺고 동작하는 지를 규정하는 것.

## 계층형 아키텍쳐

성격이 다른 모듈이 강하게 결합되어 한 데 모여 있는 경우 변경이 일어날 때 그와 상관이 없는 요소에도 영향을 미침.

그로 인해 불필요한 부분까지 변경 발생 → 작업이 더뎌지고 오류 발생 가능성 증대

따라서 인터페이스와 같은 유연한 경계를 만들어두고 분리하거나 모아주는 작업 필요.

### 아키텍쳐와 SoC

지금까지는 오브젝트 레벨에서만 DI를 기반으로 분리의 문제에 대해 생각해보았지만, 아키텍쳐 레벨처럼 더 큰 단위에서도 동일하게 적용 가능.

오브젝트를 하나의 모듈 단위로 가정.

때로는 축소나 확장도 가능.

애플리케이션을 구성하는 오브젝트들을 비슷한 성격과 책임을 가진 것들끼리 묶을 수 있음.

그리고 이렇게 애플리케이션의 오브젝트들은 다시 유사한 성격을 띤 그룹으로 나뉠 수 있음.

왜 이렇게 분리하거나 모아야 할까?

성격과 책임이 분명하게 다른 코드들이 한 곳에 모여 있는 경우 많은 문제가 발생함.

가독성이 떨어지고, 변경이나 확장이 어려움.

그래서 성격이 다른 것은 아키텍처 레벨에서 분리해주는 것이 좋음.

이렇게 분리된 오브젝트는 독자적으로 개발과 테스트가 가능.

구현 방법이나 세부 로직은 서로 영향을 주지 않고 변경될 수 있을 만큼 유연해짐.

이렇게 책임과 성격이 다른 것을 크게 그룹으로 만들어 분리해두는 것을 아키텍처 차원에서는 ‘계층형 아키텍처’라고 함.(또는 멀티 티어 아키텍처)

보통 웹 기반의 엔터프라이즈 애플리케이션은 일반적으로 세 개의 계층을 가진다고 하여 3계층 어플리케이션이라고 불림.

3계층으로 나누는 것이 필수는 아니지만 전형적인 웹 엔터프라이즈 애플리케이션은 책임과 성격을 기반으로 3계층의 논리적인 분류가 가능.

### 3계층 아키텍처와 수직 계층

3계층 아키텍처는 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할의 데이터 액세스 계층, 비즈니스 로직을 담고 있는 서비스 계층, 주로 웹 기반의 UI를 만들어내고 흐름을 관리하는 프레젠테이션 계층으로 구분.

<img width="709" height="189" alt="image" src="https://github.com/user-attachments/assets/d05070f6-c7ec-4ccd-8814-724e6eecd03a" />

- 데이터 액세스 계층

DAO라고도 불림.

또한 DB 외에도 ERP, 레거시 시스템, 메인 프레임 등에 접근하는 역할을 하기에 EIS(Enterprise Information System)계층이라고도 불림.

하지만 대부분 장기적인 데이터 저장을 목적으로 하는 DB 이용이 주된 책임.

또한 외부 시스템을 호출하여 서비스를 이용하는 것은 기반(Infrastructure) 계층으로 따로 분류.

<img width="694" height="220" alt="image" src="https://github.com/user-attachments/assets/008c1679-9271-4f76-a066-12b670a13d92" />

사용 기술에 따라 다시 세분화된 계층으로 구분 가능.

세분화하는 기준이 추상화 수준에 따른 구분이기 때문에 수직적인 계층이라고도 칭함.

JdbcTemplate이 추상화를 위한 계층으로 사용되어 로우 레벨 기반 계층에 존재하는 JDBC와 드라이버, 스프링의 트랜잭션 추상화 서비스의 동기화 기능을 간접적으로 이용하게 만든다는 특징이 있음.

<img width="575" height="228" alt="image" src="https://github.com/user-attachments/assets/eeb9dca9-54ee-4433-b68f-742bbb2ce90d" />

새로운 추상 계층 도입으로 하위 계층의 종류가 다른 서비스를 일관된 방식으로 접근 가능하도록 하는 구조.

만일 추상 계층을 새로 추가하는 것이 부담스럽거나 유연하게 하위 계층의 API를 활용할 필요가 있다면, 공통적인 기능을 분리해서 유틸리티나 헬퍼 메소드 또는 오브젝트로 제공해주는 것도 좋은 방법.

- 서비스 계층

서비스 계층은 DAO 계층을 호출하고 이를 활용하여 만들어짐.

POJO로 만든다면 객체 지향적인 설계 기법이 적용된 코드를 통해 비즈니스 로직의 핵심을 잘 담아내고, 이를 쉽게 테스트하고 유연하게 확장 가능.

아키텍처를 설계하기에 따라서 반드시 서비스 계층을 통해 사용되도록 제한 가능.

서비스 계층은 특별한 경우가 아니라면 추상화 수직 계층 구조 필요 x.

why?

기술 API를 직접 다루는 코드가 아니기 때문에 기술에 일관된 방식으로 접근을 돕는 추상화가 필요하지 않기 때문.

<img width="677" height="239" alt="image" src="https://github.com/user-attachments/assets/3cc2988a-1646-4166-964a-6cc755d25ba3" />

서비스 계층과 기반 서비스 계층, DAO 계층의 관계를 나타낸 것.

일반적으로 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출해서 이용하지만 반대로 서비스 계층이 필요에 따라 기반 서비스 계층의 API를 호출하여 이용.(ex. 스케줄러)

원칙적으로 서비스 계층 코드가 기반 서비스 계층의 구현에 종속되면 안됨.

서비스 계층의 코드는 추상화된 기반 서비스 인터페이스를 통해서만 접근하도록 만들어서 특정 구현과 기술에 대한 종속성 제거 필요.

- 프레젠테이션 계층

사용자와 애플리케이션 사이에서 요청과 응답을 번역하는 계층.

HTTP 요청을 받아 내부에서 사용할 수 있는 값으로 변환.

요청 값의 형식이 올바른 지만 검증.

실제 업무 처리는 하지 않고 서비스 계층에 위임.

why?

웹 기술에 종속된 계층이기 때문.

실제 업무를 처리하면 UI나 API가 변경될 때마다 핵심 로직 수정 필요 → 재사용 불가

서비스 처리 결과를 응답 형태로 바꾸어 전달.

즉, 요청과 응답을 이어주는 통로 역할만 함.

### 계층형 아키텍처 설계의 원칙

각 계층은 응집도가 높으면서 다른 계층과는 낮은 결합도를 유지.

각 계층은 자신의 책임에만 충실해야 하며, 다른 계층의 역할이나 기술 침범 x.

데이터 액세스 계층에 비즈니스 로직이나 웹 처리 로직이 들어가면 구조가 무너짐.

계층 간 호출은 반드시 인터페이스를 통해서 이루어져야 하고, 인터페이스는 특정 계층 기술 노출 X.

계층 간 데이터 전달은 기술과 무관한 단순한 도메인 오브젝트로 해야 함.

예외 역시 구현 기술에 종속되지 않는 추상적 런타임 예외로 처리하는 것이 바람직.

프레젠테이션 계층의 객체를 서비스 계층으로 직접 넘기면 안됨.

why?

재사용성과 테스트 용이성이 크게 떨어지기 때문.

인터페이스는 신중히 설계해야 하며, 꼭 필요한 메소드만 노출.

DI를 사용할 때도 계층 경계를 무너뜨리거나 중간 계층을 건너뛰는 의존은 x

## 애플리케이션 정보 아키텍처

엔터프라이즈 애플리케이션은 많은 요청을 빠르게 처리해야 하므로 서버에 상태를 오래 유지하지 않음.

대신 주요 상태 정보는 DB나 백엔드 시스템에 저장되고, 요청 간 필요한 임시 상태만 클라이언트나 세션에 잠시 보관.

이처럼 애플리케이션을 오가는 정보를 어떻게 다룰 것인지는 아키텍처를 결정하는 중요한 기준이 됨.

엔터프라이즈 애플리케이션의 정보 처리 방식은 크게 데이터를 중심으로 다루는 방식과 오브젝트 중심으로 다루는 방식으로 나뉨.

데이터 중심 아키텍처는 정보를 의미 있는 객체가 아닌 단순한 값의 집합으로 취급.

DB나 백엔드에서 가져온 결과를 맵이나 단순 객체에 담아 로직을 처리하고 그대로 화면에 전달.

이 구조에서는 비즈니스 로직이 SQL이나 저장 프로시저 등 DB 쪽에 많이 위치하는 경우가 많음.

또 일부 로직은 서비스 계층에 흩어져 있거나, 가공 없이 프레젠테이션 계층까지 전달되기도 함.

결과적으로 데이터 중심 아키텍처는 DB 중심 구조와 서비스 계층 중심 구조로 다시 나뉘게 됨.

### DB/SQL 중심의 로직 구현 방식

<img width="709" height="294" alt="image" src="https://github.com/user-attachments/assets/3dd00492-5592-45e3-be13-290296b9145a" />

데이터 중심 아키텍처는 하나의 업무 트랜잭션을 기준으로 모든 계층의 코드가 함께 묶여 만들어지는 구조.

업무 단위가 정해지면 SQL, DAO, 서비스, 화면 코드가 그 업무만을 위해 1:1로 대응됨.

SQL은 화면에서 어떤 데이터를 어떤 형태로 보여줄지까지 알고 있으며, 출력 포맷에 맞게 가공됨

서비스 계층은 할 일이 거의 없고, 프레젠테이션 계층은 SQL 결과 구조에 강하게 의존.

그 결과 DB 컬럼이나 필드가 바뀌면 DAO부터 화면까지 모든 계층이 함께 수정됨.

이 구조는 개발 초기에 빠르고 익숙하며 자동화에도 유리하다는 장점이 있지만 자바는 DB와 화면을 연결하는 도구로 전락하고 객체지향의 장점은 거의 활용되지 않음

로직이 SQL과 DB에 집중될수록 테스트와 변경이 어려워지고 확장 비용이 급격히 증가.

반면 애플리케이션 서버의 객체 로직은 비용이 적고 확장·테스트가 훨씬 유리.

그래서 스프링에서는 DB 중심 구조를 그대로 유지하는 것이 바람직하지 않음.

### 거대한 서비스 계층 방식

DB에 부하가 걸리지 않도록 저장 프로시저의 사용을 자제하고 복잡한 SQL을 피하면서, 주요 로직은 서비스 계층의 코드에서 처리하도록 만드는 것.

왜 이러한 방식을 사용할까.

DB에 많은 로직을 두는 개발 방법의 단점을 피하면서 애플리케이션 코드의 비중을 높이기 위해.

구조가 단순해지고 객체 지향 개발의 장점을 살릴 기회가 증대.

DAO가 돌려준 정보를 분석, 가공하면서 비즈니스 로직을 적용하는 것은 서비스 계층 코드의 책임이 됨.

DAO와 SQL은 단순해지고, 그 중 일부는 여러 서비스 계층 코드에서 재사용 가능.

비즈니스 로직이 복잡해지면 서비스 계층의 코드도 매우 복잡해지고 커짐 → 하나의 메소드가 매우 거대해지는 경우 발생.

이를 여러 메소드로 분산시킨다면 메소드 크기는 상대적으로 줄지만 전체 클래스 코드의 양은 그대로.

이러 ㄴ접근 방법은 결국 거대한 서비스 계층을 만들게 됨.

why? 

데이터의 분석, 처리와 함께 비즈니스 로직의 대부분이 서비스 계층 코드에 집중되기 때문.

<img width="707" height="250" alt="image" src="https://github.com/user-attachments/assets/e5e98f34-2feb-46f4-aa7a-24ccdfe71eb8" />

거대 서비스 계층 방식의 장점은 자바 언어의 장점을 활용해 로직을 구현 가능하고 테스트도 수월하다는 것.

하지만 계층 간의 결합도는 여전히 큼.

서비스 계층은 큰 업무 트랜잭셔 ㄴ단위로 메소드가 구성되어 비슷한 로직이 여러 곳에서 중복되기 쉬움

DAO가 반환하는 데이터 포맷이 매번 달라 공통 로직을 일반화하기도 어려움.

같은 사용자 정보라도 맵, 단순 객체 등 형태가 달라 재사용이 힘들어 서비스 계층과 DAO 모두에 중복 코드가 누적됨.

초기에는 업무 단위 별로 독립 개발이 가능 해 개발 속도가 빠르지만 객체 지향적 설계를 적용하기 어렵고 코드 스타일이 개발자마다 달라짐.

유지 보수 시 변경이 어렵고 테스트가 부족하면 스파게티 코드로 전락할 위험이 큼.

결과적으로 데이터 중심 아키텍처는 결합도는 높고 응집도가 낮아 장기적인 관리와 확장이 힘듦.

## 오브젝트 중심 아키텍처

도메인 모델을 반영한 오브젝트를 만들어 계층 간 정보 전달에 사용한다는 점이 가장 큰 특징.

값을 나열하는 데이터가 아닌 의미를 가진 오브젝트를 계층 사이의 공통 언어로 사용하는 구조.

### 데이터와 오브젝트

<img width="711" height="276" alt="image" src="https://github.com/user-attachments/assets/411133ab-58f4-404a-80f6-6fb1d3f274f4" />

위와 같이 데이터 중심의 아키텍처에서는 DAO가 만드는 SQL의 결과에 모든 계층의 코드가 의존하게 됨.

<img width="706" height="549" alt="image" src="https://github.com/user-attachments/assets/925b6687-6dba-470d-bb5b-3d6bddcd2098" />

반면에 오브젝트 방식에서는 애플리케이션에서 사용되는 정보가 도메인 모델의 구조를 반영해서 만들어진 오브젝트 안에 담김.

이 구조는 일관된 형식의 도메인 정보를 담고 있어 애플리케이션 어디서든 사용 가능함.

<img width="446" height="70" alt="image" src="https://github.com/user-attachments/assets/a6fdc5be-054d-45d4-af37-657317663a3d" />

레퍼런스 변수를 통한 상호 참조가 가능하여 위와 같이 편리하게 Category 내의 Product를 가져올 수 있음.

도메인 모델을 따르는 오브젝트 구조를 만드려면 DB에서 가져온 데이터를 메인 오브젝트 구조에 맞게 변환해줘야 함.

한 번 변환되면 그 이후의 작업은 수월해짐.

프레젠테이션 계층은 어떤 DAO가 사용되었는지, 어떤 비즈니스 로직을 거쳤는지 알 필요 x.

### 도메인 오브젝트를 사용하는 코드

오브젝트 중심 방식에서의 비즈니스 로직의 구현.

<img width="710" height="272" alt="image" src="https://github.com/user-attachments/assets/69f7ff93-d4c7-4007-9ba0-af873b736c33" />

서비스 계층 어디에서든  Category의 상품 가격을 계산해야 할 때는 이 메소드를 사용 가능.

데이터 중심 방식에서는 이런 재사용 가능한 메소드 작성이 매우 어려움.

### 도메인 오브젝트 사용의 문제점

코드를 이해하기 쉽고 로직을 작성하기도 수월하다는 장점이 존재.

코드의 재사용성은 높아지고 DAO는 더 작고 효율적으로 작성 가능.

하지만 최적화된 SQL을 매번 만들어 사용하는 경우에 비해 성능 면에서 조금은 손해를 봄.

또한 어떤 비즈니스 로직에 필요한 정보가 몇 개의 필드 뿐인 경우 DAO에서 도메인 오브젝트의 모든 필드 정보를 채워 전달하는 것이 낭비.

지연된 로딩 기법을 이요하면 일단 최소한의 오브젝트 정보만 읽어두고 관계하고 있는 오브젝트가 필요한 경우에만 동적으로 DB에서 다시 읽어올 수 있음.

가장 이상적인 방법은 JPA나 JDO, 하이버네이트, TopLink와 같은 오브젝트/RDB 매핑 기술을 사용하는 것.

기본적으로 지연된 로딩 기법 등을 제공해주기 때문에 도메인 오브젝트의 생성을 최적화 가능.

### 빈약한 도메인 오브젝트 방식

도메인 오브젝트에 정보만 담겨 있고, 정보를 활용하는 아무런 기능도 갖고 있지 않은 경우.

다루는 정보의 구조가 다를 뿐 데이터 중심 아키텍처의 거대 서비스 계층 구조와 유사.

빈약한 도메인 오브젝트 방식 역시 거대 서비스 계층 방식의 일종.

<img width="706" height="287" alt="image" src="https://github.com/user-attachments/assets/692e6129-d28d-472e-acdf-abdb7d1f5e80" />

한계 역시 거대 서비스 계층 방식과 유사 → 재사용성이 떨어짐.

하지만 비즈니스 로직이 복잡하지 않다면 만들기 쉽고 3계층 구조의 특징을 잘 살려 개발 가능한 유용한 아키텍처.

### 풍성한 도메인 오브젝트 방식.

특정 도메인 오브젝트나 관련 오브젝트가 가진 정보와 깊은 관계를 가진 비즈니스 로직을 서비스 계층의 코드가 아닌 도메인 오브젝트에 넣어주고, 서비스 계층의 비즈니스 로직에서 재사용하게 만드는 방식.

<img width="708" height="375" alt="image" src="https://github.com/user-attachments/assets/e100fbd1-f6f3-453f-a778-90a82f2a9565" />

이 로직을 서비스 계층의 메소드에 따로 만드는 경우보다 응집도가 높아짐.

why? 데이터와 그것을 사용하는 기능이 한 곳에 모여 있기 때문.

<img width="646" height="245" alt="image" src="https://github.com/user-attachments/assets/1c4f1561-7cf7-4213-b968-b699210dbd77" />

다른 서비스 오브젝트의 로직을 사용하는 코드에 비해 훨씬 간결하고 객체 지향적인 구조를 띔.

도메인 오브젝트는 직접 데이터 액세스 계층이나 기반 계층 또는 다른 서비스 계층의 오브젝트에 접근할 수 없기 때문에 서비스 계층이 필요.

왜 도메인 오브젝트는 DAO 오브젝트를 DI 받을 수 없을까?

빈이 아니기 때문.

<img width="605" height="309" alt="image" src="https://github.com/user-attachments/assets/b9aa7289-9bef-4be4-9b3b-78a652535e0b" />

풍성한 도메인 오브젝트 방식은 빈약한 도메인 오브젝트 방식보다 서비스 계층의 코드가 간결하고 비즈니스 로직 코드를 이해하기도 쉬움.

### 도메인 계층 방식

도메인 오브젝트에 담을 수 잇는 비즈니스 로직은 데이터 액세스 계층에서 가져온 내부 데이터를 분석하거나, 조건에 따라 오브젝트 정보를 변경, 생성하는 정도.

변경된 정보를 다시 반영시키려면 서비스 계층 오브젝트의 부가적인 작업 필요.

도메인 계층의 역할과 비중을 극대화시키기 위해 등장한 것이 바로 도메인 오브젝트를 계층과 같은 레벨로 격상시키는 도메인 계층 방식.

도메인 오브젝트들이 하나의 독립적인 계층을 이루어 서비스 계층과 데이터 액세스 계층 사이에 존재하게 하는 것.

이 계층의 특징은 두 가지가 있음.

첫째. 도메인에 종속적인 비즈니스 로직의 처리가 도메인 계층의 오브젝트 안에서 진행된다는 점.

둘째. 도메인 오브젝트가 기존 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다는 것.

도메인 오브젝트는 빈이 아니기에 간단한 추가 설정 필요.

AspectJ AOP를 사용하여 스프링 빈이 아닌 일반 오브젝트에도 AOP 부가 기능을 적용 가능.

이 방법을 이용하면 도메인 오브젝트가 만들어질 때 스프링의 빈 오브젝트를 DI 받을 수 있어 도메인 오브젝트가 데이터 액세스 계층이나 기반 계층의 오브젝트를 이용 가능하게 함.

도메인 오브젝트가 독립적인 계층으로 만들려고 할 때  고려해야 할 중요한 사항이 존재.

도메인 오브젝트가 도메인 계층을 벗어나서도 사용되게 할지를 결정해야 함.

우선 여전히 모든 계층에서 도메인 오브젝트를 사용하는 경우 손쉽고 편하지만 주의하지 않으면 심각한 혼란을 초래.

오브젝트를 넘겨받은 이상 그것을 사용하는 데 제약이 없어 함부로 조작하거나 기능을 실행해버릴 위험 존재.

이를 방지하기 위해 철저한 개발 가이드 라인을 작성하고 이를 강력하게 적용해야 함.

하지만 이런 규정을 어기는 경우가 존재할 수 있기 때문에 코딩 정책의 적용을 분석 가능한 툴을 사용하여 검증하거나 AspectJ의 정책/표준 강제화 기능을 사용하면 됨.

이번에는 도메인 오브젝트는 도메인 계층을 벗어나지 못하게 하는 경우.

이 경우 도메인 계층 밖으로 전달하려거든 별도로 준비된 정보 전달용 오브젝트에 도메인 오브젝트의 내용을 복사하여 넘겨주어야 함.

이런 오브젝트를 DTO라고 부름.

상태의 변화를 허용하지 않고 읽기 전용으로 만들어지기도 함.

DTO는 기능을 갖지 않아 안전하고, 외부 계층의 코드로부터 도메인 오브젝트를 보호해줌.

반면 오브젝트를 추가로 만들거나 매번 변환해주어야 하는 번거로움 존재.

<img width="618" height="364" alt="image" src="https://github.com/user-attachments/assets/f2541943-691b-431f-8926-b25502b22672" />

기존 3계층의 경우 싱글톤으로 계속 존재하는 다른 계층의 오브젝트와 달리, 도메인 계층의 오브젝트는 매우 짧은 시간 동안만 존재했다가 사라지는 것을 반복.

생명 주기가 짧은 이유는 사용자 별 요청에 대해 독립적인 상태를 유지하고 있어야 하기 때문.

그리고 상태 정보를 당고 있기 때문에 여러 스레드가 공유하는 싱글톤이 될 수 없음.

제약과 불편이 많음에도 이 방식을 택해야 하는 경우는 매우 복잡하고 변경이 잦은 도메인을 가졌을 경우.

복잡한 도메인의 구조와 로직을 초대한 도메인 계층의 오브젝트에 반영하고, 도메인 모델과 설계에 변경이 발생했을 때 도메인 계층의 오브젝트도 빠르게 대응해서 변경해주기 위해서.

반면에 복잡하지 않은 애플리케이션이라면 이런 방식을 선택하는 것 자체가 부담이 될 수 있음.

## 스프링 애플리케이션을 위한 아키텍처 설계

### 계층형 아키텍처

3계층 구조는 스프링 기반 엔터 프라이즈 애플리케이션에서 가장 일반적인 구조.

이는 논리적/개념적 구분이고, 반드시 오브젝트가 계층 별로 완전히 분리되어야 한다는 뜻은 아님.

비즈니스 로직이 단순한 경우 서비스 계층과 데이터 액세스 계층을 통합 가능.

CRUD 중심의 단순한 애플리케이션이라면 DAO에 간단한 로직과 트랜잭션 경계를 두는 것도 가능.

반대로 프레젠테이션 계층과 서비스 계층을 통합하는 방식도 이론적으로는 가능.

하지만 이 경우 스프링 AOP 기반의 트랜잭션 설정이 어려워 권장되지 않음.

그래서 3계층을 단순화한다면 논리적으로 비즈니스 로직과 데이터 접근 로직의 경계를 명확히 유지하면서 서비스 계층과 데이터 액세스 계층을 통합하는 편이 나음.

프레젠테이션 계층은 보통 Spring MVC 기반으로 구현.

스프링은 MVC의 컨트롤러 역할을 다시 세분화할 수 있도록 설계되어 있음.

또한 프레젠테이션 계층은 클라이언트로 확장되는 SOFEA구조로 발전하기도 함.

<img width="580" height="247" alt="image" src="https://github.com/user-attachments/assets/3ee191b9-e766-4129-b616-7bd1782cd30e" />

### 상태 관리와 빈 스코프

엔터프라이즈 애플리케이션은 특정 사용자가 독점해서 배타적으로 사용되지 않음.

그래서 서버 기반의 애플리케이션은 원래 지속적으로 유지되는 상태를 갖지 않음.

하지만 어떤 식으로든 애플리케이션의 상태와 장시간 진행되는 작업 정보는 유지되어야 함.

상태를 저장, 유지하는 데 어떤 방식을 사용할지 결정하는 일은 매우 중요.

스프링에서는 기본적으로 상태가 유지되지 않는 빈과 오브젝트를 사용하는 것을 권장.

why? 웹의 생리에 가장 잘 들어맞고 개발하기 쉽기 때문. 또한 서버를 여러 대로 확장하기 용이.

### 서드 파티 프레임워크, 라이브러리 적용

- 해당 기술을 스프링의 DI 패턴을 따라 사용 가능

프레임워크나 라이브러리의 핵심 클래스를 빈으로 등록 가능하게 지원해주는 것.

코드를 이용해 초기화해야만 사용할 수 있는 기능을 빈으로 등록하는 것만으로 바로 사용 가능.

<img width="613" height="525" alt="image" src="https://github.com/user-attachments/assets/24a86076-26c3-4bc9-b905-e18b421e622d" />

<img width="614" height="177" alt="image" src="https://github.com/user-attachments/assets/9bc7e3d5-da9d-4e17-8b8b-6c345cf4e0a2" />

스프링 내의 하이버네이트의 SessionFactory를 스프링이 제공하는 빈.

- 스프링의 서비스 추상화 적용

서비스 추상화를 적용하여 비슷한 기능을 제공하는 기술에 대한 일관된 접근 방법을 정의해줌.

스프링이 제공하는 서비스 추상화가 표준 기술 스펙과 다른 것은 이미 존재하는 다양한 기술의 공통점을 분석해서 추상화를 했다는 점.

따라서 추상 서비스 인터페이스를 구현하여 각 기술과 연동을 도와주는 어댑터 클래스 피룡.

- 스프링이 지지하는 프로그래밍 모델을 적용

스프링의 데이터 액세스 기술에 대한 일관된 예외적용이 가장 대표적인 예.

불필요하게 예외를 처리하는 코드를 피하도록 런타임 위주의 예외를 사용.

이를 통해 서비스 계츠으이 비즈니스 로직을 담은 코드가 데이터 액세스 계층의 기술에 종속되지 않도록 만들어줌

- 템플릿/콜백이 지원됨

템플릿과 콜백 패턴을 사용하여 지저분하고 이해가 어렵고 추상화하기도 힘든 코드를 간결하게 만들어줄 수 있음.
