[ week9 Spring Study, AOP ]

* AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반 기술이다.
* Spring에 적용된 가장 인기 있는 AOP의 적용 대상은 바로 선언적 트랜잭션 기능이다.

[ 트랜잭션 코드의 분리 ]

- 서비스 추상화 기법을 적용해 트랜잭션 기술에 독립적으로 만들어줬고, 메일 발송 기술과 환경에도 종속적이지 않은 깔끔한 코드로 다듬어 왔지만 트랜잭션 경계설정을 위해 넣은 코드 때문에 찜찜한 구성이 있다.

[ 메소드 분리 ]
￼
    * 얼핏 보면 트랜잭션 경계설정 코드와 비즈니스로 로직 코드가 복잡하게 얽혀 있는 듯 보이지만, 두가지 종류의 코드가 구분되어 있음을 알 수 있다.
    * 위의 코드의 특징은 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고받는 정보가 없다는 점이다.
    * 비즈니스 로직 코드에서 직접 DB를 사용하지 않기 때문에 트랜잭션 준비 과정에서 만들어진 DB 커넥션 정보 등을 직접 참조할 필요가 없기 때문.
    * 다만, 비즈니스 로직을 담당하는 코드가 트랜잭션의 시작과 종료 작업 사잉에 수행되어야 한다는 사항만 지켜내면 된다.




￼
    * 위의 코드는 두 개의 메소드로 분리해본 것이다. 한결 깔끔해졌다.
    * 독립적이므로 이해하기도 수정하기도 실수로 트랜잭션 코드를 건드릴 염려도 없어졌다.



[ DI를 이용한 클래스의 분리 ]
    * 하지만 여전히 트랜잭션을 담당하는 코드가 UserService안에 있다.
    * 안보이게 하고싶다. -> 트랜잭션 코드를 클래스 밖으로 뽑아내자!


{ DI 적용을 이용한 트랜잭션 분리 }
    * 실전에서는 다른 클래스나 모듈에서 이 UserService를 호출해 사용할 것이다. 하지만 현재 클래스로 되어 있으니 다른 코드에서 사용한다면 UserService 클래스를 직접 참조하게 된다. 트랜잭션 기능과 분리하고 밖으로 빼면 트랙잭션 기능이 빠진 UserService를 사용할 것이다.
    * 구체적인 구현 클래스를 직접 참조하는 경우의 전형적인 단점이다.

    * 직접 사용이 문제야? 그럼 간접적으로 사용해!
    * ￼
    * 위의 그림처럼 직접 연결은 관계가 강한 결합도로 고정되어있어 그 사이에 비집고 다른 무언가를 추가하기 힘들다.
    * 그래서 UserService를 인터페이스로 만들고 기존 코드는 인터페이스의 구현 클래스로 만들어서 넣는다. -> 클라이언트와 결합이 약해지고 직접 구현 클래스에 의존하고 있지 않아서 유연한 확장 가능!




￼
    * 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임시 DI를 통해 적용하는 방법을 쓰는 이유는? 일반적으로 구현 클래스를 바꿔가면서 사용하기 위해서다.



    * 현재 클라이언트가 UserService의 기능을 제대로 이용하려면 트랜잭션이 적용되어야 한다.
    * 아래 그림같은 구조를 생각해 볼 수 있음.
￼
    * UserServiceTx 클래스는 사용자 로직을 담고 있는 구현클래스를 대신하기 위해 만든게 아니라 트랜잭션의 경계설정이라는 책임을 맡고 있다.
    * 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업은 위임하는 것이다.




{ UserService 인터페이스 도입 }
    * 현재 구현한 사용자 관리 로직의 메소드는 add()와 upgradeLevels() 두 개 뿐이다.
￼
    * 기존 코드는 유지하되, 트랜잭션과 관련된 코드는 독립시키기로했으니 제거한다.
    * 앞에서 분리했던 upgradeLevelsInternal()로 분리했던 코드는 다시 원래대로 upgradeLevels()에 넣는다.
    * 아래 그림은 정리한 UserServiceImpl이다.
    * ￼
    * UserDao라는 인터페이스를 이용하고, User라는 도메인 정보를 가진 비즈니스 로직에만 충실한 깔끔한 코드가 되었다.



{ 분리된 트랜잭션 기능 }
    * 비즈니스 트랜잭션 처리를 담은 UserServiceTx는 기본적으로 UserService를 구현한다. 비즈니스 로직 관여 X, 인터페이스를 구현한 다른 오브젝트에게 작업을 위임만 할 뿐.
￼




    * UserServiceTx에 트랜잭션의 경계설정이라는 부작적인 작업을 부여해보면 구체적인 기술은 알지 못하지만 transactionManager라는 이름의 빈으로 등록된 트랜잭션 매니저를 받아뒀다가 트랜잭션 안에서 동작하도록 만들어줘야하는 메소드 호출의 전과 후에 필요한 트랜잭션 경계설정 API를 사용해주면 된다.
￼
    * 이제 upgradeLevels()는 UserService에서 트랜잭션 처리 메소드와 비즈니스 로직 메소드를 분리했을 때 트랜잭션을 담당한 메소드와 거의 한 메소드가 되었고, 추상화된 트랜잭션 구현 오브젝트를 DI 받을 수 있도록 PlatformTransactionManager 타입의 프로퍼티도 추가됐다.




{ 트랜잭션 적용을 위한 DI 설정 }
    * 클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용되서 트랜잭션에 관련된 작업을 진행해주고, 실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출되서 비즈니스 로직에 관련된 작업을 수행하도록 만든다. -> 아래 그림.
￼





    * 기존의 userService 빈이 의존하고 있던 tranactionManager는 UserServiceTx의 빈이, userDao와 mailSender는 UserServiceImpl 빈이 각각 의존하도록 프로퍼티 정보를 분리한다. 
￼
        * 클라이언트는 UserService라는 대표적인 빈 아이디는 UserServiceTx 클래스로 정의된 빈에게 부여해준다. 
        * userService 빈은 UserServiceImpl 클래스로 정의되는, 아이디가 userServiceImpl인 빈을 DI 하게 만든다.





{ 트랜잭션 분리에 따른 테스트 수정 }
* UserService라는 클래스가 인터페이스와 두 개의 클래스로 분리된 만큼 테스트에서도 적합한 타입과 빈을 사용하도록 변경해야 한다.
* 기존에는 @Autowired를 사용했지만 기본적으로 타입이 일치하는 빈을 찾아주기 때문에 문제가 발생한다.
* UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문. 따라서 UserService의 빈만 가져온다.
* 하지만 MailSender를 DI할 필요가 있기 때문에 UserServiceImpl 의 빈도 가져와야한다.
* 그래서 클래스 타입의 변수를 선언하고 @Autowired를 지정해서 해당 클래스로 만들어진 빈을 주입한다. -> 그래야 MockMailSender를 설정해주기위한 수정자 메소드에 접근할 수 있기 때문.
* MailSender의 목 오브젝트를 설정해주는 건 이제 UserService 인터페이스를 통해선 불가능하기 때문에 아래 그림처럼 userServiceImpl 빈에 해줘야한다.
￼





* upgradeAllOrNothing()테스트는 수정할 부분이 있다. 이 테스트는 로직 테스트 목적이 아니라, 트랜잭션 기술이 바르게 적용됐는지 확인하기위함이다.
* 그래서 TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI 시킨 후 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야한다.
￼
* 이제 UserServiceImpl 클래스를 상속하도록 바꿔주면된다.
￼



{ 트랜잭션 경계설정 코드 분리의 장점 }
* 1.  비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다. 트랜잭션의 적용이 필요한지도 신경쓰지 않아도 된다.

* 2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다 



[ 고립된 단위 테스트 ] 
* 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트 하는 것이다. -> 작은 단위의 테스트가 좋은 이유 : 테스트 실패시 오류 찾기 좋음.


{ 복잡한 의존관계 속의 테스트 }
* 위에 만든 UserService는 간단한 기능만 갖고 있다. 그럼에도 구현 클래스들이 동작하려면 세 가지 타입의 의존 오브젝트가 필요하다.
* 아래 그림은 분리하기 전의 테스트가 동작하는 모습이다.
￼
* 사용자 정보를 관리하는 비즈니스 로직의 구현 코드인데. 코드가 바르면 성공, 아니면 실패이다. -> 테스트의 단위는 Userservice클래스이다.
* 위의 그림과 같이 세 가지 의존관계를 갖는 오브젝트들이 테스트가 진행되는 동안 같이 실행된다.
* UserService만 테스트 하는 것이 아니라 그 뒤의 더 많은 오브젝트와 환경, 서비스, 서버, 심지어 네트워크까지 함께 테스트 하는 것이다.




{ 테스트 대상 오브젝트 고립시키기 }
* 그래서 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다.
* 테스트 대역이 테스트 검증에도 참여할 수 있도록, 특별히 만든 MockMailSender라는 목을 사용하는 것이다.


- 테스트를 위한 UserServiceImpl
    * 트랜잭션 코드를 독립시켰기 때문에 사용자 관리 로직을 담은 UserServiceImpl은 의존하지 않는다.
    * 두개의 목 오브젝트만 의존하는 완벽하게 고립된 테스트 대상을 만들 수 있다.
￼
    * UserDao는 단지 테스트 대상의 코드가 정상적으로 수행되도록 도와주는 스텁이 아니라, 부가적인 검증 기능까지 가진 목 오브젝트로 만듦.
    * Why? 고립된 환경에서 동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문.

    * upgradeLevels()메소드는 리턴 값이 없는 void형이다. 그래서 메소드 실행하고 그 결과를 받아서 검증하는 것은 아예 불가능하다.
        * 그럼 어떻게해? 
        * 테스트 검증의 어려움때문에
        * 행위 검증으로 전환
            * 데이터가 DB에 잘 저장되었는지 확인하는 ‘ 상태 검증 ‘ 대신 ** 올바른 메서드가 호출되었는지 확인하는 ‘ 행위 검증 ‘. *이 필요함. userDao의 update() 메서드가 호출되었다면, 실제 운영 환경에서도 DB에 결과가 반영될 것이라고 믿을 수 있기 때문.
            * 목 오브젝트의 필요성 : 목 옵젝은 메서드 호출 정보를 저장해 두었다가, 테스트 마지막 단계에서 update 메소드가 호출되었는가? 로 검증함.



- 고립된 단위 테스트 활용
￼
    * 고립된 단위 테스트 방법은 다섯 단계의 작업으로 구성됨.
        * 1. 테스트 실행 중 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다.
        * 2. 메일 발송 여부 확인을 위해 MailSender 목 오브젝트를 DI 해준다.
        * 3. 실제 테스트 대상인 userService의 메소드를 실행.
        * 4. 결과가 DB 반영됐는지 확인하기 위해 UserDao를 이용해 DB에서 데이터를 가져와 결과 확인.
        * 5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인.



- UserDao 목 오브젝트               418page
* 목 오브젝트는 기본적으로 스텁과 같은 방식으로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다.
    * upgradeLevels()메소드가 실행되는 중에 UserDao와 어떤 정보를 주고 받는지 입출력 내역을 확인할 필요 있음.
    * 아래 그림에서 보듯이 UserServiceImpl의 코드는 upgradeLevels()메소드와 그 사용 메소드에서 UserDao를 사용하는 두가지 경우이다.
￼
￼
    * 중요한 점은 업그레이드를 통해 레벨이 변경된 사용자는 DB에 반영되도록 UserDao의 update()에 전달되어야한다.
    * 그래서 update()에 대해서는 아래 그림처럼 목 오브젝트로서 동작하는 UserDao의 대역이 필요하다. 
￼
￼
    * MockDao지만 UserDao 구현 클래스를 대신해야 하니 UserDao 인터페이스를 구현해야 한다. -> 사용X도 만들어야되서 하지만 부담돼ㅜㅜ
    * 그래서 UnsupportedOperationException을 던지도록 예외를 만들어두고 빈채로 던지거나 null을 리턴해도 된다.




￼
    * 테스트 대역 오브젝트로 완전히 고립된 테스트를 진행하기 때문에 스프링 컨테이너에서 빈을 가져올 필요가 X.
    * 기존에는 DB에서 모든 사용자의 정보를 다시 가져와 일일이 확인해야 했지만 이제 그럴 필요가 없음. 
    * MockUserDao에서는 update() 메소드가 호출될 때마다 저장해둔 사용자 목록을 반환하면 되기 때문.






- 테스트 수행 성능의 향상
* 간단한 테스트지만 이전보다 분명히 빨라졌다.
    * 테스트를 도와주는 두 개의 목 옵젝 외에 사용자 과ㅓㄴ리 로직을 검증하는데 필요하지 않은 의존 오브젝트와 서비스를 제거했기 때문.

* 테스트 수행성능 향상
* 부담 없이 자주 테스트를 돌려볼 수 있음.
* 목 옵젝과 같은 수고가 있지만 보상은 충분함. 강추!






{ 단위 테스트와 통합 테스트 }
* 정하기 나름.
* 중요한건 하나의 단위에 초점을 맞춘 테스트.
* 대부분 의존 옵젝이나 외부의 리소스를 사용X, 고립시켜서 테스트 하는 것을 ‘단위 테스트’ 라함.
* 두개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록, 또는 외부 DB나 파일 서비스 등 리소스 가 참여하는 걸 ‘통합 테스트라’ 고 부른다.


* 아래의 가이드라인은 참고하자.
￼




- 목 프레임워크
    * 단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다.
    * 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문.
    * 단위 테스트가 장점이 있고 가장 우선시해야 할 테스트 방법이지만 작성이 번거롭다는 점이 문제다. -> 특히 목 오브젝트를 만드는 일 큰 짐임ㅠ
    * BUT 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 있다.


- Mockito 프레임워크
    * 사용하기 편리하고, 코드도 직관적이라 인기 있음.
    * 목 클래스를 일일이 준비해둘 필요가 없다는 점이 특징.
    * 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트 만들 수 있음.

    * 스태틱 메소드를 호출하면 만들어짐.
    * 하지만 일단 아무런 기능이 없음.
￼


    * getAll()이 호출되었을때(when), users 리스트를 리턴하라는 선언.
￼
￼
    * 그리고 메소드가 2번 호출되었는지 검증코드를 넣어주면된다.



    * Mockito는 네 단계를 거쳐서 사용하면 된다. 두 번째와 네 번째는 각각 필요할 경우에만 사용할 수 있다.(아래 그림)
￼




￼
￼
    * UserDao의 목 오브젝트를 생성하고 getAll()이 호출됐을 때 러턴 값을 설정해준 뒤 호출됐을 때 리턴 값을 설정해준 뒤에 테스트 대상에 DI 해준다.

    * userServiceImpl 메소드가 실행되는 동안 DI 해준 목 오브젝트의 메소드가 호출되면 자동으로 호출 기록이 남겨진다.
    * getAll()처럼 미리 설정해둔 리턴 값이 있는 경우에는 그 값을 리턴해 주기도 한다.

    * 지금 깢디 나온 목 오브젝트 방식을 지원하는 프레임워크 중에서 가장 사용하기 편리하다. 처음엔 어렵지만 익숙해지면 빠른 속도로 단위 테스트를 만드는 데 강력한 도구가 될 것이다.
