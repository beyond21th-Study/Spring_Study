# AOP
- AOP : Aspect Oriented Programming, 여러 곳에 반복되는 공통 로직을 핵심 로직과 분리하는 방법
- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술
- AOP의 적용대상은 선언적 트랜잭션 기능


## 6.1 트랜잭션 코드의 분리
### 6.1.1 메소드 분리

<img width="718" height="520" alt="image" src="https://github.com/user-attachments/assets/bd27fbfc-bfbf-4006-a74a-4051c5cd7aa8" />

- 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치함
- 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고 받는 점이 특징

<img width="703" height="575" alt="image" src="https://github.com/user-attachments/assets/3cb0702e-d1fb-4994-bca4-794222008ead" />

- 사용자 레벨 업그레이드를 담당하는 비즈니스 로직 코드만 독립적인 메소드에 담겨 있음 -> 이해하기 편하고 수정하기에도 부담 없음

### 6.1.2 DI를 이용한 클래스의 분리

### DI 적용을 이용한 트랜잭션 분리

<img width="595" height="154" alt="image" src="https://github.com/user-attachments/assets/31b66b9e-650d-4dc2-aa75-bb6302d18c48" />

- UserService 클래스와 그 사용 클라이언트 간의 관계가 강한 결합도로 고정 돼 있음
  
<img width="534" height="245" alt="image" src="https://github.com/user-attachments/assets/0eb07f1a-6de8-4f32-9975-7d473eae5be5" />

- UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만들어 넣는다. -> 클라이언트와 결합이 약해지고 직접 구현 ㅋ클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.

<img width="676" height="242" alt="image" src="https://github.com/user-attachments/assets/acb435c9-4798-4427-8038-d370992a5a77" />

- 위 그림은 한 번에 두 개의 UserService 인터페이스 구현 클래스를 동시에 이용하는 방법
- UserService에는 순수하게 비즈니스 로직을 담고 있는 코드만 놔두고 트랜잭션 경계설정을 담당하는 코드를 외부로 빼내려고 한다. -> 이러면 트랜잭션이 적용 돼야함.
- UserService를 구현한 또 다른 구현 클래스를 만든다.
- 이 클래스는 사용자 관리 로직을 담고 있는 구현 클래스인 UserServiceImpl을 대신하기 위해 만든게 아니고 트랜잭션의 경계설정이라는 책임을 맡고 있다.
- 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업은 위임한다.
- 이 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계를 설정해주면 클라이언트 입장에서는 '트랜잭션이 적용된 비즈니스 로직의 구현'동작이 일어남.

### UserService 인터페이스 도입

<img width="728" height="176" alt="image" src="https://github.com/user-attachments/assets/480f1835-d192-447a-92c0-e7a3fd5324f3" />

- 클라이언트에 노출할 메도스를 담은 인터페이스 리스트.
- add(), upgradeLevels() 이 두개가 현재 구현한 사용자 관리 로직의 메소드.


<img width="750" height="450" alt="image" src="https://github.com/user-attachments/assets/ddbb9675-c534-42ca-b91c-79bac0488703" />

- UserServiceImpl은 기존 UserService클래스의 내용을 대부분 그대로 유지하면 됨.
- 코드 어디에도 기술이나 서버환경, 스프링에 관련된 코드가 보이지 않는다.
- 이 자체로만 보면 USerDao라는 인터페이스를 이용하고, User라는 도메인 정보를 가진 비즈니스 로직에만 충실한 코드임.

### 분리된 트랜잭션 기능

<img width="730" height="502" alt="image" src="https://github.com/user-attachments/assets/2a80d02d-4710-4f56-8102-cc98e116b712" />

- 비즈니스 트랜잭션 처리를 담은 UserServiceTx. 
- UserServiceTx는 기본적으로 UserService를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른 오브젝트에게 작업을 위임하게 만들면 된다
- 비즈니스 로직에 대해서는 UserServiceTx가 아무런 관여도 하지 않는다.

<img width="460" height="523" alt="image" src="https://github.com/user-attachments/assets/b95a71d3-5028-4011-96ae-c4b345f3bc15" />

- 트랜잭션을 적용하도록 만든 코드
- upgradeLevel()는 UserService에서 트랜잭션 처리 메소드와 비즈니스 로직 메소드를 분리했을 때 트랜잭션을 담당한 메소드와 거의 한 메소드가 됐다.
- 추상화된 트랜잭션 구현 오브젝트를 DI받을 수 있도록 PlatformTransactionManager타입의 프로퍼티도 추가 됐다.

### 트랜재션 적용을 위한 DI 설정

<img width="389" height="80" alt="image" src="https://github.com/user-attachments/assets/7f2c0505-4847-46b7-9f2f-3776bcce9e45" />

- 클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용돼서 트랜잭션에 관련된 작업을 진행해주고
실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.

<img width="814" height="366" alt="image" src="https://github.com/user-attachments/assets/209764a8-7464-4e13-ad56-330543d57efd" />

- 기존에 userService 빈이 의존하고 있던 transactionManager는 UserServiceTx의 빈이, userDao와 mailSender는 UserServiceImpl빈이 각각 의존하도록 프로퍼티 정보를 분리한다
- 클라이언트는 UserServiceTx빈을 호출해서 사용하도록 만들어야 한다
- 따라서 userService라는 대표적인 빈 아이디는 UserServiceTx클래스로 정의된 빈에게 부여해준다. userServiceImpl클래스로 정의되는, 아이디가 userServiceImpl인 빈을 DI하게 만든다.

### 트랜잭션 분리에 따른 테스트 수정
- 기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다. UserServic는 인터페이스로 바뀌었다.
<br> 인터페이스라고 하더라도 @Autowired로 가져오는데는 아무런 문제가 없다.
- 하지만 @Autowired는 기본적으로 타입이 일치하는 빈을 찾아주기 때문에 다른 문제가 발생하는데,
<br> 수정한 스프링의 설정파일에는 UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문이다.
- 같은 타입의 빈이 두 개라면 @Autowired를 적용한 경우 기본적으로 타입을 이용해 빈을 찾지만 타입으로 하나의 빈을 결정할 수 없는 경우네는 필드 이름이 리용해 빈을 찾는다

<img width="361" height="67" alt="image" src="https://github.com/user-attachments/assets/f2486a02-2336-431f-97d3-b33efc4c4aef" />

- 따라서 위와 같은 변수를 설정해두면 아이디가 userService인 빈이 주입될 것이다.

- 그런데 UserServiceTest는 UserServiceImpl 클래스로 정의된 빈을 하나 더 가져와야 한다.
- 일반적인 UserService 기능의 테스트에서는 UserService인터페이스르 통해 결과를 확인하는 것으로 충분하다.
- 하지만 앞 장에서 만든 MailSender 목 오브젝트를 이용한 테스트에서는 테스트에서 직접 MailSender를 Di해줘야 할 필요가 있었다
- MailSender를 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에 UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.

<img width="430" height="60" alt="image" src="https://github.com/user-attachments/assets/5ed7772d-178d-4f13-9a9b-be9de7039948" />

- 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다. 따라서 위의 사진과 같이 UserServiceImpl 클래싀 타입의 변수를 선언하고 <br> @Autowired를 지정해서 해당 클래스로 만들어진 빈을 주입받도록 한다. <br> 그래야만 MockMailSender를 설정해주기 위한 수정자 메소드에 접근할 수 있기 때문이다.

<img width="819" height="248" alt="image" src="https://github.com/user-attachments/assets/8e2a629a-342d-42cc-86a5-a2384e9ae633" />

- MailSender의 목 오브젝트를 설정해주는건 이제 UserService 인터페이스를 통해선 불가능하기 때문에 별도로 가져온 userServiceImpl빈에 해줘야 한다.

- add() 테스트 메소드는, 변경하기 전과 동일하게 동작함이 보장되므로 테스트는 그대로 둔다.

- upgradeAllOrNothing() 테스트는 테스트용 확장 클래스도 만들고 수동 DI도 적용하고 한 만큼, 바뀐 구조를 모두 반영하는 수정을 한다.

<img width="936" height="619" alt="image" src="https://github.com/user-attachments/assets/8b0fb948-8a22-40d0-966f-cf7012bbf4cb" />

- TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI시킨 후에 드랜잭션 기능가지 포함된 UserServiceTx 오브젝트에 수동 DI시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야 한다.
- 트랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스는 UserServiceImpl 클래스를 상속하도록 바꿔주면 된다.

### 트랜잭션 경계설정 코드 분리의 장점
- 1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
- 2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어 낼 수 있다.
 
## 6.2 고립된 단위 테스트 























