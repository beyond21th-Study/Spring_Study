# AOP
- AOP : Aspect Oriented Programming, 여러 곳에 반복되는 공통 로직을 핵심 로직과 분리하는 방법
- AOP는 IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기술
- AOP의 적용대상은 선언적 트랜잭션 기능


## 6.1 트랜잭션 코드의 분리
### 6.1.1 메소드 분리

<img width="718" height="520" alt="image" src="https://github.com/user-attachments/assets/bd27fbfc-bfbf-4006-a74a-4051c5cd7aa8" />

- 비즈니스 로직 코드를 사이에 두고 트랜잭션 시작과 종료를 담당하는 코드가 앞뒤에 위치함
- 트랜잭션 경계설정의 코드와 비즈니스 로직 코드 간에 서로 주고 받는 점이 특징

<img width="703" height="575" alt="image" src="https://github.com/user-attachments/assets/3cb0702e-d1fb-4994-bca4-794222008ead" />

- 사용자 레벨 업그레이드를 담당하는 비즈니스 로직 코드만 독립적인 메소드에 담겨 있음 -> 이해하기 편하고 수정하기에도 부담 없음

### 6.1.2 DI를 이용한 클래스의 분리

### DI 적용을 이용한 트랜잭션 분리

<img width="595" height="154" alt="image" src="https://github.com/user-attachments/assets/31b66b9e-650d-4dc2-aa75-bb6302d18c48" />

- UserService 클래스와 그 사용 클라이언트 간의 관계가 강한 결합도로 고정 돼 있음
  
<img width="534" height="245" alt="image" src="https://github.com/user-attachments/assets/0eb07f1a-6de8-4f32-9975-7d473eae5be5" />

- UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만들어 넣는다. -> 클라이언트와 결합이 약해지고 직접 구현 ㅋ클래스에 의존하고 있지 않기 때문에 유연한 확장이 가능해진다.

<img width="676" height="242" alt="image" src="https://github.com/user-attachments/assets/acb435c9-4798-4427-8038-d370992a5a77" />

- 위 그림은 한 번에 두 개의 UserService 인터페이스 구현 클래스를 동시에 이용하는 방법
- UserService에는 순수하게 비즈니스 로직을 담고 있는 코드만 놔두고 트랜잭션 경계설정을 담당하는 코드를 외부로 빼내려고 한다. -> 이러면 트랜잭션이 적용 돼야함.
- UserService를 구현한 또 다른 구현 클래스를 만든다.
- 이 클래스는 사용자 관리 로직을 담고 있는 구현 클래스인 UserServiceImpl을 대신하기 위해 만든게 아니고 트랜잭션의 경계설정이라는 책임을 맡고 있다.
- 스스로는 비즈니스 로직을 담고 있지 않기 때문에 또 다른 비즈니스 로직을 담고 있는 UserService의 구현 클래스에 실제적인 로직 처리 작업은 위임한다.
- 이 위임을 위한 호출 작업 이전과 이후에 적절한 트랜잭션 경계를 설정해주면 클라이언트 입장에서는 '트랜잭션이 적용된 비즈니스 로직의 구현'동작이 일어남.

### UserService 인터페이스 도입

<img width="728" height="176" alt="image" src="https://github.com/user-attachments/assets/480f1835-d192-447a-92c0-e7a3fd5324f3" />

- 클라이언트에 노출할 메도스를 담은 인터페이스 리스트.
- add(), upgradeLevels() 이 두개가 현재 구현한 사용자 관리 로직의 메소드.


<img width="750" height="450" alt="image" src="https://github.com/user-attachments/assets/ddbb9675-c534-42ca-b91c-79bac0488703" />

- UserServiceImpl은 기존 UserService클래스의 내용을 대부분 그대로 유지하면 됨.
- 코드 어디에도 기술이나 서버환경, 스프링에 관련된 코드가 보이지 않는다.
- 이 자체로만 보면 USerDao라는 인터페이스를 이용하고, User라는 도메인 정보를 가진 비즈니스 로직에만 충실한 코드임.

### 분리된 트랜잭션 기능

<img width="730" height="502" alt="image" src="https://github.com/user-attachments/assets/2a80d02d-4710-4f56-8102-cc98e116b712" />

- 비즈니스 트랜잭션 처리를 담은 UserServiceTx. 
- UserServiceTx는 기본적으로 UserService를 구현하게 만든다. 그리고 같은 인터페이스를 구현한 다른 오브젝트에게 작업을 위임하게 만들면 된다
- 비즈니스 로직에 대해서는 UserServiceTx가 아무런 관여도 하지 않는다.

<img width="460" height="523" alt="image" src="https://github.com/user-attachments/assets/b95a71d3-5028-4011-96ae-c4b345f3bc15" />

- 트랜잭션을 적용하도록 만든 코드
- upgradeLevel()는 UserService에서 트랜잭션 처리 메소드와 비즈니스 로직 메소드를 분리했을 때 트랜잭션을 담당한 메소드와 거의 한 메소드가 됐다.
- 추상화된 트랜잭션 구현 오브젝트를 DI받을 수 있도록 PlatformTransactionManager타입의 프로퍼티도 추가 됐다.

### 트랜재션 적용을 위한 DI 설정

<img width="389" height="80" alt="image" src="https://github.com/user-attachments/assets/7f2c0505-4847-46b7-9f2f-3776bcce9e45" />

- 클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용돼서 트랜잭션에 관련된 작업을 진행해주고
실제 사용자 관리 로직을 담은 오브젝트가 이후에 호출돼서 비즈니스 로직에 관련된 작업을 수행하도록 만든다.

<img width="814" height="366" alt="image" src="https://github.com/user-attachments/assets/209764a8-7464-4e13-ad56-330543d57efd" />

- 기존에 userService 빈이 의존하고 있던 transactionManager는 UserServiceTx의 빈이, userDao와 mailSender는 UserServiceImpl빈이 각각 의존하도록 프로퍼티 정보를 분리한다
- 클라이언트는 UserServiceTx빈을 호출해서 사용하도록 만들어야 한다
- 따라서 userService라는 대표적인 빈 아이디는 UserServiceTx클래스로 정의된 빈에게 부여해준다. userServiceImpl클래스로 정의되는, 아이디가 userServiceImpl인 빈을 DI하게 만든다.

### 트랜잭션 분리에 따른 테스트 수정
- 기존에는 UserService 클래스 타입의 빈을 @Autowired로 가져다가 사용했다. UserServic는 인터페이스로 바뀌었다.
<br> 인터페이스라고 하더라도 @Autowired로 가져오는데는 아무런 문제가 없다.
- 하지만 @Autowired는 기본적으로 타입이 일치하는 빈을 찾아주기 때문에 다른 문제가 발생하는데,
<br> 수정한 스프링의 설정파일에는 UserService라는 인터페이스 타입을 가진 두 개의 빈이 존재하기 때문이다.
- 같은 타입의 빈이 두 개라면 @Autowired를 적용한 경우 기본적으로 타입을 이용해 빈을 찾지만 타입으로 하나의 빈을 결정할 수 없는 경우네는 필드 이름이 리용해 빈을 찾는다

<img width="361" height="67" alt="image" src="https://github.com/user-attachments/assets/f2486a02-2336-431f-97d3-b33efc4c4aef" />

- 따라서 위와 같은 변수를 설정해두면 아이디가 userService인 빈이 주입될 것이다.

- 그런데 UserServiceTest는 UserServiceImpl 클래스로 정의된 빈을 하나 더 가져와야 한다.
- 일반적인 UserService 기능의 테스트에서는 UserService인터페이스르 통해 결과를 확인하는 것으로 충분하다.
- 하지만 앞 장에서 만든 MailSender 목 오브젝트를 이용한 테스트에서는 테스트에서 직접 MailSender를 Di해줘야 할 필요가 있었다
- MailSender를 DI 해줄 대상을 구체적으로 알고 있어야 하기 때문에 UserServiceImpl 클래스의 오브젝트를 가져올 필요가 있다.

<img width="430" height="60" alt="image" src="https://github.com/user-attachments/assets/5ed7772d-178d-4f13-9a9b-be9de7039948" />

- 목 오브젝트를 이용해 수동 DI를 적용하는 테스트라면 어떤 클래스의 오브젝트인지 분명하게 알 필요가 있다. 따라서 위의 사진과 같이 UserServiceImpl 클래싀 타입의 변수를 선언하고 <br> @Autowired를 지정해서 해당 클래스로 만들어진 빈을 주입받도록 한다. <br> 그래야만 MockMailSender를 설정해주기 위한 수정자 메소드에 접근할 수 있기 때문이다.

<img width="819" height="248" alt="image" src="https://github.com/user-attachments/assets/8e2a629a-342d-42cc-86a5-a2384e9ae633" />

- MailSender의 목 오브젝트를 설정해주는건 이제 UserService 인터페이스를 통해선 불가능하기 때문에 별도로 가져온 userServiceImpl빈에 해줘야 한다.

- add() 테스트 메소드는, 변경하기 전과 동일하게 동작함이 보장되므로 테스트는 그대로 둔다.

- upgradeAllOrNothing() 테스트는 테스트용 확장 클래스도 만들고 수동 DI도 적용하고 한 만큼, 바뀐 구조를 모두 반영하는 수정을 한다.

<img width="936" height="619" alt="image" src="https://github.com/user-attachments/assets/8b0fb948-8a22-40d0-966f-cf7012bbf4cb" />

- TestUserService 오브젝트를 UserServiceTx 오브젝트에 수동 DI시킨 후에 드랜잭션 기능가지 포함된 UserServiceTx 오브젝트에 수동 DI시킨 후에 트랜잭션 기능까지 포함된 UserServiceTx의 메소드를 호출하면서 테스트를 수행하도록 해야 한다.
- 트랜잭션 테스트용으로 특별히 정의한 TestUserService 클래스는 UserServiceImpl 클래스를 상속하도록 바꿔주면 된다.

### 트랜잭션 경계설정 코드 분리의 장점
- 1. 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경 쓰지 않아도 된다.
- 2. 비즈니스 로직에 대한 테스트를 손쉽게 만들어 낼 수 있다.
 
### 6.2 고립된 단위 테스트
- 작은 단위의 테스트가 좋은 이유는 테스트가 실패 했을 때 그 원인을 찾기 쉽기 때문이다.
- 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다

### 복잡한 의존관계 속의 테스트

<img width="629" height="257" alt="image" src="https://github.com/user-attachments/assets/1c0d23fb-7b23-41a2-9613-71be64720c40" />

- 위 그림은 UserService를 분리하기 전의 테스트가 동작하는 모습
- 문제점 : UserService는 UserDao, TransactionManager, MailSender라는 세 가지의 의존 관계를 갖고 있다. <br> 세 가지 의존관계를 갖는 오브젝트들이 테스트가 진행되는 동안에 같이 실행된다.
- JDBC를 이용해 UserDao를 구현한 UserDaoJdbc는 DataSource의 구현 클래스와 DB드라이버, <br> 그리고 DB서버까지의 네트워크 통신과 DB서버 자체 그리고 그 안에 정의된 테이블 모두 의존하고 있다.
- UserService라는 테스트 대상이 테스트 단위인 것 처럼 보이지만 사실은 그 뒤의 의존관계를 따라 등장하는 오브젝트와ㅏ 서비스, 환경 등이 모두 합쳐져 테스트 대상이 된다. 즉 이런 환경의 경우 테스트는 준비하기 힘들고, 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수도 있으며, <br> 수행 속도는 느릐고 그에 따라 테스트를 작성하고 실행하는 빈도가 계속 떨어질 것이다.


### 6.2.2 테스트 대상 오브젝트 고립시키기
- 테스트의 대상이 환경이나 외부 서버, 다른 클래스의코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있다. 
- 테스트를 의존 대상으로부터 분리해서 고립시키는 방법 -> MailSender에 적용해봤던 대로 테스트를 위한 대역을 사용한다.
  - MailSender에는 이미 DummyMailSender라는 테스트 스텁을 적용
  - 테스트 대역이 검증에도 참여할 수 있도록 MockMailSender라는 목 오브젝트 사용
 
### 테스트를 위한 UserServiceImpl 고립

<img width="467" height="182" alt="image" src="https://github.com/user-attachments/assets/cb8c24fe-120d-4ec8-b4cb-d028a519a075" />

- 테스트의 대상을 고립시킨다.
- 방법 : UserServiceImple에 대한 테스트가 진행될 때 사전에 테스트를 위해 준비된 동작만 하도록 만든 두 개의 목 오브젝트에만 의존하는, 완벽하게 고립된 테스트 대상으로 만들 수 있다.
- UserServiceTest : 테스트 코드이고, UserService가 제대로 동작하는지 검증
<br> UserServiceImpl : 진짜 테스트 대상, 검증하고 싶은 핵심 로직. 고립된 테스트 대상
 <br> MockUserDao, MockMailSender : 가짜 객채, 진짜 DB에 접근하거나 진짜 메일을 전송하는건 아님
 <br> 오른쪽 큰 박스에 나열 된 것들 :  단위 테스트에서는 절대 안 건드림
<br> UserServiceTx : 트랜잭션 처리용 프록시 클래스. 얘도 직접 테스트 대상이 아님.
- 의존 오브젝트나 외부 서비스에 의존하지 않는 고립된 테스트 방식으로 만든 UserServiceImpl은 아무리 그 기능이 수행되도 그 겨로가가 DB등을 통해서 남지 않으니까 기존의 방법으로는 작업 결과를 검증하기 힘들다.
<br> 이런 경우 테스트 대상인 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는지를 확인하는 작업이 필요하다. 왜? 테스트 중에 DB결과가 반영되지는 않았지만, UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라고 결론을 내릴수 있기 때문이다.


### 고립된 단위 테스트 활용

<img width="511" height="499" alt="image" src="https://github.com/user-attachments/assets/e7ba5442-f319-4350-af41-9b43538d409d" />

- 1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DBdp sjgsmsek. UserDao는 결국 DB를 이용해 정보를 가져오기 때문에 최후의 의존 대상인 DB에 직접 정보를 넣어줘야한다.
- 2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI 해준다.
   <br> (메일을 보낸 척만 한다. MailSender을 갈아 낄울 수 있으니까 테스트가 쉬워짐.
- 3. 실제 테스트 대상인 userService의 메소드를 실행한다.
- 4. 결과가 DB에 반영됐는지 확인하기 위해서 UserDao를 이용해 DB에서 데이터를 가져와 결과를 확인한다.
- 5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인한다.
( - 테스트 대상 실행 : 내붕ㅇ세ㅓ 등급 조건 검사하고 등급 업그레이드 하고 메일 발송 처리 하고 테스트 대상을 실행한다.
- 그리고 유저들의 등급들이 올라갔는지 여부를 확인하고
- 목 오브젝트를 이용한 결과 확인 : 메일이 두번만 보내졌는지, 등급 올라간 사람에게만 갔는지 검증 )

### UserDao 목 오브젝트

- 목 오브젝트는 기본적으로 스텁과 같은 방식으로 테스트 대상을 통해 사용될 때 필요한 기능을 지원해줘야 한다.

<img width="558" height="507" alt="image" src="https://github.com/user-attachments/assets/bd76ba2c-46ca-40ab-96c7-84be1717bb3d" />

- upgradeLevles()에서 UserDao가 쓰이는 두 지점
  - getAll() : 업그레이드 후보 사용자 목록 주세요 -> 테스트 관점에서 보면 db에서 가져올 필요가 없음
  - update() : 이 사용자는 업그레이드 대상이다 -> DB볌경이라는 부작용이 있음.
 
<img width="511" height="639" alt="image" src="https://github.com/user-attachments/assets/427b4e3f-6334-498b-9145-e079fb837949" />

- 그래서 등장한게 MockUserDao
  - getAll() :  DB에서 읽은 것처럼 행동
  - update() : 목, DB반영 안함. 대신 누가/어떤순서로/몇명이 업데이트 대상이었는지 저장.

<img width="463" height="476" alt="image" src="https://github.com/user-attachments/assets/748ff986-390c-470b-8792-b3a0320b99de" />

- 스프링 없고, @Autowired 없고, 컨테이너도 없고 수동DI한다.
  - update()가 몇번 호출 됐는지, 누가/어떤 레벨로 바뀌었는지, 메일발송이 됐는지 검증한다.
 
- 즉 DAO를 Mock으로 만들면 DB에 저장했는지 확인 할 필요가 없다.
- update()호출 기록을 통한 행위 검증을 한다.
- 비즈니스 로직은 단위 테스트로 충분히 검증이 가능하다.


### 테스트 수행 성능의 향상
- 어떻게 1밀리초도 되지 않는 짧은 시간에 나름 복잡한 비즈니스 로직을 가진 테스트가 실행될 수 있었을 까?
<br> -> UserServiceImpl와 에트스를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는 데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거한 덕분이다.
- 고립된 테스트를 하면 테스트가 다른 의존 대상에 영향을 받을 경우를 대빟 ㅐ복잡하게 준비할 필요가 없을 뿐만 아니라,
<br> 테스트 수행 성능도 크게 향상된다.

### 단위 테스트와 통합 테스트

- 단위 테스트 : upgradeLevels()테스트처럼 '테스트 대상 클래스를 목 오브젝트 ㅡㅇ의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜서 테스트 하는 것'

- 통합 테스트 : 두 개 이상의, 성격이나 계층이 다르 오브젝트가 연동하도록 만들어 테스트하거나, 또는 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트.

- 단위 테스트와 통합 테스트 중에서 어떤 방법을 쓸지- 어떻게 결정해야할까?
  - 단위 테스트를 먼저 고려한다
  - 외부 리소스가 필요하면 통합 테스트
  - DAO는 단위 테스트보다 통합 테스트가 적합
  - DAO 테스트를 신뢰하면, 상위 테스트는 가볍게 -> DAO 자체가 충분히 검증돼 있으면
    <br> DAO를 사용하는 코드는 스텁이나 목으로 대체해서 단위 테스트 가능
  - 단위 테스트가 충분하면 통합 테스트 부담은 적음.
  - 단위 테스트가 너무 어려우면 통합 테스트부터. -> 가능한 부분은 단위 테스트로 분리
  - 스프링 테스트 컨텍스트 = 통합 테스트
    <br> @RunWith(SpringRunner.class)등 사용하면 -> 통합 테스트
    <br> 가능하면 스프링 없이, 직접 DI해서 단위 테스트
    <br> 하지만 스프링 설정 자체를 검증해야 하면 스프링 테스트 컨텍스트 사용
    
### 6.2.4 목 프레임 워크

- 단위 테스트를 만들기 위해서는 스텁이나 목 오브젝트의 사용이 필수적이다. 의존 관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트 할 때가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하게 되기 때문.
- 단위 테스트가 많은 장점이 있고 가장 우선시해야 할 테스트 방법이다. 하지만 작성이 번거로운게 단점이다.
  <br> 특히 목 오브젝트를 만드는 일이 가장 번거롭다.
  <br> 이런 번거로움을 해결하기 위해서 목 오브젝트를 편리하게 작성하도록 도와주는 다양한 목 오브젝트 지원 프레임워크가 존재한다.


### Mockito 프레임워크

- Mockito 와 같은 프레임워크의 특징은 목 클래스를 일일이 준비해둘 필요가 없다-는 점이다.
  <br> 간단한 메소드 호출만으로 다이내믹하게 특정 인터페이스를 구현한 테스트용 목 오브젝트를 만들 수 있다.

<img width="315" height="52" alt="image" src="https://github.com/user-attachments/assets/5f25d677-f8dd-488b-941a-a11da2dea555" />

- UserDao 인터페이스를 구현한 테스트용 목 오브젝트는 위와 같이 Mockito의 스태틱 메소드를 한 번 호출해주면 만들어진다. <br> mock() 메소드는 org.mockito,Matchers클래스에 정의된 스태틱 메소드이다. 스태틱 임포트를 사용해 로컬 메소드처럼 호출하게 하면 편리하다.
- 위 처럼 만들어진 목 오브젝트는 아직 아무런 기능이 없다. 여기서 getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁 기능을 추가해줘야 한다. 아래사진 처럼 말이다.

<img width="401" height="47" alt="image" src="https://github.com/user-attachments/assets/ed12e88b-73fb-4d1c-aed4-f5b0b3ea5564" />

- mockUserDao.getAll()이 호출됐을 때, user 리스트를 리턴해주라-는 선언이다.
<br> 이렇게 정의한 후에는 mockUserDao의 getAll() 메소드가 호출되면 users 리스트가 자동으로 리턴 될 것이다.

<img width="401" height="41" alt="image" src="https://github.com/user-attachments/assets/dc0fcc40-7925-4573-b0da-e8cd4080b01f" />

- update() 호출이 있었는지를 검증하는 부분이다. Mockito를 통해 만들어진 목 오브젝트는 메소드의 호출과 관련된 모든 내용을 자동으로 저장해두고, 이를 간단한 메소드로 검증할 수 있게 해준다.
  <br> 테스트를 진행하는 동안 mockUserDao의 update() 메소드가 두 번 호출됐는지 확인하고 싶다면 뒤와 같이 검증 코드를 넣어주면 된다.
- (코드 설명) User타입의 오브젝트를 파라미터로 받으며 update() 메소드가 두 번 호출됐는지 확인하라는 코드.
- 여기서 알수 있는 장점 :
  <br> UserDao 인터페이스를 구현한 클래스를 만들 필요도 없고 리턴 값을 생성자를 통해 넣어줬다가 메소드 호출 시 리턴하도록 코드를 만들 필요도 없다.
  <br> 특정 메소드의 호출이 있었는지, 어떤 값을 가지고 호출했는지 모두 기록해뒀다가 반환하는 기능을 만들지않아도 된다.
  <br> 편리하게 작성된 메소드 몇 개로 목 오브젝트를 사용할 수 있게 해준다.

- Mockito 목 오브젝트는 네 단계를 거쳐서 사용한다.
  - 인터페이스를 이용해 목 오브젝트를 만든다.
  - 목 오브젝트가 리턴할 값이 있으면 이를 지정해준다
  <br> 메소드가 호출되면 예외를 강제로 던지게 만들 수도 있다.
  - 테스트 대상 오브젝트에 DI해서 목 오브젝트가 테스트 중에 사용되도록 만든다.
  - 테스트 대상 오브젝트를 사용한 후에 목 오브젝트의 특정 메소드가 호출됐는지,
    <br> 어떤 값을 가지고 몇 번 호출됐는지를 검증한다.



<img width="537" height="688" alt="image" src="https://github.com/user-attachments/assets/2c3d27ee-a3ae-428e-a1e1-eb4215658cfa" />

- 위 그림을 보면 알수 있는 것
  - Mock객체를 "클래스 작성 없이" 바로 만든다.
  <br> 이전에는 클래스를 직접 작성하고 getAll(), update() 메서들 구현해서 코드가 많고, 유지보수에 부담이 있었다면
 <br> Mockito는
```
UserDao mockUserDao = mock(UserDao.class);
```
로 UserDao 구현체를 생성하고 모든 메서드를 자동 Mock으로 처리한다.


 - Stub설정이 눈에 보이게 간단해 진다.
   ```
   when(mockUserDao.getAll()).thenReturn(this.users);
```
이 코드를 보면 getAll()이 호출되면 DB대신 준비한 users리스트를 돌려주라-란 뜻인데
입력과 출력 규치이 테스트 코드에 그대로 드러난다.

 -  Mock은 상태가 아닌 '행위검증'을 한다는 것을 알 수 있다.

- ArgumentCaptor로 “전달된 값”까지 검증할 수 있다
<br> send()가 호출 될 때 실제로 전달된 메일 객체를 가로챈다. 그리고 나서 메일이 누구에게 보내졌는지까지 정확히 검증한다. 밑을 보면 알 수 있다.
```
assertThat(mailMessages.get(0).getTo()[0], is(users.get(1).getEmail()));
```

- Mockito와 같은 목 오브젝트 지원 프레임워크 하나쯤은 익숙하게 사용할 수 있도록 학습해두자~~!!



