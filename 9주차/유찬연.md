<img width="508" height="246" alt="{E580D0AF-F88A-4E7D-9D3F-935CDFCEDFD4}" src="https://github.com/user-attachments/assets/4b775670-f1cb-4064-b3b8-34a408bf3266" /># AOP

IoC/DI, 서비스 추상화와 더불어 스프링의 3대 기반 기술 중 하나.

# 트랜잭션 코드의 분리

## 메소드 분리

<img width="611" height="468" alt="{D0ABDB8F-26E3-4D0A-A3B0-633F1F97379C}" src="https://github.com/user-attachments/assets/b8ecef53-9b5b-4895-a4bc-1cb00ba3be3d" />

트랜잭션 경계 설정과 비즈니스 로직이 뚜렷하게 구분되어 존재.

또한, 두 코드 간의 주고 받는 정보가 없음.

이렇게 두 코드가 완벽하게 독립적인 코드인 경우 분리 시도 가능

<img width="612" height="518" alt="{4FFD9539-D493-4578-B332-94620A149297}" src="https://github.com/user-attachments/assets/fd9fa396-08e7-4128-90a1-d024a005c6f4" />

우선 비즈니스 로직을 위와 같이 독립적인 메소드로 분리.

## DI를 이용한 클래스의 분리

비즈니스 로직을 담당하는 코드는 깔끔하게 분리되었지만 트랜잭션 코드가 아직도 UserService 안에 자리하고 있음.

꼭 필요한 기능이지만 간단하게 트랜잭션 코드를 클래스 밖으로 뽑아내어 UserService 내에서는 보이지 않도록 할 수 있음.

## DI 적용을 이용한 트랜잭션 분리

<img width="515" height="124" alt="{68D49DD2-9E5F-4A67-8BC7-D95F38FDDBFA}" src="https://github.com/user-attachments/assets/463e0af8-7087-436f-9cfd-2f02737193ed" />

현재 클라이언트와 서비스 클래스는 그림처럼 강하게 결합되어 있지만, UserService를 인터페이스로 만들고 기존 코드는 UserService 인터페이스의 구현 클래스를 만들어 넣으면 클라이언트와 결합이 약해지고, 유연한 확장이 가능해짐.

How? 직접 구현 클래스에 의존하고 있지 않기 때문.

<img width="508" height="246" alt="{E580D0AF-F88A-4E7D-9D3F-935CDFCEDFD4}" src="https://github.com/user-attachments/assets/7095aa73-484a-4025-990e-1456bd1f8c34" />

보통 인터페이스를 이용해 구현 클래스를 클라이언트에 노출하지 않고 런타임 시에 DI를 통해 적용하는 방법을 쓰는 이유는 필요에 따라 구현 클래스를 바꿔가며 한 번에 한 가지 클래스를 선택해서 적용하여 사용하기 위해서.

하지만 한 번에 두 개의 인터페이스 구현 클래스를 이용하면 안된다는 제약이 없음.

지금 당면한 문제는 UserService 내의 비즈니스 로직은 놔두고 트랜잭션 경계 설정을 담당하는 코드를 외부로 빼내는 것.

<img width="613" height="240" alt="{6E733326-5FB6-402B-B530-0A58EF42284B}" src="https://github.com/user-attachments/assets/b96d6944-5cdd-4ced-a801-bf8cbe587498" />

이를 위의 그림과 같은 구조로 해결 가능.

트랜잭션 경계 설정을 위한 인터페이스인 UserServiceTx와 비즈니스 로직이 담긴 인터페이스인 UserServiceImpl로 두 개의 인터페이스를 사용한다면 클라이언트 입장에서 트랜잭션이 적용된 비즈니스 로직의 구현이라는 동작을 기대 가능.

### UserService 인터페이스 됩

기존의 UserService를 UserServiceImpl로 이름을 변경.

그리고 클라이언트가 사용할 로직만 UserServie 인터페이스 내에 작성.

<img width="611" height="164" alt="{8989010E-1B31-4648-85D7-E1FEFBCC1BAB}" src="https://github.com/user-attachments/assets/a7824fe9-f019-492b-b465-917ba0511f0b" />

UserServiceImpl은 기존 UserService 클래스의 내용을 대부분 그대로 유지하고 트랜잭션 관련 코드는 모두 제거.

<img width="609" height="405" alt="{CA5E80E3-C603-4795-8937-62B3E5AE0CB0}" src="https://github.com/user-attachments/assets/795e7f50-228d-4fe3-985f-06441cefade4" />

### 분리된 트랜잭션 기능

<img width="614" height="450" alt="{D7A5043F-A28F-49C2-8350-DCDDCF1E4DE4}" src="https://github.com/user-attachments/assets/456ec444-4546-485e-a7dd-c75840f883ea" />

UserServiceTx는 기본적으로 UserService를 구현하게 만들고  비즈니스 로직에 대해서는 아무런 관여도 하지 않음.

이를 위해 UserService 오브젝트를 DI 받을 수 있도록 작성.

이제 UserServiceTx에 트랜잭션의 경계 설정이라는 부가적인 작업을 부여.

transactionManager라는 이름의 빈으로 등록된 트랜잭션 매니저를 DI로 받아두고 트랜잭션 안에서 동작하도록 만들어줘야 하는 메소드 호출의 전과 후에 트랜잭션 경계 설정 API를 사용하면 됨

<img width="612" height="778" alt="{1AD83D87-33EC-401D-8014-69B9AA2262B7}" src="https://github.com/user-attachments/assets/19aeafbb-28aa-436f-a5be-534afc1467f1" />

### 트랜잭션 적용을 위한 DI 설정

<img width="614" height="113" alt="{A6BC7FC6-3CC8-4CD8-B874-03149DADD5D7}" src="https://github.com/user-attachments/assets/e6cfb8dd-7a4b-46fc-ae69-281697f92ce2" />

클라이언트가 UserService라는 인터페이스를 통해 사용자 관리 로직을 이용하려고 할 때 먼저 트랜잭션을 담당하는 오브젝트가 사용되어 트랜잭션에 관련된 작업을 진행해주고, 실제 사용자 관리 로직을 담은 오브젝트가 이후 호출되어 비즈니스 로직에 관련된 작업을 수행하도록 만들어 줌.

<img width="610" height="275" alt="{8284D01E-5234-4CAD-AD8C-389C919A347C}" src="https://github.com/user-attachments/assets/7ab508b1-4879-4116-990f-d5ed8eeae1b0" />

설정 파일을 위와 같이 수정하여 의존 관계를 구성해줌

### 트랜잭션 경계 설정 코드 분리의 장점

1. 비즈니스 로직을 담당하는 코드 작성 시 트랜잭션과 같은 기술적인 내용에 신경을 쓸 필요가 없음
2. 비즈니스 로직에 대한 테스트를 보다 쉽게 만들어 낼 수 있음.

# 고립된 단위 테스트

가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개어 테스트하는 것.

why? 테스트가 실패했을 때 원인을 찾기가 쉽기 때문.

## 복잡한 의존 관계 속의 테스트

<img width="608" height="262" alt="{83638EB1-2D38-4C2C-A449-550E611D9FF3}" src="https://github.com/user-attachments/assets/9ca05629-64ae-4945-95f4-27fefa81ff85" />

위는 기존의 UserService의 테스트 동작 구조.

UserService가 세 가지 의존 관계를 가지고 있어 테스트 진행 시 같이 실행됨.

이로 인해 어느 것 하나라도 셋업이 바르게 되어 있지 않거나, 코드에 문제가 있는 경우 이로 인해 테스트가 실패해버림.

테스트 준비도 어려울 뿐 더러 환경이 달라지는 경우 결과도 달라짐.

## 테스트 대상 오브젝트 고립시키기

따라서 테스트의 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향을 받지 않도록 고립시킬 필요가 있음.

### 테스트를 위한 UserServiceImpl 고립

<img width="611" height="238" alt="{10171994-98C5-433E-A3BB-458AEB961E7A}" src="https://github.com/user-attachments/assets/34f1d63e-2f20-401e-8818-b3a51ed49256" />

트랜잭션 코드를 독립시켰기 때문에 사용자 관리 로직을 담은 UserServiceImpl은 PlatformTransactinoManager에 더 이상 의존하지 않음.

UserDao는 단지 테스트 대상의 코드가 정상적으로 수행되도록 도와주기만 하는 스텁이 아닌 부가적인 검증 기능까지 갖춘 목 오브젝트로 생성.

why? 고립된 환경에서 동작하는upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 떄문.

UserServiceImpl의 upgradeLevels() 메소드는 void형으로 메소드를 실행하고 그 결과를 받아서 검증하는 것이 불가능.

목 오브젝트를 이용한 테스트에서는 기능이 올바르게 수행되어도 DB에 결과가 남지 않아 작업 결과 검증이 어려움.

이런 경우 UserServiceImpl과 그 협력 오브젝트인 UserDao에게 어떤 요청을 했는 지를 확인하는 작업이 필요.

why? UserDao의 update() 메소드를 호출하는 것을 확인할 수 있다면, 결국 DB에 그 결과가 반영될 것이라는 결론을 내릴 수 있기 떄문.

### 고립된 단위 테스트 활용

<img width="610" height="650" alt="{80730520-AA66-4786-AB72-BF4E3F4895B7}" src="https://github.com/user-attachments/assets/df099a51-9130-4a16-8898-d83d04e80997" />

위 테스트는 다섯 단계의 작업으로 구성됨.

1. 테스트 실행 중 UserDao를 통해 가져올 테스트 정보를 DB에 넣음.
2. 메일 발송 여부를 확인하기 위해 MailSender 목 오브젝트를 DI
3. 실제 테스트 대상인 userService의 메소드를 실행
4. 결과가 DB에 반영됐는지 확인하기 위해 UserDao를 이용해 DB에서 데이터를 가져와 결과를 확인
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지 확인.

처음 두 가지는 UserService의 upgradeLevels() 메소드가 실행되는 동안 사용하는 의존 오브젝트가 테스트의 목적에 맞게 동작하도록 준비하는 과정.

첫 번째 작업은 의존 관계를 따라 마지막에 등장하는 DB를 준비하는 것.

두 번째는 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 테스트만을 위한 목 오브젝트를 준비함.

네 번째와 다섯 번째는 테스트 대상 코드를 실행한 후에 결과를 확인하는 작업.

네 번째는 의존 관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인하는 방법.

다섯 번째는 메일 서버까지 갈 필요 없이 목 오브젝트를 통해 upgradeLevels() 메소드가 실행되는 중 메일 발송 요청이 나간 적이 있는 지만 확인.

### UserDao 목 오브젝트

실제 UserDao와 DB까지 직접 의존하고 있는 첫 번째와 네 번째 방식도 목 오브젝트를 만들어서 적용 시도.

<img width="613" height="437" alt="{F9A8E0E7-8DAC-4EF0-8751-DF469077BBF1}" src="https://github.com/user-attachments/assets/02f41857-ae81-4b20-9c55-2a650c89348c" />

위의 이미지에서 UserServiceImpl이 코드에서 upgradeLevels() 메소드와 그 사용 메소드에서 UserDao를 사용하는 경우는 두 가지.

userDao.getAll(), userDao.update(user).

userDao.getAll()은 레벨 업그레이드 후보가 될 사용자의 목록을 받아옴.

실제 DB에서 읽어온 것처럼 미리 준비된 사용자 목록을 제공해주어야 함.

테스트 진행만을 위한다면 테스트용 UserDao를 빈 메소드로 만들어도 되지만, update() 메소드의 사용은 변경에 해당하는 부분을 검증 가능한 중요한 기능이므로 업그레이드를 통해 레벨이 변경된 사용자는 DB에 반영되도록 UserDao의 update()에 전달돼야 함.

따라서 getAll()에 대해서는 스텁으로, update()에 대해서는 목 오브젝트로 동작하는 UserDao 타입의 테스트 대역이 필요.

<img width="564" height="622" alt="{36DCD06E-BD1F-4736-8335-100E04A4405B}" src="https://github.com/user-attachments/assets/a5fafb3f-825f-43f5-acba-24713ef437d1" />


MockUserDao는 UserDao 구현 클래스를 대신해야 하기에 UserDao 인터페이스 구현 필요.

MockUserDao에는 두 개의 User 타입 리스트를 정의해 둠.

하나는 생성자를 통해 전달 받은 사용자 목록을 저장해뒀다가 getAll() 메소드가 호출되면 DB에서 가져온 것처럼 돌려주는 용도. → 미리 준비된 테스트용 리스트를 메모리에 갖고 있다가 돌려주기만 하면 됨.

다른 하나는 update() 메소드를 실행하면서 넘겨준 업그레이드 대상 user 오브젝트를 저장해줬다가 검증을 위해 돌려주기 위한 것. → 메소드 실행 중에 업그레이드 대상으로 선정된 사용자가 어떤 것인지 확인하는 데 사용.

<img width="610" height="642" alt="{C5E50F78-95C1-4821-BF17-622410675E93}" src="https://github.com/user-attachments/assets/62e28bd8-91e3-4e3a-b347-10100577468b" />

위는 모든 변경 사항이 적용된 테스트 코드 이미지.

### 테스트 수행 성능의 향상

UserServiceImpl와 테스트를 도와주는 두 개의 목 오브젝트 외에는 사용자 관리 로직을 검증하는데 직접적으로 필요하지 않은 의존 오브젝트와 서비스를 모두 제거한 덕분에 테스트 수행 시간이 매우 짧아짐.

고립된 테스트의 경우 준비가 쉬울 뿐만 아니라 테스트 수행 성능도 크게 향상됨.

## 단위 테스트와 통합 테스트

단위 테스트의 단위는 사용자 관리 기능 전체를 하나의 단위로 볼 수도 있고, 하나의 클래스나 메소드를 단위로 볼 수 도 있음.

중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 것.

이 책에서는 테스트 대상 클래스를 목 오브젝트 등의 테스트 대역을 이용해 의존 오브젝트나 외부의 리소스를 사용하지 않도록 고립시켜 테스트하는 것을 단위 테스트로 정의.

반면, 두 개 이상의 성격이나 계층이 다른 오브젝트가 연동하도록 만들어 테스트하거나, 외부의 DB나 파일, 서비스 등의 리소스가 참여하는 테스트는 통합테스트.

단위 테스트와 통합 테스트 중 어떤 방법을 선택할 지에 대한 가이드 라인

<img width="545" height="777" alt="{83B24136-B827-4F1E-B3E2-137404B340EC}" src="https://github.com/user-attachments/assets/c17da862-0bc9-425a-a164-2392738b5ed0" />

여기서 말하는 단위/통합 테스트는 모두 개발자 스스로 자신이 만든 코드를 검증하기 위해 만드는 개발자 테스트.

기능 테스트와는 다른 관점에서 생각해야 함.

테스트는 코드 작성 직후 진행되는 것이 좋음.

시간이 지난 뒤의 테스트 코드 작성은 코드에 대한 이해가 떨어져 불완전해지기 쉽고 작성도 번거로움.

## 목 프레임워크

단위 테스트를 위해서는 스텁이나 목 오브젝트의 사용이 필수적.

why? 의존 관계가 없는 단순한 클래스나 세부 로직을 검증하기 위해 메소드 단위로 테스트 하는 경우가 아니라면, 대부분 의존 오브젝트를 필요로 하는 코드를 테스트하기 때문.

단위 테스트는 많은 장점이 있지만 작성이 번거로움.

그 중 목 오브젝트를 만드는 일이 가장 큰 어려움.

why? 테스트에서 사용하지 않는 인터페이스도 모두 일일이 구현이 필요하기 때문.

### Mockito 프레임워크

Mockito와 같은 목 프레임워크의 특징은 목 클래스를 일일이 준비해 둘 필요가 없다는 것.

간단한 메소드 호출만으로 동적으로 특정 인터페이스를 구현한 테스트용 목 오브젝트 생성 가능.

<img width="292" height="40" alt="{D8535182-0B97-448B-898C-9208A88D4164}" src="https://github.com/user-attachments/assets/126990aa-e6e5-408a-b948-bae782950799" />

위의 목 오브젝트는 기능이 없음.

getAll() 메소드가 불려올 때 사용자 목록을 리턴하도록 스텁 기능 추가 필요.

<img width="343" height="29" alt="{9FB47374-0D5E-44D3-87A0-4456E4D3A089}" src="https://github.com/user-attachments/assets/0565949e-4fdf-41b8-b5ff-9620ae5f93c0" />

<img width="356" height="65" alt="{FE0717A3-238A-4C1A-AA19-FF23FF90550C}" src="https://github.com/user-attachments/assets/a883b08c-c615-4a54-b2c2-4def9087b966" />

update() 호출이 있었는지에 대한 검증 역시 위와 같이 간단한 메소드를 통해 검증 가능.

Mockito 목 오브젝트는 다음의 네 단계를 거쳐서 사용하면 됨.

<img width="545" height="186" alt="{CB089D4E-C994-44D4-B3C3-77E7DE877EAF}" src="https://github.com/user-attachments/assets/56fbcffb-65e9-47b8-b009-29a8a3d73c04" />

특별한 기능을 가진 목 오브젝트를 만드는 경우가 아니라면 대부분의 경우에서 사용 가능.

<img width="579" height="680" alt="{52937591-43C8-4EB7-86E3-D9B6D792DFCA}" src="https://github.com/user-attachments/assets/3df7e1bd-a982-4f31-af1b-2a6e2096b07c" />

Mockito를 이용하여 만든 테스트 코드에서는 mock()으로 가짜 객체를 바로 만들어주고, when()으로 행동 미리 정해둔 뒤 verify()로 호출 여부/횟수/대상 확인하고, ArgumentCaptor로 전달된 값까지 쉽게 꺼내볼 수 있음.

Mockito는 목 오브젝트 방식을 지원하는 프레임워크 중 가장 사용하기 편한 기능을 갖고 있음.

처음에는 어려울 수 있어도 익숙해지면 빠른 속도로 단위 테스트를 만드는 데 강력한 도구가 될 것.
