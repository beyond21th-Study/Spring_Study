# 6.4 스프링의 프록시 팩토리 빈
## 6.4.1 Proxy Factory Bean

- 스프링의 ProxyFacotryBean은 프록시를 생성세서 빈 오브젝트로 등록하게 해주는 팩토리 빈.
- 기존의 ㅆ톄개툚ㅊ새교ㅠㄷ무rhk ekffl, ProxyFactoryBean은 순수하게 프록시를 생성하는 작업만을 담다하고 프록시를 통해 제공해줄 부가기능은 별도의 빈에 둘 수 있다.

- ProxyFactoryBean이 생성하는 프록시에서 사용할 부가기능은 MethodInterceptor 인터페이스를 구현해서 만든다.
- InvocationHandler의 invoke()메소드는 타깃 오브젝트에 대한 정보를 제공하지 않기 때문에 타깃은 InvocationHandler를 구현한 클래스가 직접 알고 있어야 한다.
- 하지만 MethodInterceptor는 MethodInterceptor의 invoke() 메소드는 ProxyFactoryBean으로부터 타깃 오브젝트에 대한 정보까지도 함께 제공받는다.
 <br> 이 덕분에 MethodInterceptor는 타깃 오브젝트에 상관없이 독립적으로 만들어질 수 있다.
  <br> 그리고 MethodInterceptor 오브젝트는 타깃이 다른 여러 프록시에서 함께 사용할 수 있고 싱글톤 빈으로 등록 가능하다.

### 어드바이스 : 타깃이 필요 없는 순수한 부가기능

- MethodInterceptor를 구현한 UppercaseAdvice에는 타깃 오브젝트가 등장하지 않는다.
  <br> MethodInterceptor로는 메소드 정보와 함께 타깃 오브젝트가 담긴 MethodInvocation 오브젝트가 전달된다.
  <br> MethodInvocation은 타깃 오브젝트의 메소드를 실행할 수 있는 기능이 있기 때문에 MethodInterceptor는 부가기능을 제공하는 데만 집중할 수 있다.
  <br> MethodInvocation은 일종의 콜백 오브젝트로, proceed()메소드를 실행하면 타깃 오브젝트의 메소드를 내부적으로 실행해주는 기능이 있다.
<br> MethodInvocation 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다.

- ProxyFactoryBean은 작은 단위의 템플릿/콜백 구조를 응용해서 적용했기 때문에 템플릿 역할을 하는 MethodInvocation을 싱글톤으로 두고 공유할 수 있다.
- SQL 파라미터 정보에 종속되지 않는 JdbcTemplate이기 때문에 수많은 DAO 메소드가 하나의 JdbxTemplate 오브젝트를 공유할 수 있는 것과 마찬가지다.

- ProxyFactoryBean에 이 MethodInterceptor를 설정해줄 때에는 일반적인 DI 경우처럼 수정자 메소드를 사용하는 대신 addAdvice()라는 메소드를 사용한다.
  <br> add라는 이름에서 알 수 있듯이 ProxyFactoryBean 하나만으로 여러 개의 부가기능을 제공해주는 프록시를 만들 수 있다는 뜻이다.
  <br> 새로운 부가기능을 추가할 때마다 프록시와 프록시 팩토리 빈도 추가해줘야 한다는 프록시 팩토리 빈의 문제를 해결 할 수 있다.
  <br> 많은 부가기능을 적용 하더라도 ProxyFactoryBean 하나면 충분하다.

- MethodInterceptor 오브젝트를 추가하는 메소드 이름은 addMethodInterceptor가 아니고 addAdvice이다.
- MethodInterceptor는 Advice 인터페이스를 상속하고 있는 서브인터페이스이기 때문이다.
- 어드바이스란 MethodInterceptor처럼 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트이다.

- 스프링의 ProxyFactoryBean은 어떻게 인터페이스 타입을 제공받지도 않고 Hello 인터페이스를 구현한 프록시를 만들어낼 수 있을까?
  <br> -> ProxyFactoryBean도 setInterfaces() 메소드를 통해서 구현해야 할 인터페이스를 지정할 수 있지만 인터페이스를 굳이 알려주지 않아도
  <br> ProxyFactoryBean에 있는 인터페이스 자동검출 기능을 사용해 타깃 오브젝트가 구현하고 있는 인터페이스 정보를 알아낸다.
  <br> 그리고 알아낸 인터페이스를 모두 구현하는 프록시를 만들어준다. 타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시를 만들어주는 기능이다.
  <br> 타깃 오브젝트가 구현하는 인터페이스 중에서 일부만 프록시에 적용하기를 원한다면 인터페이스에 정보를 직접 제공해줘도 된다.

### 포인트컷 : 부가기능 적용 대상 메소드 선정 방법

- 기존에 InvocationHandler를 직접 구현했을 때는 부가기능 적용 외에도 한 가지 작업이 더 있었다.
<br> 메소드의 이름을 가지고 부가기능을 적용 대상 메소드를 선정하는 것이었다.
- TxProxyFactoryBean은 pattern이라는 메소드 이름 비교용 스트링 값을 DI 받아서 TransactionHandler를 생성할 때 이를 넘겨주고 TransactionHandler는 요청이 들어오는 메소드의 이름과 패턴을 비교해서 부가기능인 트랜잭션 적용 대상을 판별했다.
- 그렇다면 스프링의 ProxyFactoryBean과 MethodInterceptor를 사용하는 방식에서도 메소드 선정 기능을 넣을 수 있을까?
- 일단 코드 개선 전략을 적용해본다. 함께 두기 곤란한, 성격이 다르고, 변경 이유와 시점이 다르고, 생성 방식과 의존관계가 다른 코드가 함께 있다면 분리해주면 된다.
- MethodInterceptor는 InvocationHandler와는 다르게 프록시가 클라이언트로부터 받는 요청을 일일이 전달받을 필요는 없다.
<br> MethodInterceptor에는 재사용 가능한 순수한 부가기능 제공 코드만 남겨준다. 대신에 프록시에 부가기능 적용 메소드를 선택하는 기능을 넣는다.
<br> 프록시의 핵심 가치는 타깃을 대신해서 클라이언트의 요청을 받아 처리하는 오브젝트로서의 존재 자체이므로, 메소드를 선별하는 기능은 프록시로부터 다시 분리하는 편이 낫다.
<br> 왜? 메소드를 선정하는 일도 일종의 교환 가능한 알고리즘이므로 전략 패턴을 적용할수 있기 때문이다.

<img width="735" height="234" alt="image" src="https://github.com/user-attachments/assets/64695c72-d823-485e-b8ba-03fb25466042" />

- 하지만 부가기능을 가진 InvocationHandler가 타깃과 메소드 선정 알고리즘 코드에 의존하고 있다-라는 문제가 있다.
<br> 만약 타깃이 다르고 메소드 선정 방식이 다르다면 InvocationHandler오브젝트를 여러 프록시가 공유할 수 없다.
<br> 타깃과 메소드 선정 알고리즘은 DI를 통해 분리할 수는 있지만 한번 빈으로 구성된 InvocationHandler 오브젝트는, 오브젝트 차원에서 특정 타깃을 위한 프록시에 제한된다는 뜻이다.
<br>그래서 InvocationHandler는 굳이 따로 빈으로 등록하는 대신 TxProxyFactoryBean 내부에서 매번 생성하도록 만들었던 것이다.
<br> 따라서 타깃 변경과 메소드 선정 알고리즘 변경 같은 확장이 필요하면 팩토리 빈 내의 프록시 생성코드를 직접 변경해야 한다.


- 밑의 그림은 스프링의 ProxcyFactoryBean 방식은 두 가지 확장 기능인 부가기능(advice)과 메소드 선정 알고리즘(pointcut)을 활용하는 유연한 구조를 제공한다. 

<img width="733" height="249" alt="image" src="https://github.com/user-attachments/assets/28930c07-5c6e-44b6-a853-329102a4688f" />

- 스프링은 부가기능을 제공하는 오브젝트를 어드바이스라고 부르고, 메소드 선정 알고리즘을 담은 오브젝트를 포인트컷이라고 부른다.
<br> 어드바이스와 포인트컷은 모두 프록시에 DI로 주입돼서 사용된다. 두 가지 모두 여러 프록시에서 공유가 가능하도록 만들어지기 때문에 스프링의 싱글톤 빈으로 등록이 가능하다.

- 프록시는 클라이언트로부터 요청을 받으면 먼저 포인트컷에게 부가기능을 부여할 메소드인지를 확인해달라고 요청한다. 포인트컷은 Pointccut 인터페이스를 구현해서 만들면 된다.
- 프록시는 포인트컷으로부터 부가기능을 적용할 대상 메소드인지 확인받으면, MethodInterceptor 타입의 어드바이스를 호출한다.
- 어드바이스는 JDK의 다이내믹 프록시의 InvocationHandler와 달리 직접 타깃을 호출하지 않는다. 자신이 공유돼야 하므로 타깃 정보라는 상태를 가질 수 없다.
- 따라서 타깃에 직접 의존하지 않도록 일종의 템플릿구조로 설계되어 있다. 어드바이스가 부가기능을 부여하는 중에 타깃 메소드의 호출이 필요하면 프록시로부터 전달받은 MethodInvocation 타입 콜백 오브젝트의 proceed()메소드를 호출해주기만 하면 된다.

- 실제 위임 대상인 타깃 오브젝트의 레퍼런스를 갖고 있고 이를 이용해 타깃 메소드를 직접 호출하는 것은 프록시가 메소드 호출에 따라 만드는 Invocation콜백의 역할이다.
- 재사용 가능한 기능은 만들어두고 바뀌는 부분만 외부에서 주입해서 이를 작업 흐릅 중에 사용하도록 하는 전형적인 템플릿/콜백 구조다.
- 어드바이스가 일종의 템플릿이 되고 타깃을 호출하는 기능을 갖고 있는 MethodInvocation 오브젝트가 콜백이 되는 것이다.
- 템플릿은 한 번 만들면 재상요이 가능하고 여러 빈이 공유해서 사용할 수 있듯이, 어드바이스도 독립적인 싱글톤 빈으로 등록하고 DI를 주입해서 여러 프록시가 사용하도록 만들 수 있다.

<img width="835" height="572" alt="image" src="https://github.com/user-attachments/assets/35cbe541-84c9-481b-9a75-cdcb73a476d0" />

- 포인트컷이 필요 없을 때는 ProxyFactoryBean의 addAdvice() 메소드를 호출해서 어드바이스만 등록하면 됐다.
<br> 그런데 포인트컷을 함께 등록할 때는 어드바이스와 포인트컷을 Advisor 타입으로 묶어서 addAdvisor() 메소드를 호출해야 한다.
<br> 어드바이스를 등록하듯이 포인트컷도 그냥 추가하면 될 것을 왜 굳이 별개의 오브젝트로 묶어서 등록해야 할까? 그 이유는 ProxyFactoryBean에는 여러 개의 어드바이스와 포인트컷이 추가될 수 있기 때문이다.
- 포인트컷과 어드바이스를 따로 등록하면 어떤 어드바이스(부가기능)에 대해 어떤 포인트컷(메소드 선정)을 적용할지 애매해지기 때문이다.
<br> 그래서 이 둘을 Advisor 타입의 오브젝트에 담아서 조합을 만들어 등록하는 것이다. 여러 개의 어드바이스가 등록되더라도 각각 다른 포인트컷과 조합될 수 있기 때문에 각기 다른 메소드 선정 방식을 적용할 수 있다.
<br> 예를 들어 트랜잭션은 add로 시작하는 메소드에만 적용하지만, 보안 부가기능은 모든 메소드에 적용하고, 기능검사 부가기능은 get으로 시작하는 메소드에만 적용할 수가 있다. 이렇게 어드바이스와 포인트컷을 묶은 오브젝트를 인터페이스 이름을 따서 어드바이저라고 부른다.

## 6.4.2 ProxyFactoryBean 적용

### TransactionAdvice


<img width="638" height="610" alt="image" src="https://github.com/user-attachments/assets/b611b592-8ea0-45c4-ad59-a236c5ec17db" />

- 부가기능을 담당하는 어드바이스는 테스트에서 만들어본 것처럼 MethodInterceptor라는 Advice 서브인터페이스를 구현해서 만든다.
- 위의 그림과 같이 JDK 다이내믹 프록시 방식으로 만든 TransactionHandler의 코드에서 타깃과 메소드 선정 부분을 제거해주면 된다.
- JDK 다이내믹 프록시의 InvocationHandler를 이용해서 만들었을 때보다 코드가 간결하다.
- 리플렉션을 통한 타깃 메소드 호출 작업의 번거로움은 MethodInvocation 타입의 콜백을 이용한 덕분에 대부분 제거할 수 있다.
- 타깃 메소드가 던지는 예외도 InvocationTargetException으로 포장돼서 오는 것이 아니기 때문에 그대로 잡아서 처리하면 된다.

- p471~474 (xml, test code)

### 어드바이스와 포인트컷의 재사용

<img width="661" height="350" alt="image" src="https://github.com/user-attachments/assets/74681e42-209e-494e-b103-0653c1050f0a" />

- ProxyFactoryBean은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
<br> 그 덕분에 독립적이며, 여러 프록시가 공유할 수 있는 어드바이스와 포인트컷으로 확장 기능을 분리할 수 있었다.
- UserService 외에 새로운 비즈니스 로직을 담은 서비스 클래스가 만들어져도 이미 만들어둔 TransactionAdvice를 그대로 재사용할 수 있다.
<br> 메소드의 선정을 위한 포인트컷이 필요하면 이름 패턴만 지정해서 ProxyFactoryBean에 등록해주면 된다.
<br> 트랜잭션을 적용할 메소드의 이름은 일관된 명명 규칙을 정해두면 하나의 포인트컷으로 충분할 수도 있다.

- 위의 그림은 ProxyFactoryBean을 이용해서 많은 수의 서비스 빈에게 트랜잭션 부가기능을 적용했을 때의 구조다. <br> 트랜잭션 부가기능을 담은 TransactionAdvice는 하나만 만들어서 싱글톤 빈으로 등록해주면, DI 설정을 통해 모든 서비스에 적용이 가능하다.
<br> 메소드 선정 방식이 달라지는 경우만 포인트컷의 설정을 따로 등록하고 어드바이저로 조합해서 적용해주면 된다.

- 이 구조는
  - TransactionAdvice는 하나만 만들어서 재사용
  - Pointcut만 바꿔서 적용 범위 조절
  - 서비스 클래스는 트랜잭션 코드 전혀 모름
  - 새로운 서비스가 생겨도 설정만 추가하면 끝
  - OCP(개방-폐쇄 원칙) 제대로 지킴
<br>이라는 특징을 갖고있다.

# 6.5 스프링 AOP

- AOP(Aspect Oriented Programming)는
<br> 핵심 비즈니스 로직과 공통 부가기능을 분리해서 적용하는 프로그래밍 방식. 
- 그럼 스프링 AOP는?
-> 스프링 AOP는 프록시를 이용해서 공통 부가기능을 자동으로 적용해주는 스프링의 AOP 구현 방식.

## 6.5.1 자동 프록시 생성
- 지금까지 해결된 것들을 보면 -> 부가기능(트랜잭션 등)을 Advice로 분리하고, 메서드 선정은 Pointcut으로 분리하고, 타깃 코드는 완전히 깔끔채로 남아있다. 또한 부가기능은 한 번만 만들어 재사용이 가능하다.
근데 아직 해결되지 못한 문제들이 있다
- 바로 ProxyFactoryBean 설정 중복이다. -> 서비스(타깃) 하나 생길 때마다 ProxyFactoryBean 설정 복사해서 붙여야하고 target만 바꿔서 또 등록해야한다. 
<br> 클래스, Advice, Pointcut은 설정이 거의 다 동일하다. 즉 설정이 중복되고 이렇게 되면 실수 위험이 생긴다.

### 중복 문제의 접근 방법

- JDBC 반복 코드는 바뀌지 않는 부분과 바뀌는 부분을 구분해서 분리하고 템플릿/콜백, 전략 패턴, DI로 해결했다. 
- 프록시 반복 코드는 JDK 다이내믹 프록시(런타임 코드 자동 생성)로 해결했다.
<br> 런타임 시에 만들어져 사용되기 때문에 클래스 소스가 따로 남지 않을 뿐이지 타깃 인터페이스의 모든 메소드를 구현하는 클래스가 분명히 만들어진다. 그 덕분에 개발자가 일일이 인터페이스 메소드를 구현하는 프록시 클래스를 만들어서 위임과 부가기능의 코드를 중복해서 넣어주지 않아도 되게 해줬다.

- 변하지 않는 타깃으로의 위임과 부가기능 적용 여부 판단이라는 부분은 코드 생성 기법을 이용하는 다이내믹 프록시 기술에 맡기고,
<br> 변하는 부가기능 코드는 별도로 만들어서 다이내믹 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한 것인데 <br> 변하는 로직과 변하지 않는 기계적인 코드를 잘 분리한것이다.

- 반복적인 프록시의 메소드 구현을 코드 자동생성 기법을 이용해 해결했다면 반복적인 ProxyFactoryBean 설정 문제는 설정 자동등록 기법으로 해결할 수는 없을까? -라는 고민을 하게된다.
<br> 또는 실제 빈 오브젝트가 되는 것은 ProxyFactoryBean을 통해 생성되는 프록시 그 자체이므로 프록시가 자동으로 빈으로 생성되게 할 수는 없을까? - 라는 고민도 하게된다.
<br> 마치 다이내믹 프록시가 인터페이스만 제공하면 모든 메소드에 대한 구현 클래스를 자동으로 만들듯이, 일정한 타깃 빈의 목록을 제공하면 자동으로 각 타깃 빈에 대한 프록시를 만들어주는 방법이 있다면 ProxyFactoryBean 타입 빈 설정을 매번 추가해서 프록시를 만들어내는 수고를 덜 수 있을 것 같다.

### 빈 후처리기를 이용한 자동 프록시 생성기

- 스프링은 OCP의 가장 중요한 요소인 유연한 확장이라는 개념을 스프링 컨테이너 자신에게도 다양한 방법으로 적용하고 있다.
<br> 스프링의 DI를 이용해 만들어지는 애플리케이션의 코드가 OCP에 충실할 수 있다면 스프링 스스로도 그런 가치를 따르는 게 마땅하다.
<br> 그래서 스프링은 컨테이너로서 제공하는 기능 중에서 변하지 않는 핵심적인 부분 외에는 대부분 확장할 수 있도록 확장 포인트를 제공해준다.

- BeanPostProcessor 인터페이스를 구현해서 만드는 빈 후처리기 :
<br> 빈 후처리기는 이름 그대로 스프링 빈 오브젝트로 만들어지고 난 후에, 빈 오브젝트를 다시 가공할 수 있게 해준다.

- 스프링이 제공하는 빈 후처리기 중의 하나인 DefaultAdvisorAutoProxyCreator :
<br> 이름을 보면 알 수 있듯이 DefaultAdvisorAutoProxyCreator는 어드바이저를 이용한 자동 프록시 생성기다.
<br> 빈 후처리기를 스프링에 적용하는 방법은 간단하다. 빈 후처리기 자체를 빈으로 등록하는 것이다.
<br> 스프링은 빈 후처리기가 빈으로 등록돼 있으면 빈 오브젝트가 생성될 때마다 빈 후처리기에 보내서 후처리 작업을 요청한다.
<br> 빈 후처리기는 빈 오브젝트의 프로퍼티를 강제로 수정할 수도 있고 별도의 초기화 작업을 수행할 수도 있다.
<br> 심지어는 만들어진 빈 오브젝트를 자체를 바꿔치기할 수도 있다. 따라서 스프링이 설정을 참고해서 만든 오브젝트가 아닌 다른 오브젝트를 빈으로 등록시키는 것이 가능하다.
<br> 이를 잘 이용하면 스프링이 생성하는 빈 오브젝트의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수도 있다. 바로 이것이 자동 프록시 생성 빈 후처리기다.

<img width="731" height="195" alt="image" src="https://github.com/user-attachments/assets/8ef08e60-1a27-41c6-95f9-081620ee0f48" />

- 위 그림은 빈 후처리기를 이용한 자동 프록시 생성 방법을 설명한다.
- DefaultAdvisorAutoProxyCreator 빈 후처리기가 등록되어 있으면 스프링은 빈 오브젝트를 만들 때마다 후처리기에게 빈을 보낸다.
<br> DefaultAdvisorAutoProxyCreator는 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
<br> 프록시 적용 대상이면 그때는 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
<br> 빈 후처리기는 프록시가 생성되면 원래 컨테이너가 전달해준 빈 오브젝트 대신 프록시 오브젝트를 컨테이너에게 돌려준다. 컨테이너는 최종적으로 빈 후처리기가 돌려준 오브젝트를 빈으로 등록하고 사용한다.
<br> 적용할 빈을 선정하는 로직이 추가된 포인트컷이 담긴 어드바이저를 등록하고 빈 후처리기를 사용하면 일일이 ProxyFactoryBean 빈을 등록하지 않아도 타깃 오브젝트에 자동으로 프록시가 적용되게 할 수 있다. 마지막 남은 번거로운 ProxyFactoryBean 설정 문제를 말끔하게 해결해주는 방법이다.


### 확장된 포인트컷

- 포인트컷은 클래스 필터와 메소드 매처 두 가지를 돌려주는 메소드를 갖고 있다.
- 지금까지는 포인트컷이 제공하는 두 가지 기능 중에서 MethodMatcher라는 메소드 선별 기능만 사용해온 것이다. 기존에 사용한 NameMatchMethodPointcut은 메소드 선별 기능만 가진 특별한 포인트컷이다. 메소드만 선별한다는 건 클래스 필터는 모든 클래스를 다 받아주도록 만들어져 있다는 뜻이다. 따라서 클래스의 종류는 상관없이 메소드만 판별한다. 어차피 ProxyFactoryBean에서 포인트컷을 사용할 때는 이미 타깃이 정해져 있기 때문에 포인트컷은 메소드 선별만 해주면 그만이었다.

- 만약 Pointcut 선정 기능을 모두 적용한다면 먼저 프록시를 적용할 클래스인지 판단하고 나서, 적용 대상 클래스인 경우에는 어드바이스를 적용할 메소드인지 확인하는 식으로 동작한다. 클래스 자체가 프록시 적용 대상이 아니라면 어드바이스를 통한 부가기능 부여는 물 건너간 셈이다. 결국 이 두 가지 조건이 모두 충족되는 타깃의 메소드에 어드바이스가 적용되는 것이다.

- ProxyFactoryBean에서는 굳이 클래스 레벨의 필터는 필요 없었지만, 모든 빈에 대해 프록시 자동 적용 대상을 선별해야 하는 빈 후처리기인 DefaultAdvisorAutoProxyCreator는 클래스와 메소드 선정 알고리즘을 모두 갖고 있는 포인트컷이 필요하다. 정확히는 그런 포인트컷과 어드바이스가 결합되어 있는 어드바이저가 등록되어 있어야 한다.

### 포인트컷 테스트

<img width="730" height="564" alt="image" src="https://github.com/user-attachments/assets/114f2a9f-bff9-49be-b4fc-031744d00f3f" />
<img width="620" height="423" alt="image" src="https://github.com/user-attachments/assets/094e5ea2-c486-499c-82e0-331d4b3f938c" />

- 테스트는 세 가지 클래스에 대해 진행한다. 모두 기존에 있던 HelloTarget이라는 클래스를 그대로 상속한 것이라 메소드 내용은 동일하다. 단지 클래스 이름만 다를 뿐이다.

- 이 세 개의 클래스에 모두 동일한 포인트컷을 적용했다. 메소드 선정 기준으로만 보자면 두 개의 메소드에는 어드바이스를 적용하고 마지막 것은 적용되지 않으면 된다. 하지만 두 번째 HelloWorld라는 클래스는 클래스 필터에서 이미 탈락해버리기 때문에 메소드 이름과 무관하게 모든 메소드가 어드바이스 적용 대상에서 제외된다.

- 세 개의 클래스를 포인트컷을 적용할 타깃 오브젝트로 각각 등록하고 각 메소드에 대해 어드바이스 적용 여부를 확인한다. 테스트를 돌려보면 성공이다. 클래스 필터를 통과하지 못하는 HelloWorld 클래스로 만든 타깃 오브젝트는 모든 메소드에 어드바이스가 적용되지 않았다는 사실을 기억해두자.

- 포인트컷이 클래스 필터까지 동작해서 클래스를 걸러버리면 아무리 프록시를 적용했다고 해도 부가기능은 전혀 제공되지 않는다는 점에 주의해야 한다. 사실 클래스 필터에서 통과하지 못한 대상은 프록시를 만들 필요조차 없다. 어차피 어떤 메소드에도 부가기능이 적용되지 않을 텐데 굳이 프록시를 둘 이유가 없기 때문이다.


## 6.5.2 Default Adivisor Auto Proxy Creator의 적용

### 클래스 필터를 적용한 포인트컷 작성

<img width="670" height="517" alt="image" src="https://github.com/user-attachments/assets/baca38d9-c0ee-4c0c-8538-f281ca14cb42" />

- 메서드 이름만 비교하던 기존 포인트컷에 클래스 이름 조건을 추가하기 위해 클래스 필터를 적용한 포인트컷을 작성한다.이를 위해 새로 만들어야 할 클래스는 하나뿐이며, 기존에 메서드 이름 패턴을 기준으로 포인트컷을 제공하는 NameMatchMethodPointcut을 상속한다.
 
- NameMatchMethodPointcut은 기본적으로 메서드 이름만 비교하지만, 여기에 ClassFilter를 추가로 구현하여 프로퍼티로 전달된 클래스 이름 패턴과 실제 클래스 이름을 비교하도록 확장한다.
 
- 즉,메서드 이름이 지정한 패턴과 일치하고, 클래스 이름이 지정한 패턴과 일치하는 경우에만 포인트컷이 적용되도록 만든다.
- 이 포인트컷 클래스는 학습 테스트에서 만들었던 포인트컷과 구조가 유사하며, 차이점은 클래스 필터 기능이 추가되었다는 점이다. 리스트 6-51은 이러한 클래스 필터 기능이 포함된 포인트컷의 예시를 보여준다.

### 어드바이저를 이용하는 자동 프록시 생성기 등록

- 적용할 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator는 등록된 빈 중에서 Advisor 인터페이스를 구현한 것을 모두 찾는다.
<br> 그리고 생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해보면서 프록시 적용 대상을 선정한다. 빈 클래스가 프록시 선정 대상이라면 프록시를 만들어 원래 빈 오브젝트와 바꿔치기한다.
<br> 원래 빈 오브젝트는 프록시 뒤에 연결돼서 프록시를 통해서만 접근 가능하게 바뀌는 것이다. 따라서 타깃 빈에 의존한다고 정의한 다른 빈들은 프록시 오브젝트를 대신 DI 받게 될 것이다.

<img width="628" height="72" alt="image" src="https://github.com/user-attachments/assets/a461586a-61fe-440b-b37f-94a4d4db36e3" />

- 이 빈 정의에는 특이하게도 id 애트리뷰트가 없고 class뿐이다. 다른 빈에서 참조되거나 코드에서 빈 이름으로 조회될 필요가 없는 빈이라면 아이디를 등록하지 않아도 무방하다.

### 포인트컷 등록

<img width="641" height="198" alt="image" src="https://github.com/user-attachments/assets/a265f18b-3a1a-4246-a2fa-cdb4ae877cf9" />

- 위 그림과 갘이 같이 기존의 포인트컷 설정을 삭제하고 새로 만든 클래스 필터 지원 포인트컷을 빈으로 등록한다. ServiceImpl로 이름이 끝나는 클래스와 upgrade로 시작하는 메소드를 선정해주는 포인트컷이다.

### 어드바이스와 어드바이저

- 어드바이스인 transactionAdvice 빈의 설정은 수정할 게 없다. 어드바이저인 transactionAdvisor 빈도 수정할 필요는 없다. 하지만 어드바이저로서 사용되는 방법이 바뀌었다.
- 이제는 ProxyFactoryBean으로 등록한 빈에서처럼 transactionAdvisor를 명시적으로 DI 하는 빈은 존재하지 않는다. 대신 어드바이저를 이용하는 자동 프록시 생성기인 DefaultAdvisorAutoProxyCreator에 의해 자동 수집되고, 프록시 대상 선정 과정에 참여하며, 자동 생성된 프록시에 다이내믹하게 DI 돼서 동작하는 어드바이저가 된다.

### Proxy Factory Bean 제거와 서비스 빈의 원상복구

- 프록시를 도입했던 때부터 아이디를 바꾸고 프록시에 DI 돼서 간접적으로 사용돼야 했던 userServiceImpl 빈의 아이디를 userService로 되돌려 놓는다. 더 이상 명시적인 프록시 팩토리 빈을 등록하지 않기 때문이다. 마지막으로 남았던 ProxyFactoryBean 타입의 빈은 삭제한다. 프록시를 적용하기 전의 단순한 상태다.

 <img width="623" height="180" alt="image" src="https://github.com/user-attachments/assets/82f7b364-3df6-473d-879a-7900f2bd060e" />
 
### 자동 프록시 생성기를 사용하는 테스트

- @Autowired를 통해 컨텍스트에서 가져오는 UserService 타입 오브젝트는 UserServiceImpl 오브젝트가 아니라 트랜잭션이 적용된 프록시여야 한다.
- 이를 검증하려면 upgradeAllOrNothing() 테스트가 필요한데, 기존의 테스트 코드에서 사용한 방법으로는 이제 한계가 있다. 지금까지는 ProxyFactoryBean이 빈으로 등록되어 있으므로 이를 가져와 타깃을 테스트용 클래스로 바꿔치기하는 방법을 사용했다.
- 하지만 자동 프록시 생성기를 적용한 후에는 더 이상 가져올 ProxyFactoryBean 같은 팩토리 빈이 존재하지 않는다. 자동 프록시 생성기가 알아서 프록시를 만들어줬기 때문에 프록시 오브젝트만 남아 있을 뿐이다.

- 그렇다면 어떻게 해야 할까? 지금까지는 어떻게든 설정파일에는 정상적인 경우의 빈 설정만을 두고 롤백을 일으키는 예외상황에 대한 테스트는 테스트 코드에서 빈을 가져와 수동 DI로 구성을 바꿔서 사용했다. 하지만 자동 프록시 생성기라는 스프링 컨테이너에 종속적인 기법을 사용했기 때문에 예외상황을 위한 테스트 대상도 빈으로 등록해줄 필요가 있다. 이제는 타깃을 코드에서 바꿔치기할 방법도 없을뿐더러, 자동 프록시 생성기의 적용이 되는지도 빈을 통해 확인할 필요가 있기 때문이다.

- 기존에 만들어서 사용하던 강제 예외 발생용 TestUserService 클래스를 이제는 직접 빈으로 등록해보자. 그런데 두 가지 문제가 있다. 첫째는 TestUserService가 UserServiceTest 클래스의 내부에 정의된 스태틱 클래스라는 점이고, 둘째는 포인트컷이 트랜잭션 어드바이스를 적용해주는 대상 클래스의 이름 패턴이 *ServiceImpl이라고 되어 있어서 TestUserService 클래스는 빈으로 등록을 해도 포인트컷이 프록시 적용 대상으로 선정해주지 않는다는 점이다.

- 두 가지 문제를 해결하기 위해 TestUserService 스태틱 멤버 클래스를 조금 수정하자.
- 클래스 이름은 포인트컷이 선정해줄 수 있도록 ServiceImpl로 끝나야 한다. 그래서 클래스 이름을 TestUserServiceImpl이라고 변경하자.

<img width="632" height="275" alt="image" src="https://github.com/user-attachments/assets/d94b3904-3482-42b8-8a7a-846ce9180217" />


- TestUserServiceImpl을 빈으로 등록하자. UserServiceImpl 클래스로 정의한 userService 빈은 그대로 둔 채로 밑의 그림과 같은 설정을 추가한다.

<img width="637" height="147" alt="image" src="https://github.com/user-attachments/assets/cf8d10b3-5b51-4fcf-a35d-4a85015f1585" />

- 특이점 두가지!
- 1. 여기서 하나는 클래스 이름에 사용한 $ 기호인데, 이는 스태틱 멤버 클래스를 지정할 때 사용하는 것이다. TestUserServiceImpl 클래스는 UserServiceTest의 스태틱 멤버 클래스이므로 $를 사용해서 클래스 이름을 지정해주면 된다. 특정 테스트 클래스에서만 사용되는 클래스는 스태틱 멤버 클래스로 정의하는 것이 편리하다. 원한다면 이렇게 스프링 빈으로 등록해서 사용할 수도 있다.
- 2. 또 한 가지 특이한 점은 parent 애트리뷰트다. <bean> 태그에 parent 애트리뷰트를 사용하면 다른 빈 설정의 내용을 상속받을 수 있다. TestUserServiceImpl은 UserServiceImpl을 상속받아서 만들었다. UserServiceImpl의 기능을 그대로 가져오고 일부 기능만 테스트에 맞게 수정해서 사용한 것이다. 마찬가지로 스프링에서는 빈의 설정도 상속받을 수 있다. parent="userService"라고 하면 userService 빈의 모든 설정을 그대로 가져와서 사용하겠다는 뜻이다. 클래스는 물론이고, 프로퍼티 설정도 모두 상속받는다. 물론 오버라이드도 가능하다. testUserService는 userService 빈의 설정을 상속받은 뒤 클래스만 변경했다. DI를 위한 프로퍼티 설정은 userService 빈의 프로퍼티를 그대로 상속받는다. 따라서 별도로 userDao나 mailSender 프로퍼티를 지정해줄 필요가 없다.

### 자동생성 프록시 확인

- 지금까지 트랜잭션 어드바이스를 적용한 프록시 자동생성기를 빈 후처리기 메커니즘을 통해 적용했는데 최소한 두 가지는 확인해야 한다.
- 1. 첫째는 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 적용됐는가이다. 트랜잭션이 정상적으로 커밋되는 경우에는 트랜잭션 적용 여부를 확인하기 힘들기 때문에 예외상황에서 트랜잭션이 롤백되게 함으로써 트랜잭션 적용 여부를 테스트해야 한다. 
 
- 2. 둘째는 아무 빈에나 트랜잭션이 부가기능이 적용된 것은 아닌지 확인해야 한다. 프록시 자동생성기가 어드바이저 빈에 연결해둔 포인트컷의 클래스 필터를 이용해서 정확히 원하는 빈에만 프록시를 생성했는지 확인이 필요하다. 즉 클래스 필터가 제대로 동작해서 프록시 생성 대상을 선별하고 있는지 여부를 알고 싶은 것이다.

- 포인트컷 빈의 클래스 이름 패턴을 변경해서 이번엔 testUserService 빈에 트랜잭션이 적용되지 않게 해본다. 이를 확인할 수 있다면 클래스 필터가 제대로 동작하고 있다는 최소한의 확신을 얻을 수 있다. 이 테스트를 제대로 하려면 전용 설정파일을 만들어 포인트컷을 재구성하는 등의 복잡한 과정이 필요할 텐데, 간단히 현재 테스트 설정파일을 수정해서 확인하고 다시 원상복구시키는 것으로 한다.

<img width="645" height="194" alt="image" src="https://github.com/user-attachments/assets/255befbb-9553-400f-bcdd-0bf8a236162d" />

- 테스트를 실행하면 트랜잭션 테스트인 upgradeAllOrNothing()만 실패해야 한다. 실패의 원인은 트랜잭션이 적용되지 않아서 예외가 발생하기 전에 수정한 내용이 롤백되지 않은 것이어야 한다. 이로써 적어도 포인트컷의 클래스 필터가 바르게 동작하고 있다고 확신할 수 있다.

- 또 다른 방법으로 자동생성된 프록시를 확인할 수 있다.
  
<img width="665" height="178" alt="image" src="https://github.com/user-attachments/assets/437b3be8-6b20-4008-9cc5-61e1dad26c41" />

-DefaultAdvisorAutoProxyCreator에 의해 userService 빈이 프록시로 바꿔치기됐다면 getBean("userService")로 가져온 오브젝트는 TestUserService 타입이 아니라 JDK의 Proxy 타입일 것이다. 모든 JDK 다이내믹 프록시 방식으로 만들어지는 프록시는 Proxy 클래스의 서브클래스이기 때문이다.


## 6.5.3 포인트컷 표현식을 이용한 포인트컷

- 포인트컷 표현식이란'어떤 클래스의 어떤 메서드에 AOP를 적용할지'를 문자열 규칙(표현식) 하나로 정하는 방법이다.


### 포인트컷 표현식

- 포인트컷 표현식을 지원하는 포인트컷을 적용하려면 AspectJExpressionPointcut 클래스를 사용하면 된다. Pointcut 인터페이스를 구현해야 하는 스프링의 포인트컷은 클래스 선정을 위한 클래스 필터와 메서드 선정을 위한 메서드 매처, 두 가지를 각각 제공해야 한다.
- 하지만 AspectJExpressionPointcut은 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식을 이용해 한 번에 지정할 수 있도록 해준다.

### 포인트컷 표현식 문법

- AspectJ 포인트컷 표현식은 포인트컷 지시자를 이용해 작성한다. 포인트컷 지시자 중 가장 대표적으로 사용되는 것은 execution()이다.

- <img width="619" height="169" alt="image" src="https://github.com/user-attachments/assets/b04d6d2c-7538-40cf-9486-bb92a640dadc" />

- public은 접근제한자 패턴이다. public, protected, private 등을 사용할 수 있으며, 포인트컷 표현식에서는 생략할 수 있다. 생략하면 접근제한자에 대한 조건을 부여하지 않는다는 의미다.

- int는 리턴 값의 타입 패턴이다. 리턴 타입 패턴은 필수 항목이며 반드시 하나를 지정해야 한다. *를 사용하면 모든 리턴 타입을 허용할 수 있다. 이 항목은 생략할 수 없다.


- springbook.learningtest.spring.pointcut.Target는 패키지 이름과 클래스 이름을 포함한 타입 패턴이다. 역시 생략 가능하며, 생략하면 모든 타입을 허용한다. 패키지나 클래스 이름에는 *를 사용할 수 있고, ..을 사용하면 여러 패키지를 한 번에 지정할 수 있다.

- minus는 메소드 이름 패턴이다. 메소드 이름 패턴은 필수 항목이며 반드시 지정해야 한다. 모든 메소드를 선택하려면 *를 사용하면 된다.

- (int, int)는 메소드 파라미터 타입 패턴이다. 파라미터 타입을 ,로 구분해 순서대로 지정한다. 파라미터가 없는 메소드는 ()로 표현한다. 파라미터 타입과 개수에 상관없이 모두 허용하려면 (..)을 사용한다. 이 항목 역시 필수다.

- throws java.lang.RuntimeException은 예외 타입 패턴이다. 생략 가능하며, 특정 예외를 던지는 메소드만 선택하고 싶을 때 사용한다.

- AspectJExpressionPointcut 객체를 생성하고 포인트컷 표현식을 expression 프로퍼티에 설정하면 포인트컷을 사용할 준비가 완료된다. 포인트컷은 내부적으로 클래스 필터와 메소드 매처를 사용해 대상 클래스와 메소드를 각각 비교한다. 두 조건을 모두 만족해야 포인트컷 적용 대상이 된다.

- Target 클래스의 minus 메소드는 클래스 조건과 메소드 조건을 모두 만족하므로 포인트컷 적용 결과는 true가 된다. 반면 plus 메소드는 메소드 이름 패턴이 일치하지 않으므로 false가 된다. Bean 클래스의 method 메소드는 클래스 조건부터 일치하지 않으므로 역시 false가 된다.

### 포인트컷 표현식 테스트

- 메소드 시그니처를 그대로 사용한 포인트컷 표현식을 문법구조를 참고로 해서 정리해보자. 이 중에서 필수가 아닌 항목인 접근제한자 패턴, 클래스 타입 패턴, 예외 패턴은 생략할 수 있다. 옵션 항목을 생략하면 다음과 같이 간단하게 만들 수 있다.

- <img width="597" height="55" alt="image" src="https://github.com/user-attachments/assets/43711a14-41e3-4914-8b43-045cd47ccc0f" />

(이하 생략)

### 포인트컷 표현식을 이용하는 포인트컷 적용

- AspectJ 포인트컷 표현식은 메소드를 선정하는 데 매우 편리하게 사용할 수 있는 강력한 표현식 언어다. 아직 설명하지 않은 다양한 문법과 활용 방법이 많이 있으며, 포인트컷 표현식은 메소드의 시그니처를 비교하는 방식인 execution() 외에도 몇 가지 표현식 스타일을 가지고 있다. 대표적으로 스프링에서 사용될 때 빈의 이름으로 비교하는 bean() 표현식이 있다.

- 또한 특정 애노테이션이 타입, 메소드, 파라미터에 적용되어 있는지를 기준으로 메소드를 선정하는 포인트컷도 만들 수 있다. 아래와 같이 작성하면 @Transactional 애노테이션이 적용된 메소드를 선정하게 된다.

<img width="552" height="50" alt="image" src="https://github.com/user-attachments/assets/c3293510-b7d0-4ed1-b689-9268d884f6a4" />

- 클래스 이름은 ServiceImpl로 끝나고, 메소드 이름은 upgrade로 시작하는 모든 메소드에 적용되도록 하는 표현식은 다음과 같다.

<img width="665" height="191" alt="image" src="https://github.com/user-attachments/assets/26cc5126-040c-4397-b595-ec026327c8b1" />

- 포인트컷 표현식을 사용하면 로직이 짧은 문자열에 담기기 때문에 클래스나 코드를 추가할 필요가 없어 코드와 설정이 모두 단순해진다. 반면 문자열로 된 표현식이기 때문에 런타임 시점까지 문법 검증이나 기능 확인이 되지 않는다는 단점도 있다.

- 또한 눈에 보이지 않는 백그라운드 작업을 수행하는 자동 프록시 생성기와 맞물려 동작하기 때문에 결과를 확인하기도 쉽지 않다. 표현식까지 사용하면 실수할 가능성은 더 높아진다.

- 하지만 포인트컷 표현식을 사용함으로써 얻을 수 있는 장점이 많은 만큼, 충분히 시간을 투자해 학습하고 다양한 테스트를 미리 만들어서 검증된 표현식을 가져다 사용하는 것이 중요하다.

- 포인트컷 표현식을 이용하는 포인트컷이 정확히 원하는 빈만 선정했는지를 확인하는 일은 만만치 않다. 테스트를 만들면 가능은 하지만 상당히 번거롭다. 다행히 Vol.2에서 자세히 소개하겠지만, 스프링 개발팀이 제공하는 스프링 지원 툴을 사용하면 포인트컷이 선정한 빈이 어떤 것인지 한눈에 확인할 수 있는 방법이 있다.


### 타입 패턴과 클래스 이름 패턴

- 포인트컷 표현식은 변함없이 

<img width="318" height="29" alt="image" src="https://github.com/user-attachments/assets/b42d7c09-00c1-4db9-85e6-08ac85b9f08b" />

로 되어 있는데 어떻게 TestUserService 클래스로 등록된 빈이 선정됐을까?

- 그 이유는 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 클래스 이름 패턴이 아니라 타입 패턴이기 때문이다. TestUserService의 클래스 이름은 TestUserService일 뿐이지만, 타입을 따져보면 TestUserService 클래스이자, 슈퍼클래스인 UserServiceImpl, 구현 인터페이스인 UserService 세 가지가 모두 적용된다. 즉 TestUserService 클래스로 정의된 빈은 UserServiceImpl 타입이기도 하고, 그 때문에 ServiceImpl로 끝나는 타입 패턴의 조건을 충족하는 것이다.

- TargetInterface 인터페이스를 표현식에 사용했을 때 Target 클래스의 오브젝트가 포인트컷에 의해 선정된 것과 마찬가지다. Target은 TargetInterface를 구현했기 때문에 Target 클래스의 오브젝트는 TargetInterface 타입이기도 하다.

- 포인트컷 표현식의 타입 패턴 항목을 *..UserService라고 직접 인터페이스 이름을 명시해도 두 개의 빈이 모두 선정된다. 두 클래스 모두 UserService 인터페이스를 구현하고 있기 때문이다. 여러 가지 변화가 가능하겠지만, 포인트컷 표현식의 타입 패턴은 그대로 *..*ServiceImpl로 남겨두자.

- 포인트컷 표현식에서 타입 패턴이라고 명시된 부분은 모두 동일한 원리가 적용된다






















  






