# 스프링의 프록시 팩토리 빈

## ProxyFactoryBean

스프링은 JDK 다이내믹 프록시 외에도 다양한 프록시 생성 기술이 존재하기 때문에, 이를 일관된 방법으로 사용할 수 있도록 추상 레이어를 제공.

이를 통해 개발자는 구체적인 프록시 기술에 상관없이 동일한 방식으로 프록시를 생성하고 빈으로 등록 가능.

ProxyFactoryBean은 오직 프록시를 생성하는 작업만을 담당.

부가 기능 로직을 직접 품고 있던 기존 방식(ex : TxProxyFactoryBean)과 달리, 부가 기능을 별도의 빈으로 분리하여 관리할 수 있게 해줌.

MethodInterceptor와 InvocationHandler는 비슷하지만 차이점이 존재.

가장 핵심적인 차이는 타깃 오브젝트 정보의 포함 여부.

InvocationHandler의 경우 구현 클래스가 타깃 정보를 직접 알고 있어야 하고, 타깃에 종속적이며, 타깃마다 새로운 오브젝트 생성이 필요.

하지만 MethodInterceptor의 경우 MethodInvocation 파라미터를 통해 타깃 정보를 제공받고, 타깃에 상관없이 독립적이며 싱글톤 빈으로 등록하여 여러 프록시에서 공유 가능함.

<img width="588" height="478" alt="image" src="https://github.com/user-attachments/assets/b9029c88-4132-4bdf-863d-55dbb51baf42" />

<img width="582" height="551" alt="image" src="https://github.com/user-attachments/assets/926699d1-dd22-402b-9021-bf3ec6dcc7d1" />

### 어드바이스 : 타깃이 필요 없는 순수한 부가 기능

MethodInterceptor를 구현한 어드바이스에는 InvocationHandler와 달리 타깃 오브젝트가 직접 등장하지 않음.

MethodInterceptor 오브젝트가 메소드 정보와 타깃 오브젝트를 함께 전달해주며, proceed() 메소드로 타깃의 메소드를 실행하는 콜백 역할을 함.

MethodInterceptor 은 공유 가능한 템플릿처럼 동작하며, 이를 통해 어드바이스를 싱글톤으로 두고 여러 타깃에서 공유할 수 있음.

ProxyFactoryBean은 addAdvice() 통해 여러 개의 어드바이스를 추가할 수 있어, 부가기능이 늘어나도 프록시 팩토리 빈을 추가할 필요가 없음.

스프링에서는 타깃 오브젝트에 적용하는 부가기능을 담은 오브젝트를 어드바이스라고 부름

ProxyFactoryBean은 인터페이스 자동 검출 기능을 통해 타깃이 구현한 인터페이스 정보를 알아내고 이를 구현하는 프록시를 만들어줌.

인터페이스를 직접 지정하지 않아도 타깃 오브젝트가 구현하고 있는 모든 인터페이스를 동일하게 구현하는 프록시 생성이 가능함.

상황에 따라 JDK 다이내믹 프록시뿐만 아니라 CGLib을 이용해 프록시를 생성하는 등 프록시 생성 기술을 추상화하여 제공함.

### 포인트 컷 : 부가 기능 적용 대상 메소드 선정 방법

기존 InvocationHandler 방식은 부가기능 제공과 함께 메소드 이름을 기준으로 트랜잭션 적용 대상을 직접 판단하고 있음.

이 판단 로직은 메소드 이름 패턴과 결합돼 있고, InvocationHandler는 타깃 오브젝트를 직접 알고 있음.

그 결과 InvocationHandler는 타깃과 메소드 선정 방식에 종속됨.

타깃이나 메소드 선정 기준이 달라지면 InvocationHandler를 공유할 수 없음.

그래서 프록시마다 InvocationHandler를 새로 생성해야 하는 구조임.

확장이 필요하면 팩토리 빈 내부의 프록시 생성 코드가 함께 변경됨.

ProxyFactoryBean과 MethodInterceptor 방식에서는 이 구조가 문제가 됨.

MethodInterceptor는 여러 프록시에서 공유되는 전제로 설계돼 있음.

이를 위해 MethodInterceptor는 타깃 정보를 가지지 않도록 설계됨.

따라서 특정 프록시에만 적용되는 메소드 이름 패턴을 내부에 둘 수 없음.

메소드 선정 로직을 MethodInterceptor에 넣으면 공유 구조가 깨짐.

이 문제는 MethodInterceptor를 프록시마다 따로 만드는 방식으로 해결하지 않음.

성격이 다른 책임을 분리하는 방식으로 해결함.

부가기능 제공 로직은 MethodInterceptor에 남김.

부가기능 적용 대상 메소드를 고르는 판단은 별도의 객체로 분리함.

메소드 선정 로직은 교체 가능한 알고리즘이므로 전략 패턴으로 분리됨.

<img width="608" height="203" alt="image" src="https://github.com/user-attachments/assets/cb3ab6e3-2fb1-490b-8604-6b20fd4a7166" />

스프링은 부가기능 제공 객체를 Advice라고 부름.

메소드 선정 알고리즘을 담은 객체를 포인트 컷이라고 부름.

Advice와 Pointcut은 프록시에 DI로 주입됨.

두 객체 모두 여러 프록시에서 공유 가능하도록 설계됨.

프록시는 요청을 받으면 먼저 Pointcut에게 해당 메소드가 부가기능 적용 대상인지 판단 요청함.

포인트 컷이 적용 대상이라고 판단하면 Advice를 호출함.

Advice는 타깃 메소드를 직접 호출하지 않음.

타깃 호출은 MethodInvocation 콜백의 proceed()를 통해 위임됨.

Advice는 템플릿 역할을 하고 MethodInvocation은 콜백 역할을 수행함.

여러 Advice와 여러 포인트 컷이 함께 사용될 수 있기 때문에 둘을 묶는 개념이 필요함.

이 조합 단위를 Advisor라고 부름.

Advisor는 어떤 포인트 컷이 어떤 Advice에 적용되는지를 명확히 정의함.

결과적으로 프록시와 팩토리 빈 수정 없이 부가기능과 메소드 선정 방식을 확장 가능함.

## ProxyFactoryBean 적용

### TransactionAdvice

MethodInterceptor를 구현한 어드바이스로, 기존 TransactionHandler에서 타깃 정보와 메소드 선정 로직을 제거하고 트랜잭션 처리라는 부가기능만 담당함

<img width="596" height="591" alt="image" src="https://github.com/user-attachments/assets/09e1c1ab-2192-468b-af3c-7b7c3c834a04" />

MethodInterceptor를 사용하면 JDK 다이내믹 프록시보다 코드가 간결해지고, MethodInvocation 콜백 덕분에 리플렉션 호출과 예외 언래핑 처리가 불필요해짐.

### 어드바이스와 포인트 컷의 재사용

ProxyFactoryBean은 DI, 템플릿/콜백 패턴, 서비스 추상화가 모두 적용됨.
프록시 생성 책임만 담당하도록 역할 제한됨.

트랜잭션 부가기능은 TransactionAdvice로 분리됨
어드바이스는 타깃과 무관하게 설계됨.
싱글톤 빈으로 등록 가능함.
여러 프록시에서 공유됨.

새로운 서비스 클래스가 추가돼도 기존 TransactionAdvice 그대로 재사용 가능함.
트랜잭션 적용 여부는 포인트컷에서 판단함.
메소드 이름 패턴만 지정해 ProxyFactoryBean에 등록함.

일관된 메소드 명명 규칙이 있으면 하나의 포인트컷으로 관리 가능함.
메소드 선정 방식이 달라질 경우 포인트컷만 분리해 어드바이저로 조합함

하나의 TransactionAdvice를 여러 서비스 프록시에 적용 가능함.
구조 변경 없이 설정만으로 확장 가능함.

<img width="646" height="332" alt="image" src="https://github.com/user-attachments/assets/332dada0-2de7-49f3-9c12-018346d2b15b" />

# 스프링 AOP

트랜잭션 코드는 핵심 로직과 분리된 부가기능 형태로 제공됨.

부가기능은 기존 설계와 코드에 영향을 주지 않도록 투명하게 적용됨.

외형상 보이지 않지만 메소드 호출 과정에 동적으로 개입함.

필요에 따라 자유롭게 추가·제거 가능함.

기존 비즈니스 코드는 항상 원래 상태를 유지함.

DI를 활용한 대표적인 응용 사례임.

## 자동 프록시 생성

투명한 부가기능 적용 과정에서 대부분의 구조적 문제는 해결됨.
타깃 코드는 여전히 깔끔하게 유지됨.
부가기능은 한 번만 구현해 모든 타깃과 메소드에 재사용 가능해짐.
메소드 선정 로직도 포인트컷으로 분리돼 독립적으로 관리 가능해짐

기존에 문제로 인식됐던 두 가지 한계 중, 부가기ㄴ으이 타깃마다 새로 생성되던 문제는 어드바이스 도입으로 해결됨.

남은 문제는 ProxyFactoryBean 설정의 중복임.
타깃 오브젝트마다 거의 동일한 ProxyFactoryBean 설정을 반복 작성해야 함.
코드 수정은 사라졌지만 설정 복사·수정 작업은 계속 필요함.
target 프로퍼티를 제외하면 설정 내용은 거의 동일함.
이런 형태의 설정 중복을 더 줄일 방법이 필요한 상태임.

### 중복 문제의 접근 방법

JDBC DAO 코드에서는 try/catch/finally가 메소드마다 반복됐음.

변하지 않는 부분과 변하는 부분을 분리함.

템플릿/콜백 구조로 재구성함.

전략 패턴과 DI 적용으로 문제 해결.

프록시 클래스의 경우는 성격이 달랐음.

모든 인터페이스 메소드에 위임 코드와 부가기능 코드가 반복됐음.

단순 분리와 DI만으로는 해결이 어려웠음.

런타임 코드 자동생성 기법인 다이내믹 프록시를 사용함.

다이내믹 프록시는 인터페이스만 제공하면 모든 메소드를 구현한 프록시 클래스를 런타임에 자동 새ㅅ엉함.

개발자가 프록시 클래스를 직접 작성할 필요가 없어짐.

변하지 않는 위임 구조와 호출 흐름은 다이내믹 프록시에 맡김.

변하는 부가기능 로직만 별도로 구현함.

부가기능은 DI를 통해 프록시 생성 과정에 주입되고 의미 있는 로직인 트랜잭션 경계설정은 코드로 남김.

기계적인 코드인 인터페이스 구현과 위임은 자동 생성됨.

변하는 것과 변하지 않는 것을 명확히 분리한 구조.

이제 남은 문제는 ProxyFactoryBean 설정의 반복.

프록시 메소드 구현은 자동화했지만 설정은 여전히 수동임.

타깃 빈마다 ProxyFactoryBean 설정을 반복 추가해야 함.

프록시 자체가 실제 빈이므로 프록시를 자동으로 빈으로 등록할 수 없는지 고민하게 됨.

타깃 빈 목록만 주어지면 각 타깃에 대한 프록시를 자동 생성하는 방식이 필요해짐.

하지만 지금까지의 방식으로는 여러 빈에 프록시를 일괄 적용하는 방법은 존재하지 않음.

### 빈 후처리기를 이용한 자동 프록시 생성기

스프링은 OCP의 핵심인 유연한 확장 개념을 컨테이너 자체에도 적용함.

애플리케이션 코드가 OCP를 따르도록 돕는 것에 그치지 않고, 컨테이너 기능 자체도 확장 가능하게 설계됨.

변하지 않는 핵심을 제외한 대부분의 기능에 확장 포인트를 제공함.

대표적인 확장 포인트가 BeanPostProcessor.

빈 후처리기는 스프링 빈이 생성된 이후 시점에 개입하여 생성된 빈 오브젝트를 다시 가공할 수 있고 프로퍼티 수정 가능.

추가 초기화 작업 수행 가능. 

필요하면 빈 오브젝트 자체를 다른 오브젝트로 교체 가능.

이 구조를 이용하면 스프링이 생성한 빈 대신 프록시를 빈으로 등록하는 것도 가능.

이 역할을 수행하는 것이 자동 프록시 생성 빈 후처리기.

DefaultAdvisorAutoProxyCreator는 어드바이저 기반의 자동 프록시 생성기.

빈 후처리기 자체를 빈으로 등록하는 것만으로 적용됨.

빈이 생성될 때마다 스프링은 해당 빈을 DefaultAdvisorAutoProxyCreator에게 전달함.

후처리기는 등록된 모든 어드바이저의 포인트컷을 기준으로 판단.

전달받은 빈이 프록시 적용 대상인지 검사.

프록시 적용 대상이면 내부 프록시 생성기를 통해 프록시를 생성하고 해당 프록시에 어드바이저를 연결.

이후 원래 생성된 빈 대신 프록시 오브젝트를 컨테이너에 반환.

컨테이너는 반환된 프록시를 최종 빈으로 등록.

결과적으로 클라이언트는 원래 빈이 아닌 프록시 빈을 사용하게 됨.

<img width="594" height="161" alt="image" src="https://github.com/user-attachments/assets/9055b145-3ea6-4b7f-bada-49bbd605ca11" />

적용 댓아 빈을 판단하는 로직이 포함된 포인트 컷을 어드바이저로 등록하면 자동 프록시 생성이 가능.

빈 후처리기를 사용해 ProxyFactoryBean을 개별로 등록할 필요가 없어짐. 

타깃 오브젝트에 프록시가 자동 적용되고 반복적이던 ProxyFactoryBean 설정 문제를 근본적으로 해결.

### 확장된 포인트 컷

겉으로 보면 포인트컷이 빈 자체를 선택하는 것처럼 보임.

하지만 포인트컷이 빈을 직접 선택하는 기능을 가진 것은 아님.

포인트컷은 원래 메소드 단위의 부가기능 적용 여부를 판단함.

다만 포인트컷 내부에는 두 단계의 선별 로직이 존재.

포인트컷은

- 클래스 필터(ClassFilter)를 가짐
- 메소드 매처(MethodMatcher)를 가짐

클래스 필터는 해당 빈의 클래스가 적용 대상인지 판단하고 메소드 매처는 그 클래스의 어떤 메소드에 적용할지 판단.

자동 프록시 생성 과정에서는 클래스 필터 단계가 먼저 사용.

클래스 필터를 통과한 빈만 프록시 후보가 됨.

그래서 결과적으로 포인트컷이 빈을 선택하는 것처럼 보이는 현상이 발생.

실제로는 클래스 → 메소드 순으로 적용 대상을 좁혀가는 구조.

<img width="596" height="159" alt="image" src="https://github.com/user-attachments/assets/0bae757c-9568-4bbe-9d0b-1729014b6a25" />

지금까지는 포인트컷 기능 중 메소드 선별만 사용해왔음.

NameMatchMethodPointcut은 메소드 매처만 가진 포인트컷이고, 클래스 필터는 모든 클래스를 허용.

ProxyFactoryBean에서는 타깃이 이미 정해져 있으므로 메소드 선별만으로 충분했음.

포인트컷의 전체 기능을 쓰면 먼저 클래스 필터로 프록시 적용 대상 클래스인지 판단하고, 그 다음 메소드 매처로 적용할 메소드를 판단.

클래스 단계에서 제외되면 해당 빈에는 어드바이스가 전혀 적용되지 않음.

모든 빈을 대상으로 자동 프록시 적용 여부를 판단해야 하는 DefaultAdvisorAutoProxyCreator에서는 클래스와 메소드 선별을 모두 포함한 포인트컷, 정확히는 포인트컷과 어드바이스가 결합된 어드바이저가 필요.

## DefaultAdvisorAutoProxyCreator의 적용

### 클래스 필터를 적용한 포인트 컷 작성

기존 메소드 이름만 비교하던 포인트 컷인 NameMatchMethodPointcut을 상속.

메소드 이름 비교 기능은 그대로 사용.

클래스 이름을 비교하는 ClassFilter를 추가 구현.

프로퍼티로 전달된 이름 패턴으로 클래스 적용 여부를 판단.

<img width="578" height="502" alt="image" src="https://github.com/user-attachments/assets/9d9bdf20-64a7-4364-a72c-61bd614c3d66" />

### 어드바이저를 이용하는 자동 프록시 생성기 등록

DefaultAdvisorAutoProxyCreator는 등록된 빈 중 Advisor를 구현한 빈을 모두 탐색.

생성되는 모든 빈에 대해 어드바이저의 포인트컷을 적용해 프록시 대상 여부를 판단.

적용 대상이면 프록시를 생성해 원래 빈과 교체.

타깃 빈은 프록시 뒤에 연결되고, 다른 빈들은 프록시를 DI 받게 됨.

<img width="559" height="51" alt="image" src="https://github.com/user-attachments/assets/2be07a99-2ac6-43fd-af6c-bcd0714f9357" />

이 빈 정의에는 특이하게도 id 어트리뷰트가 없고 class 뿐임.

다른 빈에서 참조되거나 코드에서 이름으로 조회될 필요가 없는 빈이라면 아이디를 등록하지 않아도 상관 x.

기존의 포인트 컷 설정을 삭제하고 새로 만든 클래스 필터 지원 포인트 컷을 빈으로 등록.

ServiceImpl로 이름이 끝나는 클래스와 upgrade로 시작하는 메소드를 선정해주는 포인트 컷.

<img width="589" height="168" alt="image" src="https://github.com/user-attachments/assets/dc0edac4-52b1-476e-ac91-de1043103bfb" />

### 어드바이스와 어드바이저

transactionAdvice와 transactionAdvisor 빈 설정은 변경 없지만 어드바이저의 사용 방식이 달라짐.

이제 ProxyFactoryBean에서 명시적으로 DI 하지 않고 DefaultAdvisorAutoProxyCreator에 의해 자동 수집되고 프록시 대상 선정 과정에 참여.

자동 생성된 프록시에 동적으로 DI 되어 동작.

### ProxyFactoryBean 제거와 서비스 빈의 원상복구

프록시 도입 때문에 변경했던 userServiceImpl 빈 아이디를 다시 userService로 복구.

명시적인 ProxyFactoryBean을 더 이상 등록하지 않음.

남아 있던 ProxyFactoryBean 타입 빈은 제거 가능.

UserService 관련 설정은 userservice 빈 하나로 충분해짐.

<img width="587" height="143" alt="image" src="https://github.com/user-attachments/assets/3885bb72-ec19-4799-98ae-2bc830ede38a" />

프록시를 적용하기 전의 단순한 상태로 돌아옴.

### 자동 생성 프록시 확인

테스트는 모두 성공했지만 자동 프록시 생성이 실제로 동작하는지 직접 확인할 필요가 있음.

자동으로 동작하는 기능일수록 오동작 시 원인 파악이 어려움.

확인해야 할 사항은 두 가지임.

첫째, 트랜잭션이 필요한 빈에 트랜잭션 부가기능이 실제로 적용됐는가.

정상 커밋 상황에서는 확인이 어려우므로 예외 발생 시 롤백 여부로 검증.

upgradeAllOrNothing() 테스트로 이미 검증 완료.

둘째, 트랜잭션이 필요 없는 빈에까지 적용되지는 않았는가.

자동 프록시 생성기가 포인트컷의 클래스 필터를 기준으로 정확히 선별했는지 확인 필요.

모든 빈을 검사하지 않고 클래스 필터 동작 여부만 간단히 검증.

포인트컷의 클래스 이름 패턴을 변경해 testUserService 가 적용 대상에서 제외되는지 확인.

이를 통해 클래스 필터가 프록시 생성 대상을 제대로 선별하고 있다는 최소한의 확신을 얻음.

<img width="586" height="165" alt="image" src="https://github.com/user-attachments/assets/d7a3455e-9051-4ed8-b24b-a0986b0600a4" />

테스트 실행 시 upgradeAllOrNothing()만 실패해야 함.

실패 원인은 트랜잭션 미적용으로 예외 발생 전 변경 내용이 롤백되지 않은 상태여야 함.

이를 통해 포인트컷의 클래스 필터가 정상 동작함을 확인.

실패 테스트를 유지할 수 없으므로 포인트컷 설정은 다시 원상 복구.

모든 테스트가 다시 성공하도록 함.

프록시 적용 여부를 확인하는 다른 방법도 있음.

DefaultAdvisorAutoProxyCreator에 의해 userservice 빈이 프록시로 교체되었다면

getBean(”userservice”) 로 가져온 객체는 실제 구현체가 아님.

JDK 다이내믹 프록시로 생성된 객체는 Proxy 타입의 서브클래스.

포인트컷 설정을 원래대로 둔 상태에서 컨테이너가 반환한 서비스 빈의 타입을 검사하는 코드를 테스트에 추가.

<img width="591" height="141" alt="image" src="https://github.com/user-attachments/assets/6f31c100-d974-445b-b9b7-93b120dd2a4d" />

## 포인트 컷 표현식을 이용한 포인트 컷

지금까지는 클래스 이름과 메소드 이름을 각각 필터와 매처로 비교해 포인트컷을 작성.

조건이 복잡해질수록 리플렉션 기반 구현은 번거롭고 유지보수가 어려워짐.

스프링은 이를 해결하기 위해 표현식 기반으로 클래스·메소드를 선정하는 포인트컷 표현식(pointcut expression) 방식을 제공.

### 포인트 컷 표현식

포인트컷 표현식을 지원하는 포인트컷을 사용하려면 AspectJExpressionPointcut을 사용.

스프링의 포인트컷은 기본적으로 클래스 필터와 메소드 매처를 각각 제공해야 함.

기존에 사용한 NameMatchClassMethodPointcut은 클래스 이름 패턴과 메소드 이름 패턴을 서로 분리해서 비교하는 방식.

그래서 클래스용 패턴과 메소드용 패턴을 각각 프로퍼티로 설정해야 했지만 AspectJExpressionPointcut은 이 과정을 단순화함.

클래스 선정과 메소드 선정을 하나의 표현식으로 동시에 지정.

복잡한 조건도 문자열 기반 표현식으로 간결하게 작성 가능.

이 표현식은 AspectJ 프레임워크의 포인트컷 표현식을 기반으로 함.

스프링은 이를 가져와 일부 문법을 확장해 사용.

그래서 이를 AspectJ 포인트컷 표현식이라고 부름.

<img width="593" height="258" alt="image" src="https://github.com/user-attachments/assets/f80a09c3-1b0d-4bb3-ad9b-1df621cfc6c9" />

Target 클래스는 총 5개의 메소드를 가짐.

앞의 4개 메소드는 TargetInterface에 정의된 메소드를 구현한 것.

마지막 메소드는 Target 클래스에만 정의된 메소드.

포인트컷 표현식을 이용해 이 중 원하는 메소드만 선별하는 방법을 확인.

클래스 선정 조건까지 함께 테스트하기 위해 비교 대상이 될 다른 클래스 하나를 추가로 준비.

<img width="586" height="188" alt="image" src="https://github.com/user-attachments/assets/a5c79bbd-63b4-4862-8e2c-ca0814524d66" />

### 포인트 컷 표현식 문법

AspectJ 포인트컷 표현식은 포인트컷 지시자를 사용해 작성함.

가장 대표적으로 사용하는 지시자는 execution().

execution() 포인트컷 표현식은 정해진 문법 구조를 가짐.

옵션 항목은 생략 가능하고 여러 조건은 OR( || )로 결합 가능.

<img width="566" height="154" alt="image" src="https://github.com/user-attachments/assets/f7953603-05ed-46a7-85d9-49bd55e3927b" />

처음엔 복잡해 보이지만 메소드의 풀 시그니처를 문자열로 매칭하는 개념으로 보면 됨.

리플렉션으로 Target.minus() 메소드의 풀 시그니처를 확인하면 이해가 쉬움.

Method 객체가 제공하는 시그니처 정보를 기준으로 포인트컷이 비교됨.

<img width="512" height="45" alt="image" src="https://github.com/user-attachments/assets/6c167058-f60e-4401-bcaf-ab5c565aadfa" />

<img width="541" height="55" alt="image" src="https://github.com/user-attachments/assets/dee05aba-76b4-4609-a752-7634a4158b0c" />

- public : 접근제한자를 의미. public, protected, private 등이 올 수 있고, 포인트 컷 표현식에서는 생략 가능.
- int : 리턴 값의 타입을 지정하는 패턴임. 포인트컷 표현식에서 필수 항목. 반드시 하나의 타입을 지정해야 함. * 를 사용해 모든 리턴 타입을 허용 가능. 생략은 불가능.
- [springbook.learningtest.spring.pointcut.Target](http://springbook.learningtest.spring.pointcut.Target) : 패키지와 클래스 또는 인터페이스 이름을 포함한 타입 패턴. 생략 가능하며, 생략 시 모든 타입을 허용. 뒤의 메소드 이름 패턴과 .으로 연결되므로 구분이 필요. 패키지나 타입 이름에 * 사용 가능함. ..를 사용하면 여러 패키지를 한 번에 지정 가능.
- minus : 메소드 이름 패턴. 필수 항목이므로 반드시 작성 필요. 모든 메소드를 다 선택하는 경우 *.
- (int, int) : 메소드 파라미터의 타입을 지정하는 패턴. 파라미터 타입을 순서대로 , 로 구분해 작성함. 파라미터가 없으면 () 로 지정. 타입과 개수에 상관없이 허용하려면 (..) 을 사용. ... 을 사용해 뒷부분 파라미터 조건만 생략할 수도 있음. 필수 항목이므로 반드시 지정.
- thorws java.lang.RuntimeException : 예외 이름에 대한 타입 패턴으로 생략 가능.

포인트컷 표현식은 Method 객체가 제공하는 메소드 시그니처 구조와 동일하게 비교. 

Target.minus() 메소드만 선택하는 포인트컷 표현식을 작성.

이를 검증하기 위해 PointcutExpressionTest 테스트 클래스를 추가.

<img width="586" height="404" alt="image" src="https://github.com/user-attachments/assets/2f250286-4bff-42cf-ba58-85965950d868" />

<img width="605" height="222" alt="image" src="https://github.com/user-attachments/assets/d59fdd9e-6940-45ed-b04a-282b92fd24d7" />

AspectJExpressionPointcut 객체를 생성하고 expression 프로퍼티에 포인트컷 표현식을 설정하면 사용 준비 완료.

포인트컷 표현식은 execution() 안에 메소드 시그니처 형태로 작성.

execution() 은 메소드 실행 시점을 대상으로 하는 포인트컷을 의미.

먼저 Target.minus() 메소드로 테스트.

클래스 필터와 메소드 매처 조건이 모두 일치하므로 결과는 true.

Target의 다른 메소드는 클래스와 파라미터는 일치하지만 메소드 이름이나 예외 패턴이 맞지 않아 결과는 false.

Bean.class 의 메소드는 클래스 단계부터 일치하지 않으므로 포인트컷 적용 결과는 false.

### 포인트 컷 표현식 테스트

메소드 시그니처를 그대로 사용해 포인트컷 표현식을 구성 가능.

접근제한자, 클래스 타입, 예외 패턴은 옵션이므로 생략 가능.

필수 항목만 남기면 포인트컷 표현식을 훨씬 간단하게 작성 가능능.

<img width="564" height="54" alt="image" src="https://github.com/user-attachments/assets/221c4b4d-ea44-4b64-9562-6ead3ebf7110" />

옵션 항목을 생략해 표현식이 간결해짐.

다만 생략된 항목은 모두 허용 조건으로 처리.

접근제한자, 클래스, 예외와 무관하게 조건이 적용.

결과적으로 정수형 두 개의 파라미터를 받고 minus 라는 이름을 가진 메소드를 모두 선정.

리턴 타입 제한을 없애려면 * 와일드카드를 사용하면 됨.

<img width="575" height="56" alt="image" src="https://github.com/user-attachments/assets/83f374f6-96b9-4721-81b5-7de5176bb34b" />

파라미터의 개수와 티입을 무시하려면 () 안에 .. 을 사용.

S<img width="560" height="54" alt="image" src="https://github.com/user-attachments/assets/2cd07295-e3d5-47ec-a6d0-6914a9314954" />

만약 모든 선정 조건을 다 없애고 모든 메소드를 허용하느 ㄴ포인트 컷이 필요한 경우에는 메소드 이름도 와일드 카드로 바꾸면 됨.

<img width="539" height="49" alt="image" src="https://github.com/user-attachments/assets/e94a30ce-b7a1-4c9b-b613-6d246f90191f" />

다양한 활용을 확인하기 위해 테스트를 보강함.

앞에서 만든 Target, Bean 클래스의 여러 메소드에 포인트컷을 적용해 결과를 검증함.

주어진 포인트컷으로 특정 메소드가 선택되는지 확인하는 테트 메소드를 추가함.

이를 위해 클래스, 메소드 이름, 파라미터 타입 정보를 지정해 메소드를 선택함.

<img width="580" height="254" alt="image" src="https://github.com/user-attachments/assets/e5034b96-ee4e-476b-accc-6594f55a5ab9" />

pointcutMatches() 메소드 활용하여 타깃으로 만든 두 클래스의 모든 메소드에 대해 포인트컷 적용 여부를 확인함.

포인트컷 표현식과 각 메소드의 예상 결과를 전달해 검증함.

<img width="594" height="257" alt="image" src="https://github.com/user-attachments/assets/530c93ff-e99b-48b9-963e-612c53ee2a53" />

이제 다양한 포인트 컷을 만들어 모든 메소드에 대한 포인트 컷 적용 결과를 확인.

<img width="600" height="149" alt="image" src="https://github.com/user-attachments/assets/3caf3e88-5f18-4967-9b9c-da839db416e1" />

<img width="589" height="742" alt="image" src="https://github.com/user-attachments/assets/0dd493cd-e3fa-4024-8145-fbee4fa5f05b" />

1번은 hello라는 이름의 메소드를 선정함.

파라미터는 (..)로 모두 허용하므로 hello()와 hello(String)이 선택됨.

2번은 hello()처럼 파라미터가 없는 메소드만 선정함.

파라미터 패턴이 ()이기 때문임.

3번은 파라미터가 1개이고 String인 hello(String)만 선정함.

4번은 메소드 이름에 * 와일드카드를 적용한 케이스임.

타입 지정이 없으므로 meth로 시작하는 메소드면 클래스와 무관하게 매칭됨.

그래서 Target.method() 와 Bean.method()가 모두 선택됨.

5번은 메소드 이름과 무관하게 파라미터 타입만으로 선정함.

두 개의 int 파라미터를 가진 메소드가 모두 선택됨.

6번은 파라미터가 없는 모든 메소드를 선정함.

7~9번은 패키지와 타입 패턴으로 클래스를 제한하는 방법임.

7번은 특정 클래스를 직접 지정하므로 Bean은 제외됨.

8번은 특정 패키지의 모든 클래스에 적용되지만 서브패키지는 포함하지 않음.

9번은 .. 로 서브패키지까지 포함함.

10번은 .. 확장으로 특정 패키지의 모든 서브패키지를 포함하도록 지정함.

11번은 com 으로 시작하는 패키지를 조건으로 걸어 매칭되는 메소드가 없게 됨.

12번은 패키지 무관하게 Target 이라는 이름의 모든 클래스에 적용됨.

다른 패키지에 같은 이름이 있으면 함께 적용될 수 있음.

13~15번은 클래스 이름에 와일드카드를 적용한 타입 패턴 확장임.

패키지, 클래스, 메소드 이름 모두 와일드카드 사용 가능함.

16번은 Target 클래스가 아니라 TargetInterface 타입을 조건으로 사용함.

인터페이스에 선언된 메소드에만 적용되므로 Method() 처럼 인터페이스에 없는 메소드는 제외됨.

포인트컷 표현식은 클래스 이름뿐 아니라 인터페이스/슈퍼클래스 타입까지 인식함.

17번은 클래스·메소드와 무관하게 예외 선언(throws) 타입으로만 선정하는 예임.

Runtime 으로 시작하는 예외를 던지면 조건을 만족함.

18~19번은 리턴 타입을 기준으로 메소드를 선정하는 예임.

각 표현식이 실제로 어떤 메소드를 선택할지 직접 예측해보면서 익숙해지는 게 목적임.

### 포인트 컷 표현식을 이용하는 포인트 컷 적용

AspectJ 포인트컷 표현식은 메소드 선정을 간결하게 표현할 수 있는 강력한 표현식 언어임.

execution() 외에도 다양한 표현식 스타일을 제공함.

스프링에서는 빈 이름을 기준으로 선택하는 bean() 표현식도 자주 사용함.

bean(*Service) 는 아이디가 Service 로 끝나는 모든 빈을 선택함.

또 애노테이션 기반 선정도 가능함.

특정 애노테이션이 타입·메소드·파라미터에 붙어 있는지를 기준으로 메소드를 선택함.

예를 들어 @Transactional 이 붙은 메소드만 자동으로 선정 가능함.

명명 규칙에 의존하지 않고 애노테이션만으로 부가기능을 적용할 수 있어 실무에서 많이 사용됨.

<img width="482" height="42" alt="image" src="https://github.com/user-attachments/assets/15e9c515-213d-4842-8e5a-e59f7d891fd3" />

이제 포인트컷 표현식을 실제로 적용할 차례임.

기존에 사용하던 transactionPointcut 빈은 제거함.

NameMatchClassMethodPointcut 처럼 직접 만든 포인트컷 구현 클래스는 더 이상 사용하지 않음.

기존 포인트컷 빈 설정을 다시 보면

mappedClassName 은 클래스 이름 패턴을 담당했고,

mappedName 은 메소드 이름 패턴을 담당했음.

<img width="388" height="61" alt="image" src="https://github.com/user-attachments/assets/9c856f8e-43ea-456a-ac21-4d28c2185bac" />

기존 포인트컷과 동일한 선정 기준을

**포인트컷 표현식으로 재작성함 .** 클래스 이름이 ServiceImpl 로 끝나고 메소드 이름이 upgrade 로 시작하는 조건임.

이를 execution(*..*ServiceImpl.upgrade*(..)) 표현식으로 작성함. AspectJExpressionPointcut 빈을 등록하고 expression 프로퍼티에 설정함.

동일한 선정 로직을 더 간결한 설정으로 적용함.

<img width="597" height="147" alt="image" src="https://github.com/user-attachments/assets/6a1d5281-29d5-4dc6-814a-c1ae090040a6" />

설정파일 수정 후 UserSerivceTest 를 실행해 포인트컷이 이전과 동일하게 동작하는지 확인함.

포인트컷 표현식을 사용하면 짧은 문자열로 선정 로직을 표현할 수 있어 코드와 설정이 단순해짐.

별도의 클래스 구현이 필요 없어짐.

반면 문자열 기반이므로 컴파일 타임에 문법 검증이 되지 않음.

런타임에서야 오류가 드러남.

자동 프록시 생성기와 함께 동작하므로 문제 원인 파악이 더 어려워질 수 있음.

따라서 포인트컷 표현식은 충분히 학습한 뒤 사용해야 함.

사전에 다양한 테스트로 검증된 표현식을 사용하는 것이 중요함.

포인트컷이 실제로 어떤 빈을 선정했는지 확인하는 일은 쉽지 않음.

테스트로 가능하지만 번거로움이 큼.

다만 스프링 개발팀이 제공하는 지원 도구를 사용하면 선정 결과를 쉽게 확인할 수 있음.

### 타입 패턴과 클래스 이름 패턴

포인트컷 표현식 적용 이전에는 클래스 이름 패턴으로 타깃 빈을 선정.

그래서 UserServiceImpl과 TestUserServiceImpl 두 빈 모두에 트랜잭션을 적용하려고

클래스 이름이 ServiceImpl 로 끝나도록 테스트용 클래스 이름까지 변경.

포인트컷 표현식 적용 시에도 동일한 기준을 유지하려고

타입 패턴을 * . . *ServiceImpl로 지정.

이 경우 두 빈 모두 선정되고 테스트도 성공.

그런데 테스트용 클래스 이름을 다시 TestUserService로 바꿔도

테스트는 여전히 성공.

겉으로 보면 타입 패턴과 맞지 않아 실패해야 할 것처럼 보임.

이유는 포인트컷 표현식에서 사용하는 것은 클래스 이름 패턴이 아니라 타입 패턴이기 때문.

TestUserService는 클래스 이름은 다르지만 타입 기준으로 보면 UserServiceImpl의 서브클래스이자 UserService 인터페이스를 구현한 타입.

따라서 * . . *ServiceImpl 이라는 타입 패턴 조건을 충족.

이는 인터페이스 타입을 기준으로 선정했을 때 구현 클래스가 함께 선정되는 것과 동일한 원리.

즉 포인트컷 표현식의 타입 패턴은 클래스 이름이 아니라 상속·구현 관계를 포함한 타입 전체를 기준으로 판단.

이 점이 기존의 단순 클래스 이름 패턴 방식과의 핵심 차이.
