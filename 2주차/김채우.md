# 개요
## 스프링의 강점
- 객체지향
- 테스트
## 테스트의 장점
- 만들어진 코드에 대한 확신
- 변화에 유연하게 대처할 수 있다는 자신감
- 스프링을 학습하는데 효과적인 방법 중 하나
  - 스프링의 활용 방법에 대한 이해와 검증, 실전 적용이 익숙해짐
  
----

# 테스트의 유용성
## 일반적인 웹에서의 DAO 테스트 방법
1. 모든 입출력 기능의 구현
2. 테스트용 웹 애플리케이션을 서버에 배치
3. 웹 화면을 띄워 폼 생성
4. 값 입력 후 버튼을 통한 등록
  - 이 과정에서 웹에서 서버까지 데이터가 파싱되고 저장되는 로직이 구현되어 있어야 함
5. 검색 폼이나 파라미터 지정 가능한 URL을 사용해 입력한 데이터를 가져올 수 있는지 확인
  - 이 과정 또한 DAO가 돌려주는 결과를 화면에 출력해주는 로직이 구현되어 있어야 함
### 이러한 방법의 단점
1. 모든 기능을 구현해야 테스트가 가능 
2. 테스트 중 에러가 발생하거나 테스트가 실패했다면 코드가 많기 때문에 그 지점을 찾는 것이 어려움
  - DB 연결 방법, DAO 로직, SQL 문법, 잘못된 바인딩 등 그 요소가 너무 많음
3. 빠르고 정확한 대응이 어려움
## 작은 단위의 테스트
- 테스트하는 대상이 명확하다면 그 대상에만 집중하는 것이 바람직
- 많은 대상을 한 번에 테스트한다면 테스트 수행 과정이 복잡해지며 정확한 원인의 발견 어려움
- 1장에 나온 관심사의 분리를 통해 테스트를 작은 단위로 분해
### 단위 테스트 aka 개발자 테스트, 프로그래머 테스트
- 작은 단위의 코드에 대해 테스트를 수행한 것
- 단위에 대한 의견은 항상 같을 수 없음
  - 사용자 관리 기능 전부가 단위일수도, 데이터 한 개의 추가 기능이 단위일 수도 있음
  - 시점과 필요에 따라 단위 결정
- **즉, 단위란 충분히 하나의 관심에 효율적으로 테스트할 만한 범위**
## 작은 단위의 이점
- 일반적으로 단위는 작을수록 좋음
- 불필요한 다른 계층들이 참여하지 않아도 테스트 가능
## 주의점
- DB를 테스트에 사용할 경우, DB의 상태가 매번 달라지고 테스트를 위해 DB를 특정 상태로 만들어줄 수 없다면 단위 테스트로서의 가치가 없어짐
- 즉, 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아님
- 항상 작은 단위의 테스트만 필요한 것은 아니고 여러 기능들을 뭉쳐놓은 테스트가 필요할 때도 있음
## 굳이 작은 단위의 테스트가 필요한 이유
- 개발자가 작성한 코드가 원래 의도대로 동작하는지 개발자 스스로 빨리 확인하는 것이 좋음
- 이 때 확인의 대상과 조건이 간단하고 명확할 수록 좋음
- 따라서 작은 단위로 제한해 테스트하는 것이 효율적

----

# 자동수행 테스트 코드
## 테스트 코드가 자동이 아닐 시 불편한 점
- 입력 값과 상호작용을 위해 개발자가 일일이 신경써야 함
- 입력 중에 실수가 있을 가능성 존재
- 서버를 띄우고 브라우저의 주소창에 들어가야 하는 등 필요한 행동들이 많음
- **따라서 자동으로 테스트가 가능한 코드를 작성하는 것이 중요**
## main 메소드를 이용한 자동화
- main 메소드로 테스트를 진행할 시 개발자가 테스트 중 할 것이 적어 빠르고 편리한 테스트 가능
- 하지만 애플리케이션에 테스트 코드를 포함시키는 것 보다는 테스트용 클래스를 만들어 테스트 코드를 넣는 것이 바람직
## 자동수행 테스트의 장점
### 자주 반복 가능
- 번거로운 작업이 적기 때문에 코드를 수정하고 테스트를 실행하는 것이 편리

----

# 지속적인 개선과 점진적인 개발을 위한 테스트
- 일단 테스트를 만들고 고쳐가며 진행하면 매우 작은 단계를 거쳐가며 지속적인 코드 개선 가능
- 테스트를 지속적으로 진행했다면 하나의 기능에 대한 신뢰도 상승
- 새로운 기능을 추가할 때 기존 기능들에 영향이 있는지 확인 가능

----

# 테스트 검증의 자동화
- 테스트 코드의 결과가 올바른 것인지 그렇지 않은지 개발자가 직접 확인해야 한다면 번거로움
- 한 번에 결과가 정상, 비정상으로 나오는 것이 편리
## 이점
- 언제든지 실행해 간단하게 결과 확인 가능
- 다른 기능을 개발하거나 기술 혹은 프레임워크를 전환하는 큰 작업이 있을 때도 자동화를 해 둔다면 간단하게 기능의 정상작동 유무 판별 가능
## 테스트 에러
- 테스트 진행 중 에러가 발생해서 실패하는 경우
- 콘솔의 에러 메시지와 호출 스택 정보로 쉽게 확인 가능
## 테스트 실패
- 테스트 작업 중 에러가 발생하지 않았지만 그 결과가 기대와 다른 경우
- 별도의 확인 작업과 그 결과가 있어야만 확인 가능
- 논리적 오류 느낌
- 테스트 에러에 비해 원인 파악과 해결이 어려움
## 포괄적인 테스트 Comprehensive Test
- 만들어진 코드의 기능을 모두 점검 가능한 테스트
- 전체적으로 정상적인 작동을 하는지 확인 가능
### 새로운 생성자 생성
- 포괄적인 테스트를 할 때 생성자를 이용해 필요한 데이터를 넣어주면 편함
- 이 때 메소드 실행 순서에 상관 없이 항상 같은 결과가 나와야 함
### 네거티브 테스트
- 개발할 때 항상 작동되는 코드만 작성할 수 있음
- 이럴 경우 다른 사람이 테스트 시 많은 오류 발생 가능
- 따라서 항상 에러가 발생할 수 있는 상황을 고려하여 코드를 작성해야 함

----

# 테스트의 효율적인 수행과 관리
## main 메소드만을 사용하는 테스트
- 애플리케이션 규모가 커지고 테스트 개수가 많아지면 테스트를 수행하는 것이 부담됨
## 테스팅 프레임워크 Junit
- 테스트를 효율적으로 사용하기 위한 프레임워크
- 실행한 테스트 수, 테스트 에러 수, 테스트 실패의 수, 어떤 테스트 클래스를 실행했는지 등 확인 가능
### 프레임워크이기 때문에 갖는 이점
- 제어의 역전이 적용되어 있기 때문에 main 메소드 불필요
- 오브젝트를 만들어 실행시키는 코드 만들 필요 없음
## Junit 테스트 메소드가 될 조건
1. 메소드가 public으로 선언될 것
2. 메소드에 @Test 어노테이션을 붙일 것
## assertThat() 메소드
- JUnit이 제공하는 static 메소드
### 매처 Matcher
- 조건 비교에 사용하는 첫 번째 파라미터 뒤의 값
- is()
  - 일종의 equals()
## @Test(expected=EmptyResultDataAccessException.test)
- 예외조건 테스트시 사용하는 문법
- 실행 시 해당 예외가 발생하면 성공, 발생하지 않으면 실패
- expected=에 발생할 예외 클래스 작성
## @Before
- 해당 어노테이션이 붙은 메소드를 작업 전 자동으로 실행해 주어 필요한 작업 수행
### 픽스처 Fixture
- 테스트를 수행하는데 필요한 정보나 오브젝트
- 보통 @Before 메소드를 이용해 생성해 두면 편리
## @After
- 해당 어노테이션이 붙은 메소드를 작업 후 자동으로 실행해 주어 필요한 작업 수행
## 테스트 클래스와 오브젝트
- 테스트 메소드를 실행할 때마다 테스트 오브젝트를 하나씩 생성
- 한 번 만들어진 테스트 객체는 테스트 메소드를 한 번 실행하면 버려짐
- 각 테스트가 독립적으로 시행된다는 것을 보장하기 위해 매번 객체를 생성
## 테스트 시 스프링 컨텍스트 개선
### @Runwith(SpringJUnit4ClassRunner.class)
- 스프링의 테스트 컨텍스트 프레임워크의 JUnit 확장 가능 지정
- JUnit이 테스트 진행 중 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업 진행
### @ContextConfiguration(locations="/applicationContext.xml")
- 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트의 위치 지정 
## @Autowired
- 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈 찾음
- 타입이 일치하는 빈 있으면 인스턴스 변수에 주입
- 일반적으로 주입을 위해서는 생성자나 수정자 같은 메소드가 필요하지만 이 경우에는 메소드 없이주입 가능
- 변수 할당 가능한 타입을 가진 빈을 자동으로 찾기 때문에 인터페이스 타입으로 변수를 선언해도 됨
- 단 같은 타입의 빈이 있다면 @Autowired는 변수의 이름과 같은 이름의 빈이 있는지 확인
- 변수 이름으로도 찾을 수 없는 경우에는 예외 발생
### 타입에 의한 자동 와이어링
- 별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져오는 것
## DirtiesTest
- 테스트 메소드에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려줌
- 꼭 클래스 레벨에만 붙일 필요는 없음
- 메소드가 변경한다면 메소드에만 붙여주는 것이 옳음

----

# 테스트 결과의 일관성
- 테스트 결과가 외부 상태에 따라 실패나 성공이 결정될 수 있으면 안 됨
- 코드에 변경사항이 없다면 항상 같은 결과를 내야 함

----

# 기능 설계를 위한 테스트
- 잘 만들어진 테스트 코드는 하나의 기능정의서로 보임
- 일반적인 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하는 느낌
- 기능 설계를 위해 테스트를 만들고 애플리케이션 코드를 작성해 정상 작동하는지 확인

----

# 테스트 주도 개발 TDD
- Test Driven Development
- aka 테스트 우선 개발 Test First Development
- 기능의 내용을 담으며 코드를 검증할 수 있는 테스트 코드를 만들고 테스트를 성공하게 해 주는 코드를 작성하는 방식
- 테스트를 만들어가며 개발할 때의 장점을 극대화한 방법
## 특징
1. 테스트를 작성하는 시간과 애플리케이션 코드를 작성하는 시간의 간격이 짧아짐
  - 이미 테스트 코드를 만들어 두었기 때문에 애플리케이션 코드를 작성하면 바로 테스트가 가능하기 때문
  - 작성 코드에 대한 빠른 피드백을 받을 수 있음
2. 코드에 대한 확신
## TDD 시 권장사항
### 테스트 작성, 개발 코드 작성의 작업 주기를 최대한 짧게 가져갈 것
- 많은 양의 테스트 코드와 애플리케이션 코드를 한 번에 작성하는 것을 지양
- 이렇게 되면 어디서 에러가 발생하는지, 어떻게 고쳐야 하는지 알기가 힘들 수 있음

----

# 굳이굳이 DI를 사용해야 하는가
- 절대 클래스 바꾸지 않을 것이고 항상 같은 세팅을 유지할 것인데 DI 굳이 해야 하나? 에 대한 대답
## 1. 소프트웨어 개발에서 절대 바뀌지 않는 것은 없음
- 클래스 대신 인터페이스를 사용하고 new 생성 대신 DI를 사용하는 것은 단순한 작업
- 이 단순한 작업으로 나중에 편리해짐
## 2. 인터페이스를 두고 DI를 적용하면 다른 차원의 서비스 기능 도입 가능
- DI 때문에 자연스러운 부가 기능 도입 편리
## 3. 테스트가 편리
- 하나의 작은 단위에 국한해야 테스트가 편리

----

# 침투적, 비침투적 기술
## 침투적 기술
- 기술 적용 시 애플리케이션 코드에 기술 관련 API가 등장하거나 특정 인터페이스 혹은 클래스를 사용하도록 강제하는 기술
- 애플리케이션 코드가 해당 기술에 종속됨
## 비침투적 기술
- 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용 가능
- 기술에 종속적이지 않은 순수한 코드 유지 가능

----

# 학습 테스트로 배우는 스프링
## 학습 테스트의 장점
1. 다양한 조건에 따른 기능 손쉽게 확인 가능
2. 학습 테스트 코드를 개발 중에 참고 가능
3. 프레임워크나 제품을 업그레이드할 때 호환성 검증 도와줌
4. 테스트 작성에 대한 좋은 훈련

----

# 버그 테스트
- 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것
- 이후 버그 테스트가 성공할 수 있도록 애플리케이션 코드 수정
- 테스트가 성공하면 버그 해결
## 필요성 및 장점
1. 테스트의 완성도 향상
2. 버그의 내용에 대한 정확한 분석
3. 기술적인 문제 해결에 도움 
