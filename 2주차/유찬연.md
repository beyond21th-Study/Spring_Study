스프링이 제공하는 가장 중요한 가치 : 객체 지향과 테스트

테스트 : 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있는 자신감을 주는 기술

테스트를 통해 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히니느데 효과적으로 사용 가능

웹 화면을 통해 값을 입력, 기능을 수행, 결과를 확인하는 방법 -> 가장 흔히 쓰이는 방법이지만 단점이 많음 why? 모든 레이어의 기능을 다 만들고 난 뒤 테스트가 가능하다는 점이 가장 큰 문제

테스트를 실행하는 중 에러가 나거나 테스트가 실패하는 경우 문제 발생 지점 확인이 어렵고 테스트 수행 시 참여하는 클래스와 코드가 너무 많음

따라서 테스트하고자 하는 대상이 명확할 경우 그 대상에만 집중해서 테스트하는 것이 바람직
테스트는 가능한 한 가장 작은 단위로 쪼개어 집중해서 실행 -> 단위 테스트

관심사의 분리 : 하나의 복잡한 시스템을 역할이나 기능 별로 나누어 관리하는 설계 원칙

단위의 기준은 크게는 기능으로 작게는 메소드로 잡을 수 있음(때에 따라 다름)

일반적으로 단위는 작을수록 좋음

단위 테스트가 필요한 이유 : 설계된 코드가 원래 의도대로 동작하는 지를 스스로 빨리 확인받기 위함
코드를 만들자마자 작은 단위로 테스트를 실행하면 오류나 버그를 수정하는 것이 훨씬 빠름

매번 같은 작업을 반복하는 경우 불편하고 값 입력 시 생기는 실수 등의 경우 다시 테스트를 진행하기에 번거로움

이를 방지하기 위해 자동 수행 테스트 코드를 사용 가능

자동 수행 테스트 코드를 사용하여 테스트를 진행하는 경우 진행 시간도 매우 짧아 자주 수행하더라도 부담 x

테스트는 자동으로 수행되도록 코드가 만들어지는 것이 중요

또한 애플리케이션을 구성하는 클래스 안에 테스트 코드가 포함되는 것보다 별도의 테스트용 클래스에 테스트 코드를 작성하는 편이 더 나음

테스트 검증 역시도 자동화하여 직접 실행하고 확인하는 번거로움을 덜어낼 수 있음

프레임워크에 적용하기 위해서는 main() 메소드 테스트는 부적합 -> 제어권을 직접 가지기 때문(제어의 역전 부합 x)

JUnit 프레임워크가 테스트 코드 작성시 요구하는 조건 충족 필요 
- 메소드가 public으로 선언
- 메소드에 @Test annotation 붙이기

JUnit으로 검증 코드 작성
if -> assertThat이라는 스태틱 메소드로 대체 가능
asserThat() : 첫 번째 파라미터의 값을 뒤에 나오는 matcher(조건)과 비교하여 일치하면 다음으로 아니면 테스트가 실패하도록 만들어주는 메소드
is() -> matcher의 일종으로 equals() 와 같은 역할

JUnit은 예외가 발생하거나 assertThat()에서 실패하지 않고 테스트 메소드 실행이 완료되는 경우 테스트가 성공했다고 인식함
-> 굳이 "테스트 성공" 메시지 출력 필요 x

JUnit을 이용해 테스트를 실행해주는 메소드 필요
<img width="658" height="181" alt="image" src="https://github.com/user-attachments/assets/048830f8-7b99-486c-a015-c2f0911a00db" />
결과
<img width="288" height="96" alt="image" src="https://github.com/user-attachments/assets/78662ac2-d1fb-48e1-aec5-44d14a588bb1" />


성공시 OK 
실패시 FAILURES!!!

실패한 원인과 위치도 확인 가능

테스트 수가 많아지면 관리하기 힘들어짐
IDE에 내장된 JUnit 테스트 지원 도구 사용하여 극복 가능

IDE(이클립스)
테스트 클래스를 선택한 뒤 Run As 항목의 JUnit Test를 선택하면 테스트 자동 실행

따로 main 메소드를 만들 필요 x

테스트가 시작되면 JUnit 테스트 정보 표시를 위한 뷰가 나타나서 진행 상황을 보여줌

테스트가 완료되면 최종 결과가 깔끔하게 나타남

이 뷰를 통해 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수를 확인 가능
또한 어떤 테스트 클래스를 실행했는지도 확인 가능

한 번에 여러 테스트 클래스를 동시에 실행도 가능

빌드 툴( : 일일이 명령을 입력하지 않아도 코드를 실행 가능한 프로그램으로 만들어주는 자동화 도구)
ANT나 메이븐같은 빌드 툴과 스크립트를 사용하는 경우 빌드 툴에서 제공되는 JUnit 플러그인이나 태스크를 이용해 테스트 실행 가능

실행 결과는 옵션에 따라 HTML이나 txt 파일의 형태로 만들어 짐

보통 여러 개발자가 만든 코드를 모두 통합해서 테스트를 수행하는 경우 사용됨

테스트 결과의 일관성
반복적으로 테스트를 할 때 결과가 달라진다면 좋은 테스트가 아님

코드에 변경 사항이 없는 경우 항상 동일한 결과가 도출되어야 함

이전 테이블 데이터가 남아있어 테스트 실행 전 준비 작업(데이터 모두 삭제)가 필요함

위의 경우 deleteAll()의 getCount()추가를 통해 해결 가능

deleteAll() : 테이블의 모든 레코드 삭제, add() 메소드와 비슷한 구조지만 파라미터 바인딩이 없어 더 단순

getCount() : 테이블의 레코드 개수를 돌려줌

위 두 코드를 기존의 테스트 코드 상단에 넣는다.

위 두 메소드에 대한 검증을 위해 getCount()를 add() 메소드 뒤에 붙여 정상 작동하는 지 확인하면 완성

성의 없는 테스트로 문제가 있는 코드가 테스트를 성공하는 경우 매우 위험함

이를 위해 꼼꼼한 테스트 작성 필요

또한 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 낼 수 있어야 함

add()의 기능에 대한 테스트는 충분하지만 get()에 대한 테스트가 부족함

get() 메소드 테스트 기능 보완 필요

중복되지 않는 값을 가진 두 개의 오브젝트 준비
get()을 통해 제대로 된 값을 반환하는지 확인
두 오브젝트 모두 정상적으로 실행될 경우 테스트 성공

get() 예외 조건에 대한 테스트
get() 메소드에 전달된 값에 해당하는 사용자 정보가 없는 경우 null과 같은 특별한 값을 리턴하거나 예외를 던지는 방법이 있음

EmptyResultDataAccessException 예외를 활용

해당 테스트에서는 
작성해둔 예외가 발생하면 테스트 성공
작업이 정상적으로 마쳐지면 테스트 실패로 간주

하지만 이런 경우 JUnit은 예외 조건 테스트를 위해 특별한 방법을 제공

@Test 어노테이션의 expected 엘리먼트를 통해 테스트 메소드 실행 중 발생될 것으로 기대되는 예외 클래스를 넣으면 됨

이를 추가할 경우 보통의 테스트와 반대로 정상적으로 테스트 메소드가 마치면 실패, 지정한 예외가 발생되면 성공


JDBC를 이용한 DAO 개발 경험이 풍부한 경우 간단한 DAO는 다양한 테스트 없이도 문제가 발생하지 않지만 DAO 메소드에 대한 포괄적인 테스트를 만들어 두는 편이 훨씬 안전하고 유용

종종 단순하고 간단한 테스트가 치명적인 실수를 피할 수 있게 도와줌

개발자가 테스트를 직접 만들 때 자주 하는 실수 -> 성공하는 테스트만 골라 만듦

테스트 작성시 문제가 될 만한 상황이나 입력 값 등을 교모히 피해서 만드는 습성이 있음

그래서 테스트를 작성할 때는 부정적인 케이스를 우선적으로 만드는 습관을 들이는 게 좋음

테스트가 이끄는 개발

테스트 코드를 먼저 만들고 난 뒤 개발하는 방법

테스트에 만들고 싶은 기능에 대한 조건과 행위, 결과에 대한 내용을 담으면 됨

이는 마치 잘 작성된 하나의 기능 정의서처럼 보임

테스트를 실패하면 설계한 대로 코드가 작성되지 않았음과 문제가 되는 부분을 바로 확인 가능
테스트를 성공하면 그와 동시에 코드 구현도 완성됨

테스트 주도 개발(TDD, Test Driven Development) : 테스트 코드를 먼저 만들고 이를 성공시키는 코드를 작성하는 방식

테스트 우선 개발(Test First Development)이라고도 불림

실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다가 TDD의 기본 원칙

개발 진행시 테스트를 만들어서 코드를 점검할 타이밍을 놓치는 일이 빈번하지만, TDD의 경우 테스트를 빼먹지 않고 꼼꼼하게 만들어 낼 수 있음

또한 테스트 작성 시간과 애플리케이션 코드 작성 시간의 텀이 짧아짐

코드 작성 후 테스트가 즉각적으로 수행되어 코드에 대한 피드백이 빠르게 이루어짐

그리고 TDD는 자연스레 단위 테스트로 만들어 짐

JUnit은 @Test 가 붙은 메소드를 실행하기 전과 후에 각각 @Before와 @After가 붙은 메소드를 자동으로 실행

테스트 메소드는 실행할 때마다 새로운 오브젝트가 만들어짐 why? 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해

픽스처(fixture) : 테스트를 수행하는 데 필요한 정보나 오브젝트

일반적으로 픽스처는 여러 테스트에서 반복적으로 사용되기 때문에 @Before 메소드를 이용해 생성해두는 것이 편리

애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트를 만들기도 함

 문제는 JUnit이 매번 테스트 클래스의 오브젝트를 새로 만든다는 점

이로 인해 여러 테스트가 함께 참조할 애플리케이션 컨텍스트를 오브젝트 레벨에 저장해두면 곤란해짐

이는 메소드에 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 하여 해결 가능하지만 스프링이 직접 제공하는 애플리케이션 컨텍스트 테스트 지원 기능을 사용하는 것이 더 편리

스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공

간단한 어노테이션 설정만으로 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유 가능

스프링 테스트 컨텍스트 프레임 워크 적용

@RunWith : JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용

@ContextConfiguration : 자동으로 만들어 줄 애플리케이션 컨텍스트의 설정 파일 위치를 지정한 것

출력된 context와 this의 오브젝트 값
context : 모두 동일(하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메소드에서 사용되고 있음을 확인 가능)
this의 오브젝트 주소값 : 매번 다름(테스트 메소드 실행할 때마다 새로운 테스트 오브젝트를 만들기 때문)

첫번째 테스트가 실행될 때 최초로 애플리케이션 컨텍스트가 처음 만들어져 실행시간이 길고 그 이후는 테스트 실행 시간이 매우 짧아짐

테스트 클래스의 컨텍스트 공유
스프링이 하나의 클래스 뿐 아닌 여러 개의 테스트 클래스에서 같은 설정 파일을 가진 애플리케이션 컨텍스트를 공유하게 도와줌

@Autowired : 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아 일치하는 경우 인스턴스 변수에 주입해 줌

일반적으로는 주입을 위해 생성자나 수정자 메소드같은 메소드가 필요하지만, 이 경우 메소드가 없어도 주입 가능
별도의 DI 설정 없이 필드의 타입 정보를 이용해 빈을 자동으로 가져오는 것을 자동 와이어링이라고 함

인터페이스를 두고 DI를 적용해야 하는 이유
1. 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없음.
클래스 대신 인터페이스를 사용하고 new를 이용해 생성하는 대신 DI를 통해 주입받게 하는 건 아주 단순하고 쉬운 작업이므로 약간의 수고를 들여 수정에 필요한 시간과 비용 부담을 줄이는 것이 이득

2. 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적요하게 해두면 다른 차원의 서비스 기능 도입 가능
새로운 기능을 넣기 위해 기존 코드 변경 필요 x, 추가했던 기능이 필요 없어지면 언제든지 설정 파일을 간단히 수정해서 제거 가능

3. 테스트
단지 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 함 -> 자동으로 실행 가능하며 빠르게 동작해야 함

테스트 중 운영용 DB 사용자가 모두 삭제되는 경우를 방지하기 위해 테스트 코드에 의한 DI를 이용해서 테스트 중 DAO가 사용할 수 있는 DataSource 오브젝트를 바꿔주는 방법 이용

스프링이 제공하는 SingleConnectionDataSource를 사용하여 테스트 내에서 DataSource를 직접 만들 수 있음

SingleConnectionDataSoure는 DB 커넥션을 하나만 만들어두고 계속 사용하기에 매우 빠름

이 방법의 장점은 XML 설정 파일을 수정하지 않고도 테스트 코드를 통해 오브젝트 관계를 재구성 가능하다는 점


애플리케이션 컨텍스트의 구성이나 상태를 테스트 내에서 변경하지 않는 것이 원칙

하지만 이 방식을 사용하면 의존 관계가 애플리케이션 컨텍스트에 의해 변경된 빈을 나머지 모든 테스트를 수행하는 동안 사용하게 되어 바람직하지 못함

이를 방지하기 위해 @DirtiesContext 애노테이션 사용 가능

@DirtiesContext : 스프링의 테스트 컨텍스트 프레임워크에게 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경하는 것을 알려주는 애노테이션

위 애노테이션이 붙은 테스트 클래스에는 애플리케이션 컨텍스트 공유가 허용되지 않음

테스트 코드에서 빈 오브젝트에 수동으로 DI하는 방법은 장점보다 단점이 많음

아예 테스트에서 사용될 DataSource 클래스가 빈으로 정의된 테스트 전용 설정 파일을 따로 만들어두는 방법으로 DI의 장점을 살려 DAO가 테스트에서만 DataSource를 사용 가능

두 가지 종류의 설정 파일을 만들어서 하나는 서버 운영용으로 사용할 DataSource를 빈으로 등록, 다른 하나는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 만드는 것

마지막으로 스프링 컨테이너를 아예 사용하지 않고 테스트를 만드는 방법이 있음

테스트를 위한 DataSource를 직접 만드는 번거로움이 있지만 애플리케이션 컨텍스트를 사용하지 않아 코드가 단순하고 이해가 편함
<img width="683" height="367" alt="image" src="https://github.com/user-attachments/assets/95f6ac6b-d877-4645-a170-96eddf2d060c" />


또한 애플리케이션 컨텍스트가 생성되지 않아 테스트 시간이 단축됨

하지만 매번 새로운 테스트 오브젝트가 만들어진다는 단점이 존재

침투적 기술 : 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술(애플리케이션 코드가 해당 기술에 종속되는 결과)
비침투적 기술 : 애플리케이션 로직을 담은 코드에 아무 영향을 주지 않고 적용 가능(종속되지 않은 결과)

스프링 컨테이너 없이 테스트하는 방법을 가장 우선적으로 고려 why? 수행 속도가 빠르고 테스트 자체가 간결하기 때문

여러 오브젝트와 복잡한 의존 관계를 갖고 있는 오브젝트의 경우 -> 스프링의 설정을 이용한 DI 방식의 테스트를 이용하면 편리

테스트 설정을 따로 만들더라도 때로는 예외적인 의존 관계를 강제로 구성해야 하는 경우 -> 컨텍스트에서 DI 받은 오브젝트에 다시 테스트 코드로 수동 DI 해서 테스트하는 방법 사용(테스트 메소드 또는 클래스에 @DirtiesContext 애노테이션 추가)

학습 테스트 : 자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대한 테스트

학습 테스트의 목적은 자신이 사용할 API나 프레임워크의 기능을 테스트하며 사용 방법을 익히기 위함

학습 테스트의 장점
- 다양한 조건에 따른 기능 확인 용이
- 학습 테스트 코드를 개발 중에 참고 가능
- 프레임 워크나 제품을 업그레이드할 때 호환성 검증을 도와줌
업데이트 과정에서 API 사용법에 미묘한 변화나 버그가 포함되는 경우 학습 테스트를 통해 오류 발생 여부를 미리 확인 가능
- 테스트 작성에 대한 좋은 훈련
미숙한 개발자의 경우 테스트를 통해 코드 작성을 연습 가능
+ 추가로 책이나 문서 등을 읽는 것보다 실제로 적용하고 실습하며 하기에 지루함을 덜어내기에 좋다

JUnit 테스트 오브젝트 테스트
<img width="659" height="223" alt="image" src="https://github.com/user-attachments/assets/512f25ee-3658-48db-89d1-f7e44ad79c0c" />
<img width="666" height="363" alt="image" src="https://github.com/user-attachments/assets/07b3b0f1-b869-4e34-8fbb-b9cc895926c3" />

not() : 뒤에 나오는 결과를 부정하는 매처
is() : 비교 후 같으면 성공
hasItem() : 컬렉션의 원소인지를 검사하는 매처

스프링 테스트 컨텍스트 테스트
매번 동일한 애플리케이션 컨텍스트가 context 변수에 주입됐는지 확인하는 방법
1. assertThat() 을 이용하는 것
매처와 비교할 대상인 첫 번째 파라미터에 Boolean 타입의 결과가 나오는 조건문 삽입
그리고 결과를 is() 를 통해 true와 비교하면 됨
2. 조건문을 받아서 결과가 true인지 false인지 확인하는 assertTrue() 사용
코드가 조금 간결해짐
3. either(), or()을 통해 두 개의 매처의 결과를 or 조건으로 비교하여 둘 중 하나만 true로 나와도 성공

<img width="426" height="292" alt="image" src="https://github.com/user-attachments/assets/442e77d4-c03e-4c15-964c-72e7a62c9ee7" />
<img width="512" height="410" alt="image" src="https://github.com/user-attachments/assets/309f922b-2fbc-4243-81f6-f0c5ec6ef1f9" />


버그 테스트 : 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트
버그 테스트는 우선 실패하도록 만들어야 함 why? 버그가 원인이 돼서 테스트가 실패하는 코드를 만들어야 하기 때문

버그 테스트의 필요성과 장점
- 테스트의 완성도를 높여줌
기존 테스트에서 미처 검증하지 못했던 부분이 발생시킨 오류들에 대한 테스트를 보완해줌
- 버그 내용을 명확하게 분석 해줌
버그를 좀 더 효과적으로 분석 가능, 그 과정에서 가려졌던 다른 오류들도 함께 발견 가능
테스트의 주요기법 중 하나인 동등분할이나 경계값 분석 적용 가능
- 기술적인 문제를 해결하는 데 도움을 줌
버그의 원인을 정확히 파악하기 어려운 경우 해당 버그를 발생시키는 가장 단순한 코드와 그에 대한 버그 테스트를 통해 도움을 받을 수 있음

동등분할(equivalence partitioning) : 같은 결과를 내는 값을 구반하여 각 대표 값으로 테스트하는 방법

경계값 분석(boundary value analysis) : 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용하여 경계의 근처에 있는 값을 이용해 테스트하는 방법
