[ Spring Study - week2 ]


스필에서 가장 중요한 가치가 무엇? 객체지향과 테스트
테스트 없이는 스프링은 필요없다는 말도 있음.


애플리케이션은 변하게 복잡해져간다 
확장과 변화를 고려한 객체지향적 설계.
IoC/DI 같은 기술.
예상하고 의도했던대로 코드가 정확하게 만들어졌는지. 변화에 유연하게 대처할 수 있다. —>  테스트.


웹을 통한 DAO 테스트 방법의 문제점
웹 화면을 통해 값 입력, 기능을 수행하고, 결과까지 보는 방법은 최소 서비스클래스, 컨트롤러, JSP 뷰 등 모든 레이어 기능을 다 만들고 나서야 테스트가 가능하다.

에러나면 어디서 문제 발생했는지 모른다. -> 빠르고 정확하게 대응 어려움.



효율적인 테스트 방법
작은 단위로 쪼개서 한다. -> 관심사의 분리의 원리 이용.
DB를 사용하는데 테스트를 위해 DB를 특정 상태로 만들 수 없다면, 단위 테스트의 가치가 없어짐.
-> 코드 수정 과정에서 심적으로 평안을얻고 새로 도입한 기술 적용에 문제가 없는지 빠르게 알수있다.


자동수행 테스트
Main 메소드를 실행하는 가장 간단한 방벙 테스트의 전 과정이 자동으로 진행됨.
자동으로 수행되도록 코드로 만들어지는것이 중요.
하지만 클래스안에 테스트 코드를 포함시키는 것보다 테스트용 클래스를 만드는 것이 더 나음.

자동수행 테스트 장점
자주 반복 가능 -> 빠르게 실행할 수 있기 떄문.
지속적이 개선과 점진적인 개발을 할 수 있음.
Ex) 간단한 등록 조회를 만들고 테스트 한 다음 기능을 조금씩 추가해 나가는 방법.



UserDaoTest의 문제점
수동 확인 작업의 번거로움
자동이지만 사람의 눈으로 확인하는 과정 필요.

실행 작업의 번거로움


테스트 검증의 자동화
일단 테스트 결과가 중요한 것은 DB에서 가져온 정보가 일치하는가?
테스트의 성공 실패를 기준을 잡는다.

테스트코드로 DB에서 가져온 정보를 조회 성공은 메소드가 에러없이 끝났다는 뜻이지 조회 테스트가 모두 성공한 것은 아님.
위의 그림처럼 오브젝트의 값을 비교해서 일치하는지 확인하는 방법이 더 좋다.




테스트의 효율적인 수행과 결과 관리
Main 메소드로 만든 테스터는 필요한 기능을 갖췄지만 단순한 main 메소드는 한계가 있다.

이를 해결하기위해 JUnit 테스트로 전환
Main 매소드가 있다는건 제어권을 직접 갖는다는 의미. -> 프레임워크게 적용하기엔 적합 X( IoC때문에 ).

JUnit 프레임워크의 요구사항 
메소드가 public 으로 선언.
메소드에 @Test라는 애노테이션 붙이기.


테스트 결과를 검증하는 if/else 문장을 JUnit 방법으로 전환.
기본 방식인 

JUnit이 제공해주는 assertThat 이라는 스태틱 메소드를 이용해 변경 가능.

assertThat() 메소드는 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라고 불리는 조건으로 비교해서 다음으로 넘어가고, 아니면 테스트가 실패하도록 만든다. 

Is()는 매처의 일종으로 equals()로 비교하는 역할을 한다.


위의 그림처럼 자바 코드를 사용하는 Test이므로 main에서 한번은 켜줘야한다.




만약 assertThat()의 검증에서 실패한다면 위의 그림같은 메세지가 나올 것이다.
성공하면 OK가 나옴.





JUnit 테스트 실행 방법
테스트의 수가 많아지면 관리 힘든 단점이있다.
하지만 IDE에 내장된 JUnit 테스트 지원 도구 사용하면된다.

IDE(Integrated Development) : 통합 개발 환경
테스트 시작시 View가 나와서 테스트 실패여부, 어떤 테스트 클래스 실행했는지, 에러의 수, 실패의 원인 등 알 수 있음.

한번에 여러 테스트 동시 실행 가능. -> 편리


JUnit 아쉬운 점.
가장 불편한 일 : 테스트 실행전에 DB의 USER 테이블 데이터를 모두 삭제해야한다.
-> 기본키가 중복된다 판단해서 add() 메소드 중 에러가 발생함.


보완?
deleteAll()의 getCount() 추가
deleteAll 로 테이블의 모든 레코드 삭제.
그리고 getCount로 USER 테이블의 레코드 개수 돌려줌.

하지만 불안해 ㅜㅜ
deleteAll 로 다 지우고 getCount하기전에 add()메소드를 추가하면 레코드 개수가 0에서 1로 변할것. -> addAndGet()
그러면 getÇount가 제대로 동작하는 것으로 볼 수 있다.


중요한건 테스트를 실행하는 순서를 바꿔도 동일한 결과가 보장되도록 독립적으로 만들어야한다.


addAndGet() 테스트 보완
확인해야하는 user 2개를 add()하고, 각 user의 id를 파라미터로 전달해서 get()을 실행하도록한다.




get() 예외조건에 대한 테스트
예를들어 get()메소드에 전달된 사용자 정보가 없다면?
null을 리턴.
정보를 찾을 수 없다고 예외를 던짐.

예외 던짐 -> 테스트 메소드 실행중단-> 테스트 실패. 검증실패는 아니고 테스트 에러남.

특정 예외 던져지면 테스트 성공, 실패하면 테스트 실패.-> 리턴 값으로 비교하긴 어렵다라는 뜻

테스트 메소드 하나 더 추가하면 된다.
모든 데이터를 지우고, 존재하지 않는 id로 get()을 호출. 이때 EmptyResultDataAccessException이 던져지면 성공, 아니면 실패

여기서 중요한 것은 @Test 애노테이션의 expected 엘리먼트임.
-> 테스트 메소드 실행중 발생하리라 기대하는 예외 클래스를 넣은 것
하지만 이렇게 돌리면 무조건 실패로 나옴.

테스트 성공시키기 위한 코드 수정.
개발자는 항상 성공하는 코드만 골라서 만든다.
조금만 신경써서 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들어라. -> 네거티브 테스트



테스트 주도 개발(TDD, Test Driven Development)
테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화 한 방법.
장점
테스트 실행 간격이 매우 짧아 오류를 빨리 발견할 수 있음.



테스트 코드 개선
@Before


JUnit의 테스트 수행 방식

테스트 메소드 실행할때마다 왜 새로운 오브젝트 만듦?
각 테스트가 서로 영향을 주지않고 독립적으로 실행됨을 확실히 보장하기 위해.


스프링 테스트 컨텍스트 프레임워크 적용
@RinWith는 Unit 프레임워크의 테스트 실행 방법을 확장할 떄 사용하는 애노테이션이다.

@Autowired가 붙은 인스턴스 변수가 있으면, 테스트 컨텍스트 프레임워크는 변수타입과 일치하는 컨텍스트 내 빈을 찾음.
타입이 일치하면 인스턴스 변수에 주입함. -> 주입을 위해서 생성자나 수정자 메소드가 필요하지만 이경우에는 주입 가능.
이걸 자동와이어링이라고함.


@Autowired를 지정하기만하면 어떤 빈이든 다 가져올 수 있다.

단, 같은 타입의 빈이 두 개 이상 있는경우는 타입만으로는 어떤 빈을 가져올지 결정X.

테스트에서는 가능한 인터페이스를 사용해서 코드와 느슨하게 연결해 놓는 것이 좋다.



DI를 이용한 테스트 방법 선택(3가지)
스프링 컨테이너 없이 할 수 있는 방법을 생각하자.
수행속도 가장 빠르고 간결하다.
Di방식의 테스트
오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트들을 테스트 할 경우 .
수동 DI


학습 테스트
자신이 만들지 않은 프레임워크나 다른 개발팀에서 만들어 제공한 라이브러리 등에서도 테스트를 작성하는것.
목적
자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용법을 익히려고 하는 것.
검증이 목적이 아님.

학습 테스트 장점
다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
학습 테스트 코드를 개발 중 참고가능.
프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와줌.
테스트 코드 작성의 좋은 훈련.
새로운 기술공부과정 Happy.


버그 테스트
코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트.

일단 실패하도록 만들어야함. -> 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것.

테스트의 완성도 UP

버그의 내용을 명확하게 분석하게 해준다.

기술적인 문제는 해결하는 데 도움이 된다.


동등분할(equivalence partitioning)
같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트를 하는 방법.
결과의 종류가 true, false또는 예외발생일때 사용하는게 좋음.



경계값 분석(boundary value analysis)
에러는 동등분할 경계에서 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법.
숫자의 입력값인 경우 0이나 그 주변 값 또는 최대, 최소값 등으로 하면 좋음.


