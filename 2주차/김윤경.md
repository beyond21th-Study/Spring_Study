## 스프링이 중요한 이유
-  객체지향
-  테스트

## 2.1 테스트의 유용성
<img width="599" height="530" alt="{5CC12E77-0351-45DF-B045-DF9C7809B622}" src="https://github.com/user-attachments/assets/3b1f972f-8fe3-4337-853f-61ad4a246534" />

- main() 메소드를 이용해 쉽게 테스트 수행을 가능하게 함
- 테스트할 대상인 UserDao를 직접 호출해서 사용
  
----

<웹을 통한 DAO 테스트 방법의 문제점>
- 서비스 클래스, 컨트롤러, JSP 뷰 등 모든 레이어의 기능을 다 만들고 나서야 테스트가 가능함
- 테스트 중에 에러나면? 테스트 실패하면? -> 어디서 문제 발생했는지 찾아내야됨. ->클래스, 코드 너무 많아
+) 파싱 : 문자열로 된 데이터 -> 프로그램이 이해 가능한 형태로


<단위 테스트>
- 테스트는 작은 단위로 쪼개서 접근 -> 간단히 IDE나 도스창에서 세트스 수행 가능
- 에러가 난다면? -> 코드나, db연결 방법 정도에 문제가 있으니까 원인을 빠르게 찾아 낼 수 있음. ->  시간 세이브 가능
- 사용자의 관리 기능, add()메소드 하나 등으로 단위를 정할 수 있음
- 단위 테스트를 사용 하는 이유 -> 개발자가 설계하고 만든 코드가 원래 의도한 대로 동작하는지 개발자 스스로 빨리 확인 받기 위함임. 개발자 테스트/프로그래머 테스트라고 불림


<자동 수행 테스트 코드>
- 테스트 자동으로 수행되도록 코드로 만들어지는 것이 중요함 <- 자주 반복할 수 있으니까 + 만들어 둔 기능에 대한 테스트가 있다면 빠르게 확인 가능함.


<UserDaoTest의 문제점>
1. 수동 확인 작업의 번거로움 ->> 테스트 수행하는 과정, 입력 데이터의 준비는 모두 자동. but 눈으로 일일이 확인해야함. 입력한 값과 가져온 값이 일치하는지 확인해주지 않음. 콘솔에 값만 출력할 뿐
2. 실행 작업의 번거로움 ->> 아무리 간단한 main()메소드라고 해도, 매번 그걸 실행하는 건 번거로운 일


## 테스트 검증의 자동화
- 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트를 만들면, 개발한 애플리케이션은 수정을 하고 나서도 테스트를 모두 돌려보면 되기때문에 개발자 입장에서는 안심이 됨 + 테스트를 통해 변경에 영향을 받는 부분이 정확히 확인된다면 빠르게 조치를 취할 수 있음


<테스트의 효율적인 수행 & 결과 관리>
- main()메소드를 이용한 테스트 작성 방법만으로는 애플리케이션 규모가 커짐, 테스트 개수가 많아지면 테스트를 수행하는 일이 점점 부담이 됨. <- main() 메서드로 직접 실행하고 결과를 수동으로 확인해야 하니까

<JUnit 테스트로 전환>
- JUnit는 프레임 워크. (개발자가 만든 클래스에 대한 제어 권한을 넘겨받아서, 주도적으로 애플리케이션의 흐름을 제어함)
- 프레임워크에서 동작하는 코드는 main()메소드, 오브젝트 만들어 실행시키는 코드 모두 필요 없음.

<테스트 메소드 전환>
- JUnit 프레임워크가 요구하는 조건
   1. 메소드가 public으로 선언돼야 함 <- JUnit은 리플렉션(Reflection) 이라는 기능으로 테스트 메소드를 찾아서 실행함. 리플렉션은 접근 제한자가 있으면(ex. private, protected) 해당 메소드를 실행하지 못하거나 접근이 제한됨.
   2. 메소드에 @Test라고 애노테이션을 붙여줘야함 <- JUnit은 “어떤 메소드를 테스트로 실행할지”를 자동으로 구분해야 함. 그런데 Java는 단순히 “이름이 test로 시작하는 메소드” 같은 규칙만으로 모든 경우를 구분하기 어렵기 때문.
 <img width="565" height="326" alt="{29260B54-AC21-4805-A21F-386751F3AB66}" src="https://github.com/user-attachments/assets/6c58e6cc-20e2-40d4-9455-2d15b318884a" />



<검증 코드 전환>


<img width="390" height="46" alt="image" src="https://github.com/user-attachments/assets/b1845ab6-481f-4a3f-a606-4430ac8b03b6" />

if 문장의 기능을 JUnit이 제공해주는 assertThat이라는 스태틱 메소드를 이용해서 밑에와 같이 변경 가능

<img width="351" height="38" alt="{DC4F932D-37EA-4E01-B696-B08AC0F2F245}" src="https://github.com/user-attachments/assets/57d86a03-cdeb-4dab-a483-29e487f2e619" />

-> assertThat() 메소드는 첫 번째 파라미터의 값응ㄹ 뒤에 나오는 매처-라고 불리는 조건으로 비교해서 일치하면 다음으로 넘기고, 일치하지않으면 테스트가 실패하도록 만들어 줌
"테스트 성공"이라는 메시지를 출력할 필요 없음 -> JUnit이 테스트를 실행하고나면 테스트 결과를 다양한 방법으로 알려주기 때문

```
public class CalculatorTest {

    // 테스트 대상 메소드
    public static int add(int a, int b) {
        return a + b;
    }

    // main() 메소드 테스트
    public static void main(String[] args) {
        int result = add(2, 3);

        if (result == 5) {
            System.out.println("테스트 성공!");
        } else {
            System.out.println("테스트 실패!");
        }
    }
}
```


```
import static org.junit.Assert.*;  // assertEquals() 사용
import org.junit.Test;

public class CalculatorTest {

    // 테스트 대상 메소드
    public static int add(int a, int b) {
        return a + b;
    }

    // 테스트 메소드
    @Test
    public void testAdd() {
        // add(2, 3)의 결과가 5인지 자동으로 검증
        assertEquals(5, add(2, 3));
    }
}
```
```
✔ testAdd() PASSED  ✅   // 성공 시  
✘ testAdd() FAILED (expected 5 but was 4) ❌  // 실패 시
```


## 2.3 개발자를 위한 테스팅 프레임 워크 JUnit

- 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용함.


<IDE = Integrated Development Environment>

- 통합 개발 환경이라고 부르고, 코드 작성 + 실행 + 테스트 + 디버깅을 한 곳에서 할 수 있는 도구.
  - 테스트의 총 수행시간, 실행한 테스트의 수, 테스트 에러의 수, 테스트 실패의 수 를 확인
  - 어떤 테스트 클래스를 실행 했는지도 알 수 있음
  - 테스스 메소드, 클래스 테스트 수행에 걸린 시간 알 수 있음.

<빌드 툴>
- JUnit 플러그인이나 테스크를 이용해 JUnit 테스트를 실행 할 수있음.
- 테스트 실행 결과는 옵션에 따라 HTML이나 텍스트 파일로 제공됨.


<테스트 결과의 일관성>

- 테스트를 실행 하기 전에 항상! DB의 USER 테이블 데이트를 모두 삭제했어야 했음. -> 외부 상태에 따라 테스트 성공여부가 달라짐 -> 변경사항이 없다면 테스트는 항상 동일한 결과 값을 내야하는데,,
  - delet All()메소드 추가 -> 파라미터 바인딩 없어서 더 단순함
  - getCount() 메소드 추가 -> USER 테이블의 레코드 개수를 돌려줌
    
 
<포괄적인 테스트>

1. getCount() 테스트
무엇을 테스트? -> 객체가 현재 갖고 있는 값을 제대로 반환하는지 확인하는 테스트
  - 단순히 저장된 값을 읽어오는 메소드 검증
  - 예외 상황 없음

2. addAndGet() 테스트 보완
- 무엇을 테스트? -> 내부 값을 더한 후, 그 결과가 정확한지 다양한 경우(양수, 0, 음수 등)까지 체크하는 테스트
  - 상태 변화를 동반함 (값을 변경함)
  - 입력값 다양성에 따른 정상 동작 확인
  - 숫자를 더하는 로직의 정상 작동 검증

3. get() 예외조건 테스트
- 무엇을 테스트 -> 잘못된 입력(예: 인덱스 범위 초과) 시 예외가 제대로 발생하는지 검증하는 테스트
  - 정상 동작뿐 아니라 오류 상황에 대한 처리 검증
  - 예외가 발생해야 하는 케이스를 명시적으로 확인
  - 프로그램이 비정상 상태에 빠지지 않고 적절히 처리하는지 확인


<TDD>
- 테스트 주도 개발
   - 만들고자 하는 기능의 내용 + 만들어진 코드 검증할수 있는 테스트 코드 + 테스트 성공하게 해줌
   - 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화 함.
- 테스트를 빼먹지 않고 꼼꼼하게 만들어 낼 수 있음 <- 테스트를 먼저 만들고, 테스트가 성공하도록 하는 코드만 만드는 식이니까
- 테스트 작성 시간 과 애플리케이션 코드를 작성하는 시간의 간격이 짧음



<테스트 코드 개선>

- @Before
  - 각 테스트 메소드가 실행되기 전에 반드시 한 번씩 실행되는 메소드를 지정할 때 사용
  - 왜 쓸까? -> 테스트할 때 매번 똑같은 초기 상태(객체 생성, 변수 초기화 등)를 만들기 위해 중복 코드를 줄이고, 테스트 간 상태 격리를 위해서
- 픽스처
  - 테스트를 실행하는 데 필요한 초기 환경이나 상태, 즉 “테스트 준비물”을 의미
  - 왜 중요? -> 테스트의 신뢰성을 높이기 위해 테스트 시작 전 항상 동일한 상태에서 시작해야 하니까.
  -  @Before 로 설정하는 초기값, 객체 생성 등이 바로 픽스처를 준비하는 작업
 

## 2.4 스프링 테스트 적용
- 애플리 케이션 컨텍스트가 만들어질땐 모든 싱글통 빈 오브젝트를 초기화 함.
- 어떤 빈은 초기화 작업때문에 시간이 많이 걸림, 독자적으로 많은 리소스를 할당하거나, 독립적인 스레드를 띄우기도 함.

<스프링 테스트 컨텍스트 프레임워크 적용>

<img width="567" height="301" alt="image" src="https://github.com/user-attachments/assets/7c653e39-7954-4400-bcd1-cb6c55181282" />

- ->@RunWith는 JUnit 프레임워크의 테스트 실행방법을 확잘 할 때 사용하는 애노테이션.
-  SpringJUnit4ClassRunner라는 JUnit용 테스트 컨텍스트 프레임워크 확장 클래스를 지정해주면, JUnit이 테스트를 진행하는 중에 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행함.
-  @ContextConfiguration은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지


<테스트 클래스의 컨텍스트 공유>

- 수 백개의 테스트 클래스, 모두 같은 설정파일을 사용하더라도 테스트 전체에 걸쳐 한 개의 애플리케이션 컨텍스트만 만들어져 사용 -> 테스트 성능이 대폭 향상


<@Autowired>
- 스프링 컨테이너가 관리하는 빈(Bean) 객체 중에서 해당 타입에 맞는 객체를 찾아서 자동으로 주입해줍니다.
- 의존성 주입 자동화
- 개발자가 직접 객체를 new로 만들거나 할당하지 않아도, 스프링이 필요한 객체를 찾아서 넣어줌.
- @Autowired 위치
  - 필드 위
  - 생성자 위 
  - 세터 메소드 위
 

<DI와 테스트>

- 사용 이유
  - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없기 때문
    - new 대신 사용 -> 들어가는 시간, 비용 부담 줄여줄 수 있음
  - 클래스의 구현 방식은 바뀌지 않는다 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있기 때문
  - 테스트 때문
    - 효율적인 테스트, 범위는 좁게
- +) DI는 애플리케이션 켄텍스트 같은 스프링 컨테이너에서만 할 수 있는 작업은 아님
   - 테스트 코드 내에서 이를 이용해서 직접 DI해도 됨 (=UserDao가 사용할 DataSource 오브젝트를 테스트 코드에서 변경 할 수 있다-라는 뜻)
 
  

<테스트를 위한 별도의 DI 설정>

- 테스트 코드에서 빈 오브젝트에 수동으로 DI하는 방법 장점보다 단점 더 많음
  - 왜? -> 코드가 많아져서 번거로움, 애플리케이션 켄텍스트도 매번 새로 만들어야 하니까
  - 테스트 전용 설정파일을 따로 만들어 두는 방법 사용하자
          - 하나는 서버에서 운영용, 다른 하나는 테스트에 적합하게 준비된 DB를 사용하는 가벼운 DataSource가 빈으로 등록되게 하는 용


  ## 학습 테스트로 배우는 스프링

  <장점>
  - 다양한 조건에 따른 기능을 손쉽게 확인해 볼 수 있음
  - 학습 테스트 코드를 개발 중에 참고 할 수 있음
  - 프레임 워크나 제품을 업그레이드할 때 호환성 검증을 도와줌
  - 테스트 작성에 대한 좋은 룬련이 됨.
  - 공부하는 과정 즐거움~
 
  <버그 테스트>
  - 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트
    - 장점
       - 테스트 완성도 높여줌
       - 버그의 내용을 명확하게 분석
       - 기술적인 문제를 해결하는데 도움이 됨


  






 








  




  







