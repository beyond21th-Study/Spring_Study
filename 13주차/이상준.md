[ week13, Spring Study 6.9까지 ]


[ 애노테이션 트랜잭션 속성과 포인트컷 ]

* 포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄적으로 적용하는 방식은 복잡한 트랜잭션 속성이 요구되지 않는 한 대부분의 상황에 잘 들어맞는다.

* BUT 가끔은 클래스나 메소드에 따라 제각각 속성이 다른, 세밀하게 튜닝된 트랜잭션 속성을 적용해야 하는 경우도 있음. 

* 이런 경우라면 메소드 이름 패턴을 이용해서 일괄적으로 트랜잭션 속성을 부여하는 방식은 적합하지 않음. -> 일일이 포인트컷 어드바이스 추가하면 지저분해짐.



{ 트랜잭션 애노테이션 }

* @Transactional
￼
￼

* @Transactional 애노테이션의 타깃은 메소드와 타입이다. 따라서 메소드 클래스, 인터페이스에 사용할 수 있다.

* @Transactional을 트랜잭션 속성정보로 사용하도록 지정하면 스프링은 @Transactional이 부여된 모든 오브젝트를 자동으로 타깃 오브젝트로 인식함.

* 이때 사용되는 포인트컷은 TransactionalAttributeSourcePointcut임. 스스로 표현식과 같은 선정기준을 갖고 있진 않다.

* 대신 @Transactional이 타입 레벨이든 메소드 레벨이든 상관없이 부여된 빈 옵젝을 모두 찾아서 포인트컷 선정 결과로 돌려줌.-> 포인트컷의 자동등록에도사용됨.





{ 트랜잭션 속성을 이용하는 포인트컷 }

* @Transactional 애노테이션 사용시 어드바이저 동작방식 보여줌. -> 트랜잭션 속성 가져오는 AnnotationTransactionalAttributeSource 사용함.

* 메소드마다 다르게 설정할 수 있어 매우 유연한 트랜잭션 속성 설정이 가능. -> 매우 세밀한 트랜잭션 속성 제어 가능.

￼

* BUT 코드는 지저분해지고, 동일한 속성 정보를 가진 애노테이션을 반복적으로 메소드마다 부여해주는 바람직하지 못한 결과 초래가능.





{ 대체 정책 }

* 그래서 스프링은 @Transactional을 적용할 때 4단계의 대체 정책을 이용하게 해줌,

* 메소드의 속성 확인할 때 타깃 메소드, 타깃 클래스, 선언 메소드, 선언 타입(클래스, 인터페이스)의 순서에 따라서 @Transactional이 적용됐는지 차례대로 확인하고, 가장 먼저 발견되는 속성정보를 사용하게 하는 방법이다.

* 타깃 메소드에 @Transactional 확인 후 만약 없다면 다음 대체 후보인 타깃 클래스에 부여된 @Transactional 부여되어 있으면 이를 속성으로 사용함.

* 아래 그림은 @Transactional을 부여할 수 있는 위치는 총 6개다
￼

* 타깃 옵젝인 [5], [6] @Transactional의 첫번째 후보. 여기서 애노테이션이 발견되면 바로 메소드의 트랜잭션 속성으로 사용함.

* 미 발견시 다음인 [4] 확인 함. 이를 통해 클래스에 부여된 해당 클래스 모든 메소드의 공통적으로 적용되는 속성이 될 수 있음. 
    * 메소드 레벨에 없다면 클래스 레벨의 속성을 사용할 것이기 때문.

* 메소드가 여러 개라면 클래스 레벨의 @Transactional이 부여하는것이 편함.
    * 특정 메소드만 공통 속성을 따르지 않으면 해당 메소드에 추가로 @Transactional를 부여해주면됨.

* 대체 정책에서 지정한 수선서에 따라서 항상 메소드에 부여된 @Transactional이 가장 우선이기 때문에 @Transactional이 붙은 메소드는 클래스 레벨의 속성을 무시하고 메소드 레벨의 속석을 사용할 것이다.

* 타깃 클래스에서 발견 못하면, 인터페이스로 넘어감. [2], [3]을 확인함. -> 여기도 없으면 [1]로 감.

* @Transactional을 사용하면 대체 정책을 잘 활용해 애노테이션 자체는 최소한으로 사용하면서 세밀한 제어가 가능.

* 기본적으로 타깃 클래스보다는 인터페이스에 두는 게 바람직함.
    * 구현 클래스가 바뀌더라도 트랜잭션 속성을 유지할 수 있다는 장점이 있음.

* BUT, 인터페이스를 사용하는 프록시 방식의 AOP가 아닌 방식으로 적용하면 타깃 클래스에 하는것을 권장.



{ 트랜잭션 애노테이션 사용을 위한 설정 }

￼
* 이 태그 하나로 어드바이저, 어드바이스, 포인트컷, 애노테이션을 이용하는 트랜잭션 속성정보가 등록됨.




[ 트랜잭션 애노테이션 적용 ]

* 세밀한 트랜잭션 설정 뿐 아니라 직관적이고 간단하다고 생각해서 사용하는 경우도 많음.

*  다만 트랜잭션 적용 대상을 손쉽게 파악할 수 없고, 사용 정책을 잘 만들어두지 않고, 무분별하게 사용되거나 자칫 빼먹으면 안된다.
    * 트랜잭션이 적용되지 않았다는 사실은 파악하기 어려움.

* 다행히 일부는 티가 나지만 JDBC를 직접 사용하는 기술의 경우는 트랜잭션 없이도 DAO가 동작할 수 있기 때문에 주의해야함.




￼

* 위의 두 가지 속성 중에서 많이 사용되는 한 가지를 타입 레벨에 공통 속성으로 지정해주고, 나머지 속성은 개별 메소드에 적용해야 함.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       


￼



￼

* 위위의 그림과 같이 @Transactional을 그대로 두고 위의 그림처럼 타깃 클래스에 @Transactional을 넣은 테스트 결과는?
    * 대체 정책의 순서에 따라 클래스에서 정의된 모든 모소드의 트랜잭션은 디톨트 속성을 띄게됨.

    * 그래서 인터페이스의 getAll() 메소드에 부여한 읽기전용 속성은 무시되고, 읽기전용 속성을 검증하는 readOnlyTransactionAttrubute() 테스트는 실패 !



[ 트랜잭션 지원 테스트 ] 

{ 선언적 트랜잭션과 트랜잭션 전파 속성 }

* 트랜잭션을 정의할 때 지정할 수 있는 트랜잭션 전파 속성은 매우 유용한 개념임.

* 트랜잭션 적용 때문에 불필요하게 코드를 중복하는 것도 피할 수 있고, 애플리케이션을 작은 기능 단위로 쪼개서 개발할 수 있다.

* 예를 들어, add() 메소드는 트랜잭션 속성이 디폴트로 지정되어 있으므로 트랜잭션 전파 방식은 REQUIRED다. 만약 add() 메소드가 처음 호출되는 서비스 계층의 메소드라면 한 명의 사용자를 등록하는 것이 하나의 비즈니스 작업 단위가 된다. 

* 이때는 add() 메소드가 실행되기 전에 트랜잭션이 시작되고 add() 메소드를 빠져나오면 트랜잭션이 종료되는 것이 맞다. -> DB 트랜잭션은 단위 업무와 일치해야 하기 때문.

* BUT 작업 단위가 다른 비즈니스 로직이 있을 수 있음.
    * 예를 들어, 그날의 이벤트의 신청 내역을 모아서 한 번에 처리하는 기능이 있다고 해보면,  처리되지 않은 이벤트 신청정보를 모두 가져와 DB에 등록하고 그에 따른 정보를 조작해주는 기능임.

    * 그런데 신청정보의 회원가입 항목이 체크되어 있는 경우에는 이벤트 참가자를 자동으로 사용자로 등록해줘야함. -> 하루치 이벤트 신청 내역을 처리하는 기능은 반드시 하나의 작업 단위로 처리되어야 함.

    * 직접 UserDao의 add() 메소드를 사용할 수 있지만, 그보다는 UserService의 add() 메소드를 이용해 사용자 등록 중 처리해야 할, 디폴트 레벨 설정과 같은 로직을 적용하는 것이 바람직함.

* 트랜잭션 전파라는 기법을 사용했기 때문에 UserService의 add()는 독자적인 트랜잭션 단위가 될 수도 있고, 다른 트랜잭션의 일부로 참여할 수도 있다. 

* 트랜잭션의 전파 방식을 이용할 수 없었다면 어떻게 될까?
    * UserService의 add() 메소드는 매번 트랜잭션을 시작하도록 만들어졌을 것이고, 이 때문에 processDailyEventRegistration() 등의 메소드에서 호출해서 사용할 수 없었을 것이다.
    * processDailyEventRegistration()에서  사용자 등록 기능이 필요하긴 하지만 사용자 등록 작업도 같은 트랜잭션에 넣어야하는데 add()메소드는 독자적인 트랜잭션을 만들어버리기 때문에 중복이 일어나고 코드 관리가 불편함.

* 그래서 그림 6-25는 add() 메소드에 REQUIRED 방식의 트랜잭션 전파 속성을 지정했을 때 트랜잭션이 시작되고 종료되는 경계를 보여줌.

* 이 덕분에 사용자 등록 가능이 다양한 비즈니스 트랜잭션에서 사용되더라도 add() 메소드는 하나만 존재하면 되고 불필요한 코드 중복이 일어나지 않는다.

￼

* AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고 속성을 지정할 수 있게 하는 방법을 “ 선언적 트랜잭션(declarative transaction) “ 이라고 함.

* 반대로 TransactionTemplate이나 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법은 “ 프로그램에 의한 트랜잭션(programmatic transaction) “ 이라고 함.

* 스프링은 두 가지 모두 지원하지만 특별한 경우가 아니라면 선언적 방식의 트랜잭션을 사용하는 것이 바람직함.

* 컴포넌트 기반의 서비스를 지향하던 EJB의 특성상 트랜잭션 전파가 가능한 선언적인 트랜잭션은 중요한 기능이었다.
    * EJB 컴포넌트가 아닌 평범한 자바 클래스로 만든 옵젝에도 선언적 트랜잭션을 적용할 수 있음.
    * 트랜잭션 추상화를 제공하기 때문에 EJB처럼 특정 트랜잭션 기술과 환경에 종속되지도 않는다.




{ 트랜잭션 동기화와 테스트 }

* 이렇게 트랜잭션의 자유로운 전파와 그로 인한 유연한 개발이 가능할 수 있었던 기술적인 배경엔 AOP가 있음.

* AOP 덕분에 프록시를 이용한 트랜잭션 부가기능을 간단하게 애플리케이션 전반에 적용할 수 있었음.

* 또 중요한 기술적인 기반인 스프링 트랜잭션 추상화다.
    * 데이터 액세스 기술에 상관없이.
    * 트랜잭션 기술에 상관없이 DAO에서 일어나는 작업들을 하나의 트랜잭션으로 묶어서 추상 레벨에서 관리하게 해주는 트랜잭션 추상화가 없었다면 AOP를 통한 선언적 트랜잭션이나 트랜잭션 전파 등은 불가능 했을 것이다.




{ 트랜잭션 매니저와 트랜잭션 동기화 }

* 트랜잭션 추상화 기술의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.

* PlatformTransactionManager 인터페이스를 구현한 트랜잭션 매니저를 통해 구체적인 트랜잭션 기술의 종류에 상관없이 일괁된 트랜잭션 제어가 가능했음.
    * 또한 트랜잭션 동기화 기술이 있었기에 시작된 트랜잭션 정보를 저장소에 보관해뒀다가 DAO에서 공유할 수 있었다.

* 트랜잭션 동기화 기술은 트랜잭션 전파를 위해서도 중요한 역할을 함.
    * 진행중인 트랜잭션이 있는지 확인하고, 트랜잭션 전파 속성에 따라 이에 참여할 수 있도록 만들어 주는 것도 트랜잭션 동기화 기술 덕분임.

* 선언적 트랜잭션이 훨씬 편해서 트랜잭션 매니저를 직접 이용하는 코드를 작성할 필요가 없었지만 트랜잭션 매니저를 이용해 트랜잭션에 참여하거나 트랜잭션을 제어하는 방법을 사용할 수도 있음.
    * 바로바로 테스트!

* 테스트 컨텍스트를 이용한 테스트에서는 @Autowired를 이용해 애플리케이션 컨텍스트에 등록된 빈을 가져와 테스트 목적으로 활용할 수 있었다. 그러면 당연히 트랜잭션 매니저 빈도 가져올 수 있다.

￼

* 따라서 아래 그림처럼 @Autowired를 사용해 테스트 사용할 수 있다.

￼


* 테스트 메소드 추가

￼

* UserService의 모든 메소드에는 트랜잭션을 적용했으니 3개 만들어질 것이다. 각 메소드가 모두 독립적인 트랜잭션 안에서 실행된다.

* 실행시 기존 진행중인 트랜잭션이 없고 전파 속성은 REQUIRED라서 새로운 트랜잭션이 실행되고, 종료하는 순간 트랜잭션은 커밋되면서 종료될 것이다.



{ 트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어 }

* 세 개의 메소드 모두 트랜잭션 전파 속성이 REQUIRED이니 이 메소드들이 호출되기 전에 트랜잭션이 시작되게만 한다면 가능함.

* UserService에 새로운 메소드르르 만들고 그 안에서 deleteAll()과 add()를 호출한다면 물론 가능함. 
    * UserService의 모든 메소드는 트랜잭션 경계가 되니 새로 만든 메소드에서 시작한 트랜잭션이 메소드로 묶여서 하나의 트랜잭션 안에서 동작하게 될 것.

* BUT 메소드를 추가하지 않고도 테스트 코드만으로 세 메소드의 트랜잭션을 통합하는 방법이 있음.
    * 테스트 메소드에서 UserService의 메소드를 호출하기 전에 트랜잭션을 미리 시작해주면 됨.

    * 전파는 트랜잭션 매니저를 통해 트랜잭션 동기화 방식이 적용되기 때문에 가능함

    * 테스트에서 트랜잭션 매니저를 이용해 트랜잭션을 시작시키고 이를 동기화해주면 된다.




￼

* 테스트 코드에서 트랜잭션 매니저를 이용해서 트랜잭션을 만들고 그 후에 실행되는 UserService의 메소드들이 같은 트랜잭션에 참여하게 만들 수 있음.

* 세 개의 메소드 속성이 REQUIRED이므로 이미 시작된 트랜잭션이 있으면 참여하고 새로운 트랜잭션을 만들지 않는다.




{ 트랜잭션 동기화 검증 }

* 세 개의 메소드가 테스트 코드 내에서 시작된 트랜잭션에 참여하고 있는지는 알 수 없다. -> 트랜잭션의 속성을 변경해서 이를 증명해볼 것.

* 트랜잭션 속성 중에 읽기전용과 제한시간 등은 처음 트랜잭션이 시작할 때만 적용되고 그 이후에 참여하는 메소드의 속성은 무시됨.(아래 그림처럼)

￼

* 테스트는 예외 발생으로 실패할 것이다. -> 읽기전용 트랜잭션에 대해 쓰기 작업을 했을 때 발생하는 예외.
    * 예외 발생위치는 deleteAll() 메소드를 호출한 곳인데 이것으로 코드 내에서 시작한 트랜잭션에 deleteAll() 메소드가 참여하고 있다는 것을 알 수 있음.

* 테스트를 통해 확인할 수 있듯이 스프링의 트랜잭션 추상화가 제공하는 트랜잭션 추상화가 제공하는 트랜잭션 동기화 기술과 트랜잭션 전파 속성 덕분에 테스트도 트랜잭션으로 묶을 수 있다.





* 이런 방법은 선언적 트랜잭션이 적용된 서비스 메서드에만 적용되는 것이 아니다. JdbcTemplate과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 동일한 영항을 미친다.

* 개념은 조금 다르지만 JdbcTemplate의 메소드 단위로 마치 트랜잭션 전파 속성이 REQUIRED인 것 처럼 동작한다고 볼 수 있다.


￼

* 트랜잭션이라면 당연히 롤백도 가능해야 함.

￼

* UserService의 add() 작업이 테스트에서 시작한 트랜잭션에 참여하고 있으므로 테스트에서 만든 트랜잭션을 롤백하면 당연히 add() 작업도 롤백되어야 한다.
    * 지금 테스트 돌리면 성공할 것.

* rollback() 대신 commit()을 하면 결과가 어떻게 달라지는지도 확인해보자.



* 테스트에서 트랜잭션을 시작하거나 조작할 수 있는 기능은 매우 유용함.

* 테스트 코드에서 미리 트랜잭션을 시작해놓으면 직접 호출하는 DAO 메소드도 하나의 트랜잭션으로 묶을 수 있다.

* 트랜잭션 결과나 상태를 조작하면서 테스트하는 것도 가능함.

* 예를 들어, 하이버네이트 같은 ORM에서 세션에서 분리된(detached) 엔티티의 동작을 확인할 때도 유용함.

* 테스트 메소드 안에서 트랜잭션을 여러 번 만들 수도 있음. 트랜잭션 속성에 따라 여러 메소드를 조합해 사용할 때 어떤 결과가 나오는지도 미리 검증 가능함.



{ 롤백 테스트 }

* 테스트 코드로 트랜잭션을 제어해서 적용할 수 있는 테스트 기법이다.

* 롤백 테스트는 테스트 내의 모든 DB 작업을 하나의 트랜잭션 안에서 동작하게 하고 테스트가 끝나면 무조건 롤백해버리는 테스트를 말함.\

* 아래 그림은 전형적인 롤백 테스트코드.

￼
* 롤백 테스트는 DB 작업이 포함된 테스트가 수행되도 DB에 영향을 주지 않기 때문에 장점 많음.

* 간단한 CRUD코드의 테스트는 괜찮지만 복잡한 데이터를 바탕으로 동작하는 기능을 테스트하려면 테스트가 실행될 때의 DB 데이터와 상태가 매우 중요함.

* 문제는 테스트에서 DB에 쓰기 작업을 하는 기능을 실행하면서 테스트를 수행하고 나면 DB의 데이터가 바뀐다는 점이다.

* 결국 DB를 액세스하는 테스트를 위해서 테스트를 할 때마다 테스트 데이터를 초기화하는 번거로운 작업이 필요해짐.

* 이런 이유들 때문에 롤백 테스트는 매우 유용함.
    * 테스트를 진행하는 동안 조작한 데이터를 모두 롤백하고 테스트를 시작하기 전 상태로 만들어주기 때문.

    * 어떤 경우에도 트랜잭션을 커밋하지 않기 때문에 테스트가 성공하든 실패하든 상관없다. 예외가 발생해도 괜찮음.

    * 물론, 테스트에 따라 고유한 테스트 데이터가 필요한 경우에는 테스트 앞 부분에서 그에 맞게 DB를 초기화하고 테스트를 진행하면 됨.

* 심지어 여러 개발자가 하나의 공용 테스트용 DB를 사용할 수 있게도 해준다. 적절한 격리수준만 보장해주면 동시에 여러 개의 테스트가 진행되도 상관없음.

* 이처럼 테스트에서 트랜잭션을 제어할 수 있기 때문에 얻을 수 있는 가장 큰 유익이 있다면 바로 이 롤백 테스트임.

* BUT, DB의 트랜잭션 처리 방법에 따라 롤백이 커밋보다 더 많은 부하를 주는 경우도 있으니 단지 성능 때문에 롤백 테스트가 낫다고 볼 수 없음.





{ 테스트를 위한 트랜잭션 애노테이션 }

* @Transactional 애노테이션을 타깃 클래스 또는 인터페이스에 부여하는 것만으로 트랜잭션을 적용해 주는건 매우 편한 기술임.
    * 그런데 이 편리한 방법을 테스트 클래스와 메소드에도 적용할 수 있음.

* @ContextConfiguration을 클래스에 부여하면 테스트를 실행하기 전에 스프링 컨테이너를 초기화하고, @Autowired 애노테이션이 붙은 필드를 통해 필요한 빈에 자유롭게 접근할 수 있다. 



- @Transactional

* 테스트에도 @Transactional을 적용할 수 있다. 테스트 클래스 또는 메소드에 @Transactional 애노테이션을 부여해주면 마치 타깃 클래스나 인터페이스에 적용된 것처럼 테스트 메소드에 트랜잭션 경계가 자동으로 설정됨.
    * 이를 활용하면 테스트 내에서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있음 

* @Transactional에는 모든 종류의 트랜잭션 속성을 지정할 수 있기도 함.

* 테스트의 @Transactional은 앞에서 테스트 메소드의 코드를 이용해 트랜잭션을 만들어 적용했던 것과 동일한 결과를 가져옴.

* 트랜잭션 매니저와 번거로운 코드를 사용하는 대신 간단한 애노테이션만으로 트랜잭션이 적용된 테스트를 손쉽게 만들 수 있는 것이다.

* 물론, 테스트에서 사용하는 @Transactional은 AOP를 위한 것은 아니다. 단지 컨텍스트 테스트 프레임워크에 의해 트랜잭션을 부여해주는 용도로 쓰일 뿐임.

* BUT 기본적인 동작방식과 속성은 UserService 등에 적용한 @Transactional과 동일하므로 이해하고 사용하기 쉽다.

￼


￼

* @Transactional은 테스트 클래스 레벨에 부여가능.

* 각 메소드에 @Transactional을 지정해서 클래스의 공통 트랜잭션과는 다른 속성 지정 가능. 메소드의 속성이 클래스의 속성보다 우선함.



- @RollBack

* 테스트 메소드나 클래스에 사용하는 @Transactional은 애플리케이션의 클래스에 적용할 때와 디폴트 속성은 동일함.

* BUT, 테스트용 트랜잭션은 테스트가 끝나면 자동으로 롤백된다는 것. 
    * 기본적으로 테스트가 끝나면 트랜잭션을 강제 롤백되게 기본설정 되어있음.


￼


* 테스트 메소드 안에서 진행되는 작업을 하나의 트랜잭션으로 묶고 싶지만 강제 롤백을 원치 않을때는?

* @Rollback이라는 애노테이션을 이용!

* @Rollback의 기본 값은 true다. 따라서 트랜잭션은 적용되지만 롤백을 원치 않는다면 @Rollback(false)라고 해줘야 함.
￼
* 예외가 발생하지 않는 한 트랜잭션은 커밋된다.





- @TransactionConfiguration

* @Transactional은 테스트 클래스에 넣어서 모든 테스트 메소드에 일괄 적용할 수 있지만 @Rollback 애노테이션은 메소드 레벨에만 적용할 수 있음.

* @TransactionConfiguration을 이용하면 모든 메소드에 @Rollback(false)를 안넣어도 된다.

￼
* @TransactionConfiguration의 디폴트 롤백 속성은 false로 두고 테스트 메소드 중 롤백 할 것만 true이므로 이때는 트랜잭션을 롤백함.




- NotTransactional과 Propagation.NEVER

* 필요하지 않은 트랜잭션이 만들어지는 것이 꺼림칙하거나 트랜잭션이 적용되면 안 되는 경우에는 해당 메소드에만 테스트 메소드에 의한 트랜잭션이 시작되지 않도록 만들어 줄 수 있다.

* @NotTransactional을 테스트 메소드에 부여하면 클래스 레벨의 @Transactional 설정을 무시하고 트랜잭션을 시작하지 않은 채로 테스트를 진행한다.
    * 물론 테스트 안에서 호출하는 메소드에서 트랜잭션을 사용하는 데는 영향을 주지 않음.

    * BUT, 스프링 3.0에서 제거 대상이라 트랜잭션 테스트와 비 트랜잭션 테스트를 아예 클래스를 구분해서 만들도록 권장함.

* @NotTransactional 대신 @Transactional 전파 속성으로 지정하는 방법도 있음.                
￼



- 효과적인 DB 테스트

* 일반적으로 의존, 협력 옵젝을 사용하지 않고 고립된 상테에서 테스트를 진행하는 단위 테스트와 DB 같은 외부의 리소스나 여러 계층의 클래스가 참여하는 통합 테스트는 아예 클래스를 구분해서 따로 만드는게 낫다.

* UserServiceTest는 단지 테스트를 만드는 다양한 예제를 보여주기 위해 단위 테스트와 통합 테스트, 학습 테스트를 함께 갖고 있지만, 실전에서는 깔끔하게 클래스를 분리하는 것이 바람직하다.

* DB가 사용되는 통합 테스트를 별도의 클래스로 만들어둔다면 기본적으로 클래스 레벨에 @Transactional을 부여해준다.

* DB가 사용되는 통합 테스트는 가능한 한 롤백 테스터로 만드는게 좋다. 애플리케이션의 모든 테스트를 한꺼번에 실행하는 빌드 스크립트 등에서 테슽에서 공통적으로 이용할 수 있는 테스트 DB를 셋업해주고, 각 테스트는 자신이 필요한 테스트를 보충해서 진행.

* 테스트는 어떠한 경우에도 서로 의존하면 안된다. 코드가 바뀌지 않는 한 어떤 순서로 진행되더라도 테스트는 일정한 결과를 내야 함. 

* 트랜잭션을 지원하는 롤백 테스트는 매우 유용한 도구가 될 것.
