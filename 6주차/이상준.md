[ week6 Spring-Study  ]


- 서비스 추상화(Service Abstraction)에 대해서 알아보자


- 스프링 애플리케이션의 빈이 존재하는 계층 구조
    * 3개의 전형적인(stereotype) 애노테이션을 사용하는 애플리케이션 빈의 위치
        * @Controller —> Presentation(Web, UI) Layer
        * @Service —> Business(Service, Application) Layer
        * @Repository —> Persistence(Data Access, Infra) Layer

    * 개발자에게 서비스는?
        * 클라이언트에게 서비스를 제공해주는 오브젝트나 모듈.
        * 서비스는 일반적으로 상태를 가지지 않음(상태없는(stateless) 싱글톤 스프링 빈을 사용하기 적합)
            * 멀티쓰레드로  여러개의 요청을 처리하기때문.
            * Ex) @Compoent, @Service
            * 
- 서비스의 종류
    * 애플리케이션 서비스(application service)
        * 애플리케이션 계층에 존재하는 서비스. 
    * 도메인 서비스(domain service)
        * 비즈니스 로직을 사용해서 엔티티같은 도메인로직에 집어넣는 서비스.
    * 인프라 서비스(infrastructure service)
        * 도메인/애플리케이션 로직에 참여하지 않는, 기술을 제공하는 서비스
        * Ex) 메일, 캐시, 트랜잭션, 메시징 등…

- ** 서비스 추상화의 서비스는? 서비스 애노테이션이 아니라 인프라 서비스에서 기술을 제공 하는 서비스를 뜻함.
    * 정의 :  하위 시스템의 공통점을 뽑아내서 분리시키는 것으로, 하위 시스템이 무엇인지 알지 못하거나 변경되더라도 일관된 방식으로 접근할 수 있게 한다. 

- ** 인프라 서비스 범위
    * 메일 발송, 캐시 관리, 데이터베이스 트랜잭션. 메세지 처리 등 비즈니스 로직과 독립적인 기술적 기능들을 포함해야한다. 애플리케이션 서비스는 이러한 인프라 서비스의 도움이 필요하지만, 가능한 인프라 레이어의 구체적인 기술에 의존하지 않아야 한다.

- ** 서비스 추상화의 주요 이점과 단점
    * 이점 :
        * 결합도 감소
        * 기술 은닉 및 교체 용이성
        * 테스트 용이성
        * 비즈니스 로직 집중
    * 단점 :
        * 복잡성 증가 및 가독성 저하
        * 오버헤드 및 성능
        * 과도한 추상화의 함정
        * 기능의 파편화


- 애플리케이션 서비스 도입
    * @Service 빈으로 구성
    * 가장 중요한 도메인/애플리케이션/비즈니스 로직
    * Application/Service Layer에 존재.

- OrderService 코드{를 구현할때 전형적인 의존성 구조}
    * 데이터 액세스 기술의 하나인 JPA에 의존.
    * JPA를 사용하는 Repository 클래스에 의존.
    * JPA Transaction Manager에 의존.

- Order 라는 엔티티 클래스를 사용하는데 JPA엔티티 스타일로 만들었다 -> @Entity* 
    * 컴파일 시점에만 JPA 컴파일타임 라이브러리에 의존
    * 클래스 코드에는 JPA 기술과 관련된 내용이 들어가지 않음
    * JPA를 사용하지 않으면 런타임에는 JPA라이브러리에 의존하지 않음.
    * 엔티티의 동작에는 영향을 주지 않기 때문에 엔티티 클래스를 다른 데이터 기술에서 사용해도 된다.


- Order에서 JPA 메타데이터 분리
    * 그래도 제거하고 싶다면 외부 XML디스크립터를 사용할 수 있다. 


- 특정 기술(JPA)에 의존하지 않는 애플리케이션 서비스 만들기
    * JPA Repository - OrderRepository에 의존하지 않도록 변경.
    * 의존관계 역전(DIP).
        * **SOLID중 하나로, 구체적인 구현체에 의존하지 말고, 추상화(인터페이스)에 의존하라는 뜻.
        * 쉽게말해 “ 언제든 갈까 끼울 수 있는 껍데기(역할)에 의존해야지, 딱딱한 알맹이(구현)에 의존하면 안된다는 뜻이다 “


- Transaction은 데이터 기술에 따라 방법이 다르다.
    * JDBC, MyBatis
        * 어노테이션을 붙이면, Spring이 사용중인 데이터 라이브러리에 맞춰 적절한 구현체를 자동으로 등록해줌.
    * JPA
        * 단순히 SQL을 날리는 것이 아니라, 영속성 컨텍스트(Persistence Context)라는 중간관리자가 존재하여 동작 방식이 조금 다름.
        * JpaTransactionManager는 내부적으로 datasource에 접근 가능해 JPA와 MyBatis를 섞어 쓸때도 하나로 묶어서 트랜잭션을 통합 관리할 수 있음.
    * Jooq 
        * 안전한 SQL 빌더로, Spring Boot환경에서는 보통 JDBC기반의 트랜잭션 매니저에 참여하는 방식을 선호.


- 추상화
    * 구현의 복잡함과 디테일을 감추고 중요한 것만 남기는 기법.
    * 여러 인프라 서비스 기술의 공통적이고 핵심적인 기능을 인터페이스로 정의하고 이를 구현하는 어댑터를 만들어 일관된 사용이 가능하게 만드는 것이 서비스 추상화.


- JDBC 데이터 액세스 기술
    * SQL을 사용하는 JDBC 데이터 처리 코드를 유연하게 작성하도록 도와줌.
    * 일종의 템플릿/콜백
    * 스프링의 JdbcTemplate의 대체 기술
    * DataSourceTransactionManager
        * JDBC의 Connection을 이용하는 트랜잭션 매니저
        * Connection을 리턴하는 DataSource 오브젝트 필요.

- 트랜젝션 프록시
    * ** 스프링이 @Transaction 어노테이션을 처리하는 핵심 동작방식.
    * 쉽게말해, 개발자가 작성한 코드에 트랜잭션 시작과 종료(커밋/롤백)을 직접 넣지 않아도, 스프링이 몰래 ‘가짜 객체(Proxy)’를 만들어서 대신 처리해주는 기술을 말함.
- ** 주의해야 할 점 :
* ** 같은 클래스 내부의 메소드끼리 호출할 때는 트랜잭션이 적용되지 X
* 이유 : 외부에서 호출할 때만 프록시를 거치는데, 내부 호출은 프록시를 거치지 않고 바로 자신의 메소드를 부르기 때문.
* 해결책 :  별도 클래스로 분리하거나, 자기 자신을 주입받아서 호출하는 방식을 사용해야 한다.


- OrderService에서 기술 관련 코드 제거
    * 데이터 기술이 변경되어도 기존 코드는 영향을 받지 않음
    * TransactionTemplate, PlatformTransactionManager와 같은 기술과 연관된 코드가 계속 등장함.
    * 트랜잭션의 시작과 종료는 보통 애플리케이션 서비스 메소드 실행 전후.


- 트랜잭션 테스트
    * 트랜잭션이 필요한 곳에 정확하게 적용되었는지 테스트 하기는 매우 어려움.
    * JDBC처럼 자동 커밋이 되거나 Spring Data JPA처럼 기본 리포지토리 구현에서 트랜잭션을 알아서 적용해주는 기술을 사용할 때 트랜잭션이 바르게 적용되지 않은 것을 놓치지 쉬움.
    * 모든 작업이 성공하면 하나의 트랜잭션으로 진행된 것인지 여러 개의 트랜잭션으로 쪼개진 것인지 확인하기 어려움.
    * 트랜잭션 중간에 실패하는 케이스를 만들 수 있다면 롤백 여부로 확인할 수 있음.


- 데코레이터 패턴(객체지향 디자인 패턴 중 하나)
    * 오브젝트의 코드를 변경하지 않고 새로운 기능을 런타임에 부여하는 디자인 패턴

- 프록시 패턴
    * 타깃을 대신해서 존재하며 접근을 제거하거나 보안, 지연, 원격 접속 등의 기능을 제공.  

- 트랜잭션 프록시
    * OrderService 인터페이스 추출
    * 트랜잭션 부가 기능을 제공하는 OrderServiceTxProxy 프록시

- 트랜잭션 프록시 적용
    * 동일한 OrderService 인터페이스를 구현한 프록시를 OrderClient에 주입

- 스프링이 만들어주는 트랜잭션 프록시
    * @Tranactional 애노테이션이 붙은 클래스의 메소드가 트랜잭션 안에서 실행되도록 프록시를 만들어 줌.


- 스프링의 프록시 AOP
    * AOP는 스프링에서 그다지 성공하지 못한 핵심 기술 중 하나.
    * 활용 용도가 제한적이면서 막상 사용하기는 매우 어려움
    * 스프링이 만들어 놓은 트랜잭션과 보안 기술에서는 유용하게 활용
    * 직접 활용하려면 꽤 많은 학습이 필요함
    * AOP는 아니더라도 데코레이터/프록시 패턴의 동작 원리를 이해하고 필요한 곳에 활용할 수 있음.
****
