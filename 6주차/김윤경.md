- 1. Presentation Layer (표현 계층)
     - 컨트롤러(@Controller, @RestController)**가 위치하는 계층, 사용자 요청을 받고, 응답을 돌려주는 역할
     - 포함되는 Bean -> @Controller, @RestController, @RequestMapping으로 매핑된 클래스
     - 특징 : 비즈니스 로직 없음, 화면/요청 처리만 담당

- 2. Service Layer (서비스 계층)
     - 비즈니스 로직을 담당하는 핵심 계층
     - 포함되는 Bean -> @Service
     - 트랜잭션 관리(@Transactional)가 주로 사용됨
     - 특징 : 여러 Repository 조합하여 로직 수행. 중요한 검증, 도메인 규칙 처리
       
- 3. Repository Layer (저장소 계층)
     - DB에 접근하는 계층, 이 계층을 DAO(Data Access Object) 또는 Repository라 부름
     - 포함되는 Bean -> @Repository
     - 특징 : SQL 실행, 데이터 CRUD, 예외

- 스프링 애플리케이션의 빈은 Controller → Service → Repository 순의 계층 구조 안에서 역할별로 생성되고, ApplicationContext가 이 빈들을 관리한다.

- Service란? -> 비즈니스 로직(업무 로직)**을 담당하는 계층이자 객체. 컨트롤러가 요청을 받으면 그 요청을 처리할 정확한 기능을 제공하는 객체가 Service.

- Controller: "사용자가 주문 요청했어!", Service: “OK! 주문 처리해줄게. 가격 계산하고, 재고 확인하고, DB에 기록하고…” 이런 실제 ‘업무 흐름’을 모두 Service가 처리함. 즉, Controller는 “명령하는 클라이언트”, Service는 “기능을 실제로 수행해주는 모듈(객체)”

- 그럼 왜 스프링이 왜 굳이 Service를 분리할까?
  - Controller가 너무 비대해지는 걸 막기 위해
  - 비즈니스 로직을 따로 관리하기 때문에 유지보수 편함
  - 여러 컨트롤러에서 공통으로 사용하는 로직을 한 곳에서 제공 가능
  - 트랜잭션 등 핵심 기능을 서비스에서 통합 관리 가능 (@Transactional)
 
  - 서비스는 일반적으로 상태를 가지지 않음
````
@Service
public class OrderService {
    private int userId;  // 상태 저장 ❌
}

````

- 왜 상태를 가지면 안 되나?
  - 스프링 서비스 빈은 기본이 싱글톤
  - 애플리케이션 전체에 단 하나만 존재
  - 여러 스레드(사용자 요청)가 동시에 같은 객체를 사용함
       - 상태가 있으면 스레드끼리 서로 데이터 덮어써서 문제가 생김
       - 그래서 서비스는 반드시 무상태(Stateless)여야 함
   
- 서비스의 종류
  - 애플리케이션 서비스
    - 담당책임 : 유즈케이스 실행, 흐름 제어
    - 특징 : 트랜잭션 관리, 여러 도메인 조합
    - 예시 : 주문 생성하기, 회원 가입하기, 결제 요청하기
  - 도메인 서비스
    - 담당책임 : 순수 비즈니스 규칙
    - 특징 : 엔티티/VO만으로 해결 안 되는 로직
  - 인프라 서비스
    - 담당책임 : 기술적 처리, 외부 연동
    - 특징 : 이메일/SMS/API 호출 등 IO
    - 예시 : 이메일 전송, 결제 API 호출, SMS 발송, 파일 업로드
   
- 서비스 추상화란?
  - 기술(외부 시스템)에 의존하는 로직을 인터페이스로 감싸서 애플리케이션 코드가 기술에 종속되지 않도록 만드는 것
  - 이때 기술 의존성이 가장 큰 계층 = 인프라 계층(Infrastructure). 그래서 “추상화해야 하는 대상 1순위”가 인프라 서비스임.

- 왜 인프라 서비스는 추상화해야 할까?
  - ① 외부 기술은 언제든 바뀔 수 있기 때문. ex) 카카오페이 API → 토스페이 API로 변경 -> 이런 변화가 생기면 비즈니스 로직이 깨지면 안 됨. 추상화(인터페이스)를 걸면 교체가 쉬워짐.
  - ② 테스트하기 힘든 로직이 많기 때문.
  - ③ 클린 아키텍처 원칙: “도메인/애플리케이션은 인프라를 직접 의존하지 않는다.” 즉, 도메인은 인프라의 구현을 몰라야 한다.
 


- 애플리케이션 서비스
  - DIP(의존 역전 원칙): 상위 수준 모듈은 하위 수준 모듈에 의존하면 안 된다. 둘 다 추상화에 의존해야 한다. -> 즉, 구현체가 아니라 인터페이스(추상화)에 의존하라.
  - 애플리케이션(Domain + Application Layer)에서 DIP를 적용하면?
    - 애플리케이션 계층(Controller, Service)은 인프라 기술(Repository, 외부 API 구현체)에 직접 의존하면 안 된다. 반드시 “추상화된 인터페이스”를 통해 의존해야 한다. 애플리케이션은 “기술”을 몰라야 함.
   

- ex) order service
  - 문제 상황: OrderService가 기술(JPA)에 의존하고 있음
    - JPA 자체 API(EntityManager)에 의존
    - JPA로 만든 Repository 구현체에 의존
    - JPA용 TransactionManager에 의존
    - -> DIP 위반
- ex) order

  <img width="426" height="160" alt="image" src="https://github.com/user-attachments/assets/cb6845f4-c200-4457-81d6-ec46d24648a2" />

  - @Entity가 붙은 클래스는 오직 ‘도메인 모델’ 역할만 한다
  - JPA 엔티티가 의존하는 것은 “애노테이션뿐”
  - @Entity가 붙은 jpa 엔티티로 작성.
  - 컴파일 시점에만 jpa 라이브러리에 의존.
  - 클래스 코드에는 JPA 기술과 관련된 내용이 들어가지 않음.
  - JPA를 사용하지 않으면 런타임에는 JPA라이브러리에 의존하지 않음
 
 <img width="430" height="136" alt="image" src="https://github.com/user-attachments/assets/a5a1e634-a177-438f-a5ba-0c3bd73f9da6" />
- 도메인 엔티티(Order) = 순수 객체 (POJO)
JPA 매핑 정보 = 별도의 클래스나 XML로 분리

- 특정 기술(JPA)에 의존하지 않는 애플리케이션 서비스 만들기
<img width="470" height="110" alt="image" src="https://github.com/user-attachments/assets/97f77f5a-bf22-4e95-81a5-8dc51fb3eec0" />
- OrderService가 JPA repository 구현체에 의존하지 않도록, 순수한 OrderRepository 인터페이스로 DIP를 적용하자!

  <img width="357" height="132" alt="image" src="https://github.com/user-attachments/assets/3185ef8d-f104-4808-96ea-d77268035192" />


- 트랜잭션은 “데이터 접근 기술”에 따라 방식이 모두 다르다
  - JDBC, JPA, MyBatis, jOOQ -> 각 기술은 트랜잭션을 시작하고, 커밋하고, 롤백하는 방식이 서로 다름. 그래서 트랜잭션 자체도 기술 의존적인 작업임.

- 기술별 트랜잭션 방식 요약
  - JDBC 트랜잭션 : Connection 객체 필요, 수동 commit/rollback
    
````
connection.setAutoCommit(false);
try {
    // SQL 실행
    connection.commit();
} catch(Exception e) {
    connection.rollback();
}
````

- JPA 트랜잭션 : EntityManager 기반 : 트랜잭션이 없으면 영속성 컨텍스트 flush 불가, 트랜잭션 필수
  
````
entityManager.getTransaction().begin();
entityManager.persist(order);
entityManager.getTransaction().commit();
````

- MyBatis 트랜잭션 : SqlSession 기반, 수동 commit/rollback
  
````
SqlSession session = sqlSessionFactory.openSession(false);
try {
    session.insert("saveOrder");
    session.commit();
} catch(Exception e) {
    session.rollback();
}
````

- jOOQ 트랜잭션
- 
````
DSLContext.transaction()

dsl.transaction(config -> {
    DSL.using(config).insertInto(...).execute();
});
````

<img width="455" height="262" alt="image" src="https://github.com/user-attachments/assets/2babbfbd-576b-441c-84cd-3b365fbe9cf6" />

- TransactionManager(정확히는 PlatformTransactionManager)는 DataSource 기반 트랜잭션 매니저(JdbcTransactionManager), JPA 트랜잭션 매니저(JpaTransactionManager) 등 다양한 기술의 트랜잭션 처리 방식을 통합해 “트랜잭션을 관리하는 객체의 추상화”를 제공한다.
- 즉, 각 기술마다 다른 트랜잭션 관리 방식을 스프링이 TransactionManager 인터페이스로 “일원화”해서 서비스 계층이 기술에 종속되지 않도록 만든 것.
<img width="574" height="395" alt="image" src="https://github.com/user-attachments/assets/4c89e282-651d-4f85-8733-521ca6ae6192" />


- JDBC Client
````
String sql = "SELECT * FROM member WHERE id = ?";
Member member = jdbcTemplate.queryForObject(sql, new MemberRowMapper(), id);
````

````
Member member = jdbcClient
    .sql("SELECT * FROM member WHERE id = :id")
    .param("id", id)
    .query(Member.class)
    .single();
````

- “JDBC Client는 Spring이 제공하는 최신 SQL 실행 도구로, 전통적인 JdbcTemplate보다 단순하고 직관적으로 파라미터 바인딩과 결과 매핑을 처리해주는 JDBC 접근 객체

- DataSourceTransactionManager가 하는 일
  - DataSource에서 Connection을 가져옴
  - 오토커밋을 false로 바꿈
  - 트랜잭션 시작
  - 서비스 로직 수행
  - 성공 → commit
  - 실패 → rollback
  - Connection 반환
- 개발자에게는 안 보이지만, @Transactional 쓰면 이 매니저가 내부에서 다 처리함.

- JDBC 데이터 액세스용 구성 정보 : 스프링에서 JDBC 기반으로 DB에 접근하기 위해 반드시 필요한 설정 정보
  - DataSource (필수) : DB 연결 정보를 가진 객체, JDBC의 가장 중요한 구성 요소.  ex) URL, username, password, 드라이버 클래스(driver-class-name)
  - DataSourceTransactionManager (필수는 아니지만 보통 필요) : JDBC 트랜잭션을 관리하는 스프링 트랜잭션 매니저


- OrderService에서 기술 관련 코드 제거
<img width="645" height="350" alt="image" src="https://github.com/user-attachments/assets/a7e1f51c-6696-4b08-858d-e7eb2ef847d3" />
- OrderService에서 기술(JPA/JDBC/MyBatis/트랜잭션 등) 관련 코드를 모두 제거하고,
오직 OrderRepository 인터페이스 같은 추상화에만 의존하도록 변경하는 것이
‘기술 관련 코드 제거’의 의미이다.


-트랜잭션 테스트
<img width="450" height="187" alt="image" src="https://github.com/user-attachments/assets/d89ae8fd-faef-46a4-a285-dbd4a5392cf7" />
- 트랜잭션 테스트는 커밋/롤백 여부, 전파 동작, 예외 처리 시 동작을 검증하는 테스트이며,
스프링에서는 @Transactional, @Rollback, PlatformTransactionManager를 이용해 수행한다.











