- 1. Presentation Layer (표현 계층)
     - 컨트롤러(@Controller, @RestController)**가 위치하는 계층, 사용자 요청을 받고, 응답을 돌려주는 역할
     - 포함되는 Bean -> @Controller, @RestController, @RequestMapping으로 매핑된 클래스
     - 특징 : 비즈니스 로직 없음, 화면/요청 처리만 담당

- 2. Service Layer (서비스 계층)
     - 비즈니스 로직을 담당하는 핵심 계층
     - 포함되는 Bean -> @Service
     - 트랜잭션 관리(@Transactional)가 주로 사용됨
     - 특징 : 여러 Repository 조합하여 로직 수행. 중요한 검증, 도메인 규칙 처리
       
- 3. Repository Layer (저장소 계층)
     - DB에 접근하는 계층, 이 계층을 DAO(Data Access Object) 또는 Repository라 부름
     - 포함되는 Bean -> @Repository
     - 특징 : SQL 실행, 데이터 CRUD, 예외

- 스프링 애플리케이션의 빈은 Controller → Service → Repository 순의 계층 구조 안에서 역할별로 생성되고, ApplicationContext가 이 빈들을 관리한다.

- Service란? -> 비즈니스 로직(업무 로직)**을 담당하는 계층이자 객체. 컨트롤러가 요청을 받으면 그 요청을 처리할 정확한 기능을 제공하는 객체가 Service.

- Controller: "사용자가 주문 요청했어!", Service: “OK! 주문 처리해줄게. 가격 계산하고, 재고 확인하고, DB에 기록하고…” 이런 실제 ‘업무 흐름’을 모두 Service가 처리함. 즉, Controller는 “명령하는 클라이언트”, Service는 “기능을 실제로 수행해주는 모듈(객체)”

- 그럼 왜 스프링이 왜 굳이 Service를 분리할까?
  - Controller가 너무 비대해지는 걸 막기 위해
  - 비즈니스 로직을 따로 관리하기 때문에 유지보수 편함
  - 여러 컨트롤러에서 공통으로 사용하는 로직을 한 곳에서 제공 가능
  - 트랜잭션 등 핵심 기능을 서비스에서 통합 관리 가능 (@Transactional)
 
  - 서비스는 일반적으로 상태를 가지지 않음
````
@Service
public class OrderService {
    private int userId;  // 상태 저장 ❌
}

````

- 왜 상태를 가지면 안 되나?
  - 스프링 서비스 빈은 기본이 싱글톤
  - 애플리케이션 전체에 단 하나만 존재
  - 여러 스레드(사용자 요청)가 동시에 같은 객체를 사용함
       - 상태가 있으면 스레드끼리 서로 데이터 덮어써서 문제가 생김
       - 그래서 서비스는 반드시 무상태(Stateless)여야 함
   
- 서비스의 종류
  - 애플리케이션 서비스
    - 담당책임 : 유즈케이스 실행, 흐름 제어
    - 특징 : 트랜잭션 관리, 여러 도메인 조합
    - 예시 : 주문 생성하기, 회원 가입하기, 결제 요청하기
  - 도메인 서비스
    - 담당책임 : 순수 비즈니스 규칙
    - 특징 : 엔티티/VO만으로 해결 안 되는 로직
  - 인프라 서비스
    - 담당책임 : 기술적 처리, 외부 연동
    - 특징 : 이메일/SMS/API 호출 등 IO
    - 예시 : 이메일 전송, 결제 API 호출, SMS 발송, 파일 업로드
   
- 서비스 추상화란?
  - 기술(외부 시스템)에 의존하는 로직을 인터페이스로 감싸서 애플리케이션 코드가 기술에 종속되지 않도록 만드는 것
  - 이때 기술 의존성이 가장 큰 계층 = 인프라 계층(Infrastructure). 그래서 “추상화해야 하는 대상 1순위”가 인프라 서비스임.

- 왜 인프라 서비스는 추상화해야 할까?
  - ① 외부 기술은 언제든 바뀔 수 있기 때문. ex) 카카오페이 API → 토스페이 API로 변경 -> 이런 변화가 생기면 비즈니스 로직이 깨지면 안 됨. 추상화(인터페이스)를 걸면 교체가 쉬워짐.
  - ② 테스트하기 힘든 로직이 많기 때문.
  - ③ 클린 아키텍처 원칙: “도메인/애플리케이션은 인프라를 직접 의존하지 않는다.” 즉, 도메인은 인프라의 구현을 몰라야 한다.
 


- 애플리케이션 서비스
  - DIP(의존 역전 원칙): 상위 수준 모듈은 하위 수준 모듈에 의존하면 안 된다. 둘 다 추상화에 의존해야 한다. -> 즉, 구현체가 아니라 인터페이스(추상화)에 의존하라.
  - 애플리케이션(Domain + Application Layer)에서 DIP를 적용하면?
    - 애플리케이션 계층(Controller, Service)은 인프라 기술(Repository, 외부 API 구현체)에 직접 의존하면 안 된다. 반드시 “추상화된 인터페이스”를 통해 의존해야 한다. 애플리케이션은 “기술”을 몰라야 함.
   

- ex) order service
  - 문제 상황: OrderService가 기술(JPA)에 의존하고 있음
    - JPA 자체 API(EntityManager)에 의존
    - JPA로 만든 Repository 구현체에 의존
    - JPA용 TransactionManager에 의존
    - -> DIP 위반
- ex) order

  <img width="426" height="160" alt="image" src="https://github.com/user-attachments/assets/cb6845f4-c200-4457-81d6-ec46d24648a2" />

  - @Entity가 붙은 클래스는 오직 ‘도메인 모델’ 역할만 한다
  - JPA 엔티티가 의존하는 것은 “애노테이션뿐”
  - @Entity가 붙은 jpa 엔티티로 작성.
  - 컴파일 시점에만 jpa 라이브러리에 의존.
  - 클래스 코드에는 JPA 기술과 관련된 내용이 들어가지 않음.
  - JPA를 사용하지 않으면 런타임에는 JPA라이브러리에 의존하지 않음
 
 <img width="430" height="136" alt="image" src="https://github.com/user-attachments/assets/a5a1e634-a177-438f-a5ba-0c3bd73f9da6" />
- 도메인 엔티티(Order) = 순수 객체 (POJO)
JPA 매핑 정보 = 별도의 클래스나 XML로 분리

- 특정 기술(JPA)에 의존하지 않는 애플리케이션 서비스 만들기
- 
<img width="470" height="110" alt="image" src="https://github.com/user-attachments/assets/97f77f5a-bf22-4e95-81a5-8dc51fb3eec0" />

- OrderService가 JPA repository 구현체에 의존하지 않도록, 순수한 OrderRepository 인터페이스로 DIP를 적용하자!

  <img width="357" height="132" alt="image" src="https://github.com/user-attachments/assets/3185ef8d-f104-4808-96ea-d77268035192" />


- 트랜잭션은 “데이터 접근 기술”에 따라 방식이 모두 다르다
  - JDBC, JPA, MyBatis, jOOQ -> 각 기술은 트랜잭션을 시작하고, 커밋하고, 롤백하는 방식이 서로 다름. 그래서 트랜잭션 자체도 기술 의존적인 작업임.

- 기술별 트랜잭션 방식 요약
  - JDBC 트랜잭션 : Connection 객체 필요, 수동 commit/rollback
    
````
connection.setAutoCommit(false);
try {
    // SQL 실행
    connection.commit();
} catch(Exception e) {
    connection.rollback();
}
````

- JPA 트랜잭션 : EntityManager 기반 : 트랜잭션이 없으면 영속성 컨텍스트 flush 불가, 트랜잭션 필수
  
````
entityManager.getTransaction().begin();
entityManager.persist(order);
entityManager.getTransaction().commit();
````

- MyBatis 트랜잭션 : SqlSession 기반, 수동 commit/rollback
  
````
SqlSession session = sqlSessionFactory.openSession(false);
try {
    session.insert("saveOrder");
    session.commit();
} catch(Exception e) {
    session.rollback();
}
````

- jOOQ 트랜잭션
- 
````
DSLContext.transaction()

dsl.transaction(config -> {
    DSL.using(config).insertInto(...).execute();
});
````

<img width="455" height="262" alt="image" src="https://github.com/user-attachments/assets/2babbfbd-576b-441c-84cd-3b365fbe9cf6" />

- TransactionManager(정확히는 PlatformTransactionManager)는 DataSource 기반 트랜잭션 매니저(JdbcTransactionManager), JPA 트랜잭션 매니저(JpaTransactionManager) 등 다양한 기술의 트랜잭션 처리 방식을 통합해 “트랜잭션을 관리하는 객체의 추상화”를 제공한다.
- 즉, 각 기술마다 다른 트랜잭션 관리 방식을 스프링이 TransactionManager 인터페이스로 “일원화”해서 서비스 계층이 기술에 종속되지 않도록 만든 것.
<img width="574" height="395" alt="image" src="https://github.com/user-attachments/assets/4c89e282-651d-4f85-8733-521ca6ae6192" />


- JDBC Client
````
String sql = "SELECT * FROM member WHERE id = ?";
Member member = jdbcTemplate.queryForObject(sql, new MemberRowMapper(), id);
````

````
Member member = jdbcClient
    .sql("SELECT * FROM member WHERE id = :id")
    .param("id", id)
    .query(Member.class)
    .single();
````

- “JDBC Client는 Spring이 제공하는 최신 SQL 실행 도구로, 전통적인 JdbcTemplate보다 단순하고 직관적으로 파라미터 바인딩과 결과 매핑을 처리해주는 JDBC 접근 객체

- DataSourceTransactionManager가 하는 일
  - DataSource에서 Connection을 가져옴
  - 오토커밋을 false로 바꿈
  - 트랜잭션 시작
  - 서비스 로직 수행
  - 성공 → commit
  - 실패 → rollback
  - Connection 반환
- 개발자에게는 안 보이지만, @Transactional 쓰면 이 매니저가 내부에서 다 처리함.

- JDBC 데이터 액세스용 구성 정보 : 스프링에서 JDBC 기반으로 DB에 접근하기 위해 반드시 필요한 설정 정보
  - DataSource (필수) : DB 연결 정보를 가진 객체, JDBC의 가장 중요한 구성 요소.  ex) URL, username, password, 드라이버 클래스(driver-class-name)
  - DataSourceTransactionManager (필수는 아니지만 보통 필요) : JDBC 트랜잭션을 관리하는 스프링 트랜잭션 매니저


- OrderService에서 기술 관련 코드 제거
- 
<img width="645" height="350" alt="image" src="https://github.com/user-attachments/assets/a7e1f51c-6696-4b08-858d-e7eb2ef847d3" />

- OrderService에서 기술(JPA/JDBC/MyBatis/트랜잭션 등) 관련 코드를 모두 제거하고,
오직 OrderRepository 인터페이스 같은 추상화에만 의존하도록 변경하는 것이
‘기술 관련 코드 제거’의 의미이다.


-트랜잭션 테스트

<img width="450" height="187" alt="image" src="https://github.com/user-attachments/assets/d89ae8fd-faef-46a4-a285-dbd4a5392cf7" />

- 트랜잭션 테스트는 커밋/롤백 여부, 전파 동작, 예외 처리 시 동작을 검증하는 테스트이며,
스프링에서는 @Transactional, @Rollback, PlatformTransactionManager를 이용해 수행한다.


- 데코레이터 패턴이란? : 기존 객체를 수정하지 않고, 그 객체를 '감싸서(wrap)' 새로운 기능을 덧붙이는 패턴.
<img width="514" height="446" alt="image" src="https://github.com/user-attachments/assets/5afdca88-2be1-4ff1-9961-03fd0546a682" />

````
           ┌───────────────┐
           │   Client      │
           └───────▲───────┘
                   │
             (인터페이스)
                   │
        ┌──────────┴──────────┐
        │                     │
   [ConcreteComponent]   [Decorator]
    (원본 객체)                 │
                              │ wraps
                              ▼
                       [ConcreteDecorator]
                (기능을 추가하는 래퍼 객체)
````

- 어떤 때 사용하냐?
  - 원본 객체를 변경할 수 없을 때 (라이브러리, 공용 코드)
  - 여러 “부가 기능”을 조합해서 쓰고 싶을 때
  - 상속보다 유연한 기능 추가가 필요할 때
  - AOP, 프록시처럼 실행 전/후 로직을 넣고 싶을 때
 
- 프록시 패턴 : 타깃을 대신해서 존재하며 접근을 제거하거나 보안, 지연, 원격 접속 등의 기능을 제공. 어떤 객체(Real Subject)에 직접 접근하지 않고, 그 앞에 '대리인(Proxy)'을 두어서 접근을 제어하는 패턴.
  <img width="379" height="332" alt="image" src="https://github.com/user-attachments/assets/df3bb381-ac6c-49f4-8703-f76e4695666c" />
  
- 프록시 패턴을 쓰는 이유?
  - 원본 객체의 접근 제어
  - 호출 전/후에 부가 기능 넣기
  - 실제 객체를 감추기
  - 객체 생성 비용이 비쌀 때 지연 로딩(Lazy Loading)
  - 보안, 로그, 트랜잭션, 캐싱

<img width="542" height="135" alt="image" src="https://github.com/user-attachments/assets/635c0fad-5789-4bf6-8b19-fc7f1f5a8a61" />


- 트랜젝선 프록시

<img width="556" height="476" alt="image" src="https://github.com/user-attachments/assets/917f3c87-e511-4cf5-b18f-6f8db56ac470" />


<img width="654" height="327" alt="image" src="https://github.com/user-attachments/assets/1564c31a-fce4-435d-8836-453b92764ed4" />

<img width="671" height="318" alt="image" src="https://github.com/user-attachments/assets/dd4f97c1-d750-44d6-b6ff-16da4ce43fc2" />

<img width="663" height="362" alt="image" src="https://github.com/user-attachments/assets/d95cb11f-1f83-4840-a377-cfd641031fd5" />


- 다이어그램의 의미(핵심 정리)
  - 클라이언트는 OrderService 인터페이스만 의존한다
  - 실제로 주입되는 객체는 OrderServiceImpl이 아니라 OrderServiceTxProxy
  - Proxy가 내부에서 **타깃(OrderServiceImpl)**을 실행
  - Proxy가 트랜잭션 처리
  - 서비스는 “도메인 로직만” 처리
- 이것이 트랜잭션 프록시의 기반 구조
- 스프링에서 @Transactional을 쓰면 이 구조가 AOP로 자동 생성되는 것!


- 트랜잭션 프록시 적용

  <img width="471" height="253" alt="image" src="https://github.com/user-attachments/assets/448d01a5-1fc4-4ab4-97bf-fc6f77dd1e27" />

  <img width="545" height="197" alt="image" src="https://github.com/user-attachments/assets/387c2bd0-56a6-4102-b6fb-8784e8e8d81a" />
  
  <img width="619" height="261" alt="image" src="https://github.com/user-attachments/assets/5131d0d2-d36a-4524-b192-f8752574713d" />

- 왜 트랜잭션 프록시를 적용하는걸까?
  - 단일 책임 원칙(SRP) 지키기 -> OrderService는 “주문 처리”만 집중. 트랜잭션과 같은 기술 로직은 프록시가 담당
  - OCP(Open-Closed Principle) 지키기 -> 기존 OrderService 코드는 수정 필요 없음. 트랜잭션 기능을 추가할 때 프록시만 끼워 넣으면 됨
  - AOP 구조의 기본 원리 -> 스프링의 @Transactional이 내부적으로 바로 이런 프록시 패턴 사용함


- 스프링의 프록시 AOP
-
````
public void external() {
    internal(); // ← 여기서 AOP가 적용 안 됨!!
}

@Transactional
public void internal() { ... }
````
- 프록시를 통해 호출해야 AOP가 실행되는데, 내부 메서드 호출은 프록시를 거치지 않고 자기 자신을 직접 호출함. 그래서 @Transactional, @Cacheable 등이 내부 호출에서 적용 안 되는 문제가 생김.

- 프록시 대상만 적용 → private, final 메서드 AOP 불가
  - 프록시 AOP는 public 메서드만 적용된다.
  - private 메서드 → 프록시가 접근 불가
  - final 클래스/메서드 → CGLIB이 상속할 수 없음
  - static 메서드 → 인스턴스 기반이 아니라 프록시 불가
  - 즉 @Transactional을 private 메서드에 걸어도 동작 안 함.
























