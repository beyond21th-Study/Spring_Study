# 스프링 애플리케이션의 빈이 존재하는 계층 구조

## Presentation(Web, UI) Layer

사용자한테 어떻게 보여줄 것인가, 사용자의 행위에 대해서 이걸 어떻게 처리할 것인가에 대한 부분들이 모여있는 계층

대표적인 어노테이션 : @Controller

## Business(Service, Application) Layer

전체 애플리케이션의 핵심적인 비즈니스 로직, 도메인 로직 등이 포함된 계층

대표적인 어노테이션 : @Service

## Persistence(Data Access, Infra) Layer

백엔드 프로그램은 클라이언트나 브라우저로부터 들어온 요청을 받아서 뭔가를 처리한 다음 DB에 저장해두고 DB에서 뭔가를 꺼내서 다시 클라이언트가 볼 수 있는 웹과 같은 형태로 만들어 오는 것이 주된 업무

대표적인 어노테이션 : @Repository

# 서비스

1. 클라이언트가 반드시 존재해야 함
2. 서버에서 동작하는 서비스들은 일반적으로 상태를 가지지 않음 → 그로 인해 스프링 빈으로 사용하기 적합

스프링 빈은 기본적으로 싱글톤으로 만들어지는데 싱글톤 빈을 이용할 때 기본적으로 상태를 가지고 있으면 안됨 why? 멀티스레드로 여러 개의 요청을 한꺼번에 처리하기 위해서는 어떤 상태 값이 저장되어 있으면 안되기 때문

상태는 DB에 저장.

## 서비스의 종류

- 애플리케이션 서비스(application service)

→ 애플리케이션 계층에 존재, 서비스라는 어노테이션이 붙음. 비즈니스 로직을 담당하기 시작하는 시작점, 종료가 되는 경계에 있는 서비스를 말함

- 도메인 서비스(domain service)

→ 도메인 모델 패턴을 이용해 비즈니스 로직을 엔티티 같은 도메인 오브젝트에 집어넣는 경우 특정 엔티티로 표현이 어려운 로직을 도메인 서비스의 오브젝트로 만들어 집어넣을 수 있음.

- 인프라 서비스(infrastructure service)

→ 도메인/애플리케이션 로직에 참여하지 않는, 기술을 제공하는 서비스.(ex. 메일, 캐시, 트랜잭션, 메시징 등) 서비스 추상화 대상.

## 애플리케이션 서비스

Application Layer

순수하게 서버가 제공하고자 하는 전체 서비스의 핵심적인 로직이 들어감

특정 기술의 변경이나 특정 기술이 적용된 환경에 의존하지 않도록 만드는 것이 중요.

### @Service

스프링의 빈으로 등록될 때 스캐너에 의해서 자동으로 인식되어 등록되게 만들거나 코드를 읽을 때 애플리케이션 서비스의 빈으로 사용되어지는 또 싱글 톤으로 사용되는 빈의 클래스임을 인식할 수 있게 하기 위해 사용.

### @Configuration

구성 정보를 담고 있는 클래스, import를 통해 데이터 config 클래스 이름을 주면 오더 config을 로딩할 때 데이터 config에 있는 모든 빈 설정들도 가져옴.

## JPA 의존

- JPA를 이용하는 특정 레포지토리 클래스에 의존하는 코드 → 액세스 기술을 사용하는 새로운 레포지토리 클래스를 만들면 서비스 코드도 같이 수정 필요
- 이름에 아예 JPA 트랜잭션 매니저라는 JPA를 위한 클래스를 주입을 받아서 사용하는 코드

### @Entity

JPA 기술을 이용해서 데이터 베이스에 저장하고 읽어오기 위해 사용.

해당 애노테이션이 붙으면 JPA 기술에서 이 클래스를 엔티티 클래스임을 인식

컴파일 시점에서만 의존하고 이후에는 의존하지 않음

## JPA 메타데이터 분리

- 어노테이션은 컴파일 타임 라이브러리 의존성만 가짐.
- 엔티티의 동작에는 영향을 주지 않기 때문에 엔티티 클래스를 다른 데이터 기술에서 사용 가능
- 제거하고 싶은 경우 외부 XML 디스크립터를 사용

### XML

태그 형태로 정보를 기술하는 방식

어노테이션이 아니기 때문에 컴파일을 직접 할 필요는 없지만 빌드할 때 패키징하는 jar 파일에 포함되어야 함

빌드할 때 어노테이션에서 메타 데이터를 읽는 것처럼 JPA 라이브러리가 xml에서 동일한 메타 정보를 읽어옴

### unique

동일한 값 허용하지 않는 속성

어노테이션을 제거한 엔티티를 그대로 실행 시 오류가 발생

→ UnknownEntityTypeException 

JPA에게 Order가 JPA 엔티티라는 사실을  XML 파일에 정보를 저장하여 전달

## 특정 기술(JAP)에 의존하지 않는 애플리케이션 서비스 만들기

- JPA Repository - OrderRepository에 의존하지 않도록 변경
- 의존 관계 역전(DIP)

### 의존 관계 역전(DIP)

상위 모듈과 하위 모듈 두 가지 모두 인터페이스에만 의존하는 것 → 변경에 매우 용이

## Spring Test

평범한 단위 테스트가 아닌 스프링을 이용하는 테스트임을 표현하는 방식

→ @ExtendWith(SpringExtension.class) @ContextConfiguration() 어노테이션을 붙여서 표현

### var

variable의 약자로 해당 키워드로 변수를 선언시 뒤의 코드를 보고 컴파일러가 자동으로 실행

뒤의 코드에서 알기 어려운 경우 쓰지 않는 것이 좋음

# 트랜잭션 서비스 추상화

## Transaction

데이터 베이스 사용시 반드시 필요

why? 반드시 이어지는 작업이 존재하는 경우 개별적으로 수행될 때 문제가 발생할 수 있기 때문에 트랜잭션을 통해 해당 작업들을 하나로 묶어주어야 함

데이터 기술마다 트랜잭션을 사용하는 방식이 다 다름

### JPA 트랜잭션

GetTransaction이라는 API를 통해 엔티티 트랜잭셔늘 가져오고 난 뒤 Begin, Commit 혹은 롤백 이런 코드를 사용.

### JDBC 트랜잭션

오토 커밋이 기본적으로 적용.

편리하지만 작업 시 여러 개의 변경 작업이 하나의 트랜잭션으로 묶이지 않는 경우가 발생

이 때문에 명시적으로 커넥션 오브젝트를 가져온 뒤 setAutoCommit을 false로 변경.

작업을 마친 뒤 커밋을 호출하면 트랜잭션이 적용됨

## 추상화

- 구현의 복잡함과 디테일을 감추고 중요한 것만 남기는 기법
- 여러 인프라 서비스 기술의 공통적이고 핵심적인 기능을 인터페이스로 정의하고 이를 구현하는 어댑터를 만들어 일관된 사용이 가능하게 만드는 것이 ‘서비스 추상화’

추상화가 필요한 이유는 각 기술의 디테일에 의존하는 코드의 경우 기술이 변경될 때마다 코드의 변경이 많이 발생하여 버그가 발생하거나 작업의 양이 크게 늘어날 수 있기 때문

### 추상화 방법

1. 기술의 공통적인 핵심 기능들을 뽑아내 인터페이스 생성 → PlatformTransactionManager
2. 이 기술을 사용하는 서비스 코드는 해당 인터페이스에만 의존하도록 설정
3. 각 기술에 맞는 어댑터 생성 → 데이터 액세스 기술이 변경되더라도 클라이언트 코드에 영향을 주지 않음

트랜잭션의 시작과 종료는 애플리케이션 서비스 쪽에서 일어나야 함

why? 레포지토리 하나 레벨이 아니라 여러 레포지토리를 이용해서 변경하는 작업을 하나의 트랜잭션으로 묶어야 하기 때문

# JDBC 데이터 액세스 기술

## JdbcClient

- SQL을 사용하는 JDBC 데이터 처리 코드를 유연하게 작성하도록 도와줌
- 일종의 템플릿/코랙
- 스프링의 JdbcTemplate의 대체 기술

## DataSourceTransactionManager

- JDBC의 Connection을 이용하는 트랜잭션 매니저
- Connection을 리턴하는 DataSource 오브젝트 필요

# 트랜잭션 프록시

## 서비스에서 기술 관련 코드 제거

- 데이터 기술이 변경되어도 기존 코드는 영향을 받지 않음
- TransactionTemplate, PlatfromTransactionManager와 같은 기술과 연관된 코드가 계속 등장함
- 트랜잭션의 시작과 종료는 보통 애플리케이션 서비스 메소드 실행 전후

## 트랜잭션 테스트

- 트랜잭션이 필요한 곳에 정확하게 적용되었는지 테스트하기는 매우 어려움
- JDBC처럼 자동 커밋이 되거나 Spring Data JPA처럼 기본 레포지토리 구현에서 트랜잭션을 알아서 적용해주는 기술을 사용할 때 트랜잭션이 바르게 적용되지 않은 것을 놓치기 쉬움
- 모든 작업이 성공하면 하나의 트랜잭션으로 진행된 것인지 여러 개의 트랜잭션으로 쪼개진 것인지 확인 어려움
- 트랜잭션 중간에 실패하는 케이스를 만들수 있다면 롤백 여부로 확인 가능

JDBC에서 트랜잭션 코드를 제거하고 실행하더라도 문제 발생 x

why? JDBC에서는 오토 커밋을 지원하기 때문

그렇다고 트랜잭션을 만들지 않아도 되는 것은 아님

why? 트랜잭션 사용은 적어도 두 개 이상의 데이터를 변경하거나 조작하는 작업이기 때문에 트랜잭션을 통해 하나로 묶어주는 것이 필요

테스트를 진행할 때 값을 두 개 넣을 때 첫 번째 값이 잘 들어가고 두 번째 값에서 오류가 발생하는 경우 롤백이 되어야 함

테스트 진행 시 예상과 다르게 첫 번째 값이 들어있다면 그 원인이 트랜잭션을 통해 두 작업이 하나로 묶이지 않았음을 확인 가능

이런 테스트를 통해 트랜잭션이 잘 적용되는지에 대해 검증이 가능하지만 매우 까다로움

트랜잭션을 시작하고 문제가 없다면 트랜잭션을 커밋, 문제가 잇다면 롤백하는 기능을 디자인 패턴으로 추가 가능

## 데코레이터 패턴

- 대상이 되는 오브젝트의 코드를 변경하지 않고 새로운 기능을 런타임에 부여하는 디자인 패턴

## 프록시 패턴

- 타깃을 대신해서 존재하며 접근을 제거하거나 보안, 지연, 원격 접속 등의 기능을 제공

## 트랜잭션 프록시

- OrderService 인터페이스 추출
- 트랜잭션 부가 기능을 제공하는 OrderServiceTxProxy 프록시

## 트랜잭션 프록시 적용

- 동일한 OrderService 인터페이스를 구현한 프록시를 OrderClient에 주입

## 스프링이 만들어주는 트랜잭션 프록시

- @Tranactional 어노테이션이 붙은 클래스의 메소드가 트랜잭션 안에서 실행되도록 프록시를 만들어줌

## 스프링의 프록시 AOP

- 활용 용도가 제한적이면서 막상 사용이 매우 어려움
- 스프링이 만들어 놓은 트랜잭션과 보안 기술에서는 유용하게 활용
- AOP는 아니더라도 데코레이터/프록시 패턴의 동작원리를 이해하고 필요한 곳에 활용 가능

특정 기능하고 연결된다기보다 기술적인 부분에서 필요로 하는 곳에서 반복적으로 나오게 되는 경우 어노테이션이나 XML을 통해 설정한 코드 앞이나 뒤에 혹은 예외가 발생했을 때 처리가 필요한 코들르 일괄적으로 많은 곳에 한꺼번에 적용해줌
