[ week7 Spring-Study  ]

[ 스프링이란 무엇인가? ]

- 스프링의 정의
    * 한마디로 정의 어려움.
    * 일반적인 정의 -> “ 자바 엔터프라이즈 개발을 편하게 해주는 오픈소스 경량급 애플리케이션 프레임워크 “

- 애플리케이션 프레임워크
    * 프레임 워크 : 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어진다.
    * 스프링은 간단한 설정만으로 관계형 DB와 자바 오브젝트를 매핑해주는 ORM 기술을 제공.
    * 프레임 워크는 애플리케이션의 특정 계층에서 주로 동작하는 한 가지 기술 분야에 집중되지만. 스프링은 다르게 ‘ 애플리케이션 프레임워크 ‘ 라는 특징을 갖고 있다.

    * 애플리케이션 프레임 워크는 전 영역을 포괄하는 범용적인 프레임 워크를 말한다. 
    * -> 개발 전 과정을 빠르고 편리하며 효율적으로 진행하는 데 일차적인 목표를 둠.
    * 여러계층의 다양한 기술을 한데 모은게 프레임 워크 X ->  전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 각 분야의 특성에 맞는 필요를 채워주고 있는게 프레임워크.

- 경량급
    * 스프링이 가볍다 하는 이유 -> 불필요하게 무겁지 않다는 의미.
    * 단순한 서버 환경인 톰캣(Tomcat)이나 제티(Jetty)에서도 완벽하게 동작함.
    * 서블릿 컨테이너만으로 충분하니 무겁고 복잡한 기능이 포함된 고급 WAS를 사용할 이유가 없다.

    * 또한 개발환경과 서버에만 국한된게 아닌 프레임워크에서 동작하기 위해 만들어진 코드에 비해 상대적으로 작고 단순하단 뜻.
    * -> 프레임워크와 서버환경에 의존적인 부분을 제거해주기 때문.

- 자바 엔터프라이즈 개발을 편하게
    * 애플리케이션 개발? 개발자가 복잡하고 실수하기 쉬운 로우레벨 기술에 많은 신경을 쓰지 않으면서 애플리케이션의 핵심인 사용자의 요구사항, 즉 비즈니스 로직을 빠르고 효과적으로 구현하는 것을 말함.

- 오픈소스
    * 소스가 모두에게 공개되고, 특별한 라이선스를 취득할 필요 없이 얼마든지 가져다 자유롭게 이용 가능.
    * 자신의 목적에 맞게 사용, 수정, 다시 공개적으로 배포하는 자유도 허용.
        * 그래도 저작권이 있어서 원 저작자에 대한 정보와 라이선스는 유지한 채로 사용 및 배포해야됨.
    * 장점 :
        * 투명한 방식 다양한 참여로 매우 빠르고 유연한 개발 가능.
        * 버그 신고, 발견, 기능 개선 제안, 처리 등 지켜볼 수 있음.
        * 라이선스 비용 부담 없음.
    * 단점 :
        * 오픈소스 개발 방식의 취약점인 지속적이고 안정적인 개발이 계속될지 불확실.
        * 개발자 개개인에게 극희 의존적.




- 스프링의 목적
    * 목적을 이루는 도구로 스프링을 잘 활용해야만 스프링으로부터 제대로 된 가치를 얻을 수 있다.
    * 목적 : ‘경량급’ 프레임 워크인 스프링을 사용해서 애플리케이션 개발을 편하게 하는 것이다.




- 엔터프라이즈 개발의 복잡함
* 복잡함의 근본적인 이유
    * 1. 기술적인 제약조건과 요구사항이 늘어가기 때문.
        * 엔터프라이즈 시스템 : 서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템을 말함.
        * 많은 사용자의 요청을 동시에 처리해야 하기때문에 서버의 자원을 효율적으로 공유하고 분배해야됨.
        * 시스템 개발하는 비즈니스 로직 구현 외의 보안과 안정성, 확장성 등 개발 기술이 필요함.

    * 2. 엔터프라이즈 애플리케이션이 구현해야 할 비즈니스 로직의 복잡함이 증가하기 때문.
        * 예전에 비해 엔터프라이즈 시스템이 관여하는 업무의 비율이 급격히 커짐.
        * 경제 흐름과 사회의 변화, 업계의 추이에 따라 수시로 업무 프로세스를 변경하고 조종하는 것을 상시화 할만큼 변화가 빨라짐.
        * 자주 수정해야하는 시대가 됐음.

* 복잡함을 가중시키는 원인
    * 엔터프라이즈 애플리케이션 개발실패의 주요 원인 : 비즈니스 로직의 복잡함과 기술적 복잡함.
        * 비즈니스 로직과 엔터프라이즈 기술인 두 가지 복잡함이 얽혀있기 때문.




- 복잡함을 해결하려는 도전
* 제거될 수 없는 근본적인 복잡함
    * 근본적인 복잡함의 원인은 제거할 대상은 아니다. -> 현실적으로 불가능함.

    * 복잡함을 효과적으로 다루기 위한 전략과 기법이 필요.

* 실패한 해결책:EJB
    * 기술적인 복잡함을 애플리케이션의 핵심 로직에서 일부분 분리하는데 성공.
    * BUT 특정 인터페이스를 구현하고, 특정 클래스를 상속, 서버에 종속적인 서비스를 통해서만 접근하고 사용 가능하게 만드는 개발방식이 잘못된 선택. -> EJB라는 환경과 스펙에 종속되는 코드로 만들어졌기 때문.

* 비침투적인 방식을 통한 효과적인 해결책 : 스프링
    * 침투적인 기술 : 기술과 관련된 코드나 규약 등이 코드에 등장하는 방법.
        * 문제점 : 비즈니스 로직이 담긴 코드가 프레임워크의 코드와 뒤섞임. 자바 객체로 테스트 어려움.
    * 비침투적인 기술 : 기술의 적용 사실이 코드에 직접 반영되지 않음.(기술 격리, 유연성, 테스트 용이성)

    * 근본적인 원인이 사라진건 X -> 다른 복잡함들을 깔끔하게 분리해서 각각을 효과적으로 상대할 수 있는 기반 만들어짐.




[ 복잡함을 상대하는 스프링의 전략 ]
- 기술적 복잡함을 상대하는 전략
    * 첫 번째 문제 : 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적이다.
        * 환경, 서버, 조건, 기술이 바뀐다고 코드도 바뀌는건 심각한 문제.
        * 일관성 없는 기술과 서버환경의 변화에 대한 스프링의 공략법 -> 서비스 추상화.
        * 로우레벨 기술 구현 부분, 기술을 사용하는 인터페이스로 분리하고 환경과 세부 기술에 독립적인 접근 인터페이스는 굿
        * 스프링이 제공하는 템플릿/콜백 패턴은 반복 작업과 API 사용코드 제거-> 핵심 로직에만 집중할 수 있음.

    * 두 번째 문제 : 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장한다.
        * 책임에 따라 계층을 구분하고 그 사이에 서로의 기술과 특성에 의존적인 인터페이스나 예외처리 등을 최대한 제거한다 할지라도 근본적으로 엔터프라이즈 서비스를 적용하는한 이 문제는 쉽게 해결 X.
        * 그래서 이런 기술과 비즈니스 로직의 혼재로 발생하는 복잡함을 해결하기 위한 스프링의 접근 방법 -> AOP

        * AOP?
            * 비즈니스 로직과 공통 기능(로그, 트랜잭션, 보안)을 분리하는 기법.
            * 핵심 로직       +       공통 기능      =       완전한 서비스
            * 주문 처리 ──────┬─────── 로그/트랜잭션 ──────── 실제 동작
            *                  │
            *               AOP가 분리&삽입

        * Spring AOP 동작 원리
            * 클라이언트 요청
            *      ↓
            * [프록시 객체]           ──               Advice 실행 ── [실제 Service] ── 핵심 로직
            *      ↑                                                   ↓
            * 가로채서 공통기능 추가 후 호출


    * AOP는 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 깔끔하게 분리해서 별도의 모듈로 관리하게 해주는 강력한 기술.




- 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략
    * 위의 전략으로 주요 기능과 비즈니스 로직을 담은 코드만 독립적으로 존재하게되면 가장 중요한 핵심 부분이 되는 것이다.
    * 업부의 변화에 따라 자주 변경되거나 수정되고 대체로 복잡한 부분들이다.
    * 다른 문제(기술부분, 사용자 인터페이스 등)는 시스템 복구를 하거나 빠르게 대응해주면 당장 큰 문제 발생 X.
    * BUT 비즈니스 로직에 오류가 있으면 시스템 업무 자체에 큰 지장을 주거나 치명적인 손실 가능.
		ex) 서비스가 느린건 서버 증설 등 대응 가능. 거래했는데 실제로 체결이나 돈이 맘대로 줄어듬 -> big event

    * 비즈니스 로직은 가장 중요하게 다뤄져야 하고 가장 많이 신경 써야 한다. 
    * Before 비로의 상당부분을 DB에 뒀음. 하지만 엔터프라이즈 규모가 커지고 복잡해지면서 매우 불편하고 위험해짐.
    *  DB에 비즈니스 로직을 두는건 매우 불편, 위험한 일, 유지보수 와 개발 및 테스트 어려움. -> 요즘은 비즈니스로직은 애플리케이션 안에 만드는게 추세.
    * DB는 서버로 이동.

    * 오브젝트에 담긴 로직은 테스트 쉬움. 목 오브젝트로 DB없어도 테스트 가능.
    * 자바 -> 객체지향 언어로 유연한 설계, 재사용성 높음 -> 조건이 까다로운 비즈니스 로직을 효과적으로 구현 가능.



- 핵심 도구 : 객체지향과 DI
    * 기술적인 복잡함을 효과적으로 다루는건 DI를 바탕으로함. -> 서비스 추상화, 템플릿/콜백, AOP 등.
    * 객체 지향과 DI는 떼놓을 수 없음. 
    * 객체 지향의 특성을 잘 살린 설계 -> 상속과 다형성, 위임 등 많음.
    * 스프링의 기술과 전략 : 객체지향이라는 자바 언어가 가진 강력한 도구를 극대화해서 사용할 수 있는 것.



[ POJO 프로그래밍 ]

- 스프링의 핵심 : POJO
￼
    * 위의 그림은 스프링으로 개발한 애플리케이션의 기본 구조를 보여줌.
    * 스프링의 주요 기술인 IoC/DI, AOP와 PSA(Portable Service Abstraction)는 애플리케이션을 POJO로 개발할 수 있게 해주는 간으기술이라고 불린다.

- POJO란 무엇인가?
    * Plain Old Java Object의 약자. 
    * 오브젝트를 사용하지만 그냥 멋진 이름을 붙여준 것.

[ POJO의 조건 ]

- 특정 규약에 종속되지 않는다.
    * 자바 언어와 꼭 필요한 API외에는 종속되지 않아야 한다.
    * 스트럿츠 1과 같이 특정 클래스를 상속해서 만들어야 하는 규약이 있는 경우도 마찬가지. 이럴경우 단일 상속제한으로 객체지향 기법쓰기어려움.
￼
    * 또한 규약이 적용된 환경에 종속적이 되기 떄문에 다른 환경으로 이전이 어렵다


- 특정 환경에 종속되지 않는다.
    * 환경에 독립적이어야 한다.
    * POJO클래스는 웹이라는 환경정보나 웹 기술을 담고 있는 클래스나 인터페이스 사용 X
    * 나중에는 웹 컨트롤러와 연결할지라도 직접적으로 웹이라는 환경으로 제한해버리는 오브젝트나 API에 의존 X.
    * 웹 외의 클라이언트가 사용하지 못할뿐더러 웹 서버에 올리지 않고 독립적인 테스트도 힘듦.

    * 직접 메타정보를 추가해주는 애노테이션이 환경에 종속되지만 않는다면 POJO possible!
    * 하지만 애노테이션이나 엘리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 POJO nope!

- 특정 기술규약과 환경에 종속되지 않으면 모두 POJO인가?
    * 개발자가 크게 오해하는 것 중 하나이다.
    * 자바 언어 문법을 사용했다고해서 자동으로 객체지향 프로그래밍이 적용됐다고는 보기 힘들기 때문.
    * 진정한 POJO란? 객체지향의 원리에 충실하며, 환경과 기술에 종속되지 않고 필요에 따라 재활용 될 수 있는 방식.

- POJO 장점
    * 깔끔한 코드
    * 자동화된 테스트에 매우 유리
    * 객체지향적인 설계를 자유롭게 적용가능.
- POJO 단점
    * 기술 지원 기능 못씀
    * 구조가 너무 단순해지면 OOP 설계가 빈약해짐(상속/구성/캡슐화, 유지보수 어려움)
    * 공통 규약/제약을 표현하기 어려움
    * 인프라와 통합 시 추가 코드 필요

[ POJO 프레임워크 ]
* 스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적으로 만들어짐
* 아래 그림은 복잡한 스프링 시스템을 보여줌.
￼
* 자바 언어와 JVM플랫폼, JDK API 등 사용법 잘 알아야된다.


[ 스프링의 기술 ]
* POJO 프로그래밍을 쉽게 할수록 도와주는 세 가지 기술 : IoC/DI, AOP, PSA
    * 스프링이 직접 제공하지 않는 기술에 대해서도 PSA를 적용할 수 있어야한다.


- 제어의 역전(IoC) / 의존관계 주입(DI)
    * IoC는 스프링의 기본이되는 기술이자 핵심 개발 원칙이다.
    * 활용 방법
        * 왜 오브 젝트를 분리ㅣ해서 만들고, 인터페이스를 느슨하게 연결한 뒤 DI를 통해 외부에서 지정하는 것일까?
            * 유연한 확장이 가능하게 하기 위해서.
            * DI는 OCP의 ‘변경에는 닫혀있따’라는 말로 해당되고, 폐쇄적인 관점으로볼때 ‘ 재사용이 가능하다’ 라고 볼 수 있따.


[ DI의 활용 방법 ]
- 핵심 기능의 변경
    * 의존 대상의 구현을 바꾸는 것. 실제 의존하는 대상이 가진 핵심기능을 DI 설정을 통해 변경하는 것이 대표적인 DI 활용방법.

- 핵심기능의 동적인 변경
    * 의존 오브젝트의 핵심기능 자체를 바꾸는 것.
    * 일반적인 DI를 이용한 변경 방법과는 달리, 동적으로 매번 다르게 변경할 수 있다.
    * 일단 DI가되고나면 그 후로는 바뀌지 않는다 -> 정적인 관계를 맺어주는 것.
    * 하지만 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 그 의존 대상을 다이내믹하게 변경 가능.
        * 예를들면 사용자 등급에 따라 DataSource를 만들 수 있는데, DAO는 DataSource에 의존한다. DAO하나가 여러 개의 DataSource에 의존할 수 있는 것이다. 현재 접속한 사용자의 등급에 따라 그때끄때 다른 DataSource를 DAO가 사용하게 할 수 있는 것.
    * 핵심기능이 바뀐다기보다는 기능은 같지만 독립적인 상태정보를 저장할 수 있는 자신만의 오브젝트를 가질 수 있다는 말!

- 부가기능의 추가
    * 핵심기능은 그대로 둔 채 부가기능을 추가하는 것.
    * 인터페이스를 두고 사용하면서 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용하면 핵심기능과 클라이언트 코드에는 전혀 영향을 주지 않으면서 부가적인 기능을 얼마든지 추가할 수 있다.
    * 트랜잭션 기능이 대표적인 예.
    * OCP가 말하는 확장에 열려 있다는 것은 전략 패턴에서처럼 핵심기능을 변경해서 쓰는 수준만을 말하는게 아님을 기억하자!

- 인터페이스의 변경
    * 클라이언트가 사용하는 인터페이스와 실제 오브젝트 사이에 인터페이스가 일치하지 않는 경우에도 DI가 유용하다.
    * 중간에 인터페이스 어댑터 역할을 해주는 레이어를 추가하는 방법도 있다.

- 프록시
    * 필요한 시점에서 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩을 적용하려면 프록시가 필요하다.
    * 원격 오브젝트를 호출할 때 마치 로컬에 존재하는 오브젝트처럼 사용할 수 있게 해주는 원격 프록시를 적용하려고 할 때도 필요함.

- 템플릿과 콜백
    * 반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이에서 자주 바뀌는 부분을 분리해서 템플릿과 콜백으로 만들고 이를 DI 원리를 응용해 적용하면 코드를 간결하게 만들 수 있다. 

- 싱글톤과 오브젝트 스코프
    * DI가 필요한 중요한 이유 중 한가지는 DI 할 오브젝트의 생명주기를 제어할 수 있다.
    * DI를 프레임워크로 이용한다는 건 DI 대상 오브젝트를 컨테이너가 관리한다는 의미이다. 
    * 가장 기본이 되는 스코프는 싱글톤!
        * 전통적인 싱글톤 패턴은 오브젝트에 많은 제약을 가해서 만들어지기 때문에 권장 X.
        * 이보다는 컨테이너가 오브젝트를 관리하는 IoC 방식이 유용하다.


- 테스트
    * 여타 오브젝트와 협력해서 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것이다.
    * 그래야 다른 오브젝트와 사이에서 일어나는 일을 테스트를 위해 조작할 수 있다.
    * 그래서 의존 오브젝트를 대신해서 목 오브젝트같은 테스트 대역을 이용한다.
    * DI는 한가지만 선택적으로 사용해하 하는게 아니라 여러 가지 활용 방법을 한 번에 적용할 수도 있다.


[ 애스펙트 지향 프로그래밍(AOP) ]
* AOP는 객체 지향 기술의 한계와 단점을 극복하도록 도와주는 보조적인 프로그래밍 기술이다.
* POJO같은 조건을 유지한채로 엔터프라이즈 서비스를 적용하기 어렵다 -> 그래서 AOP 필요 

- AOP의 적용 기법
    * 스프링과 같이 다이내믹 프록시를 사용하는 방법
        * 기존 코드에 영향을 주지 않고 부가기능을 적용하게 해주는 데코레이터 패턴을 응용한 것.
        * 대신 부가기능을 부여할 수 있는 곳은 메소드의 호출이 일어나는 지점뿐이라는 제약이 있다.

    * 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법
        * AspectJ라는 유명한 오픈소스AOP 툴이 있다. 강력한 고급 기능을 가진 AOP를 제공함.
        * 이런 고급 AOP 기능을 적용하려면 자바 언어와 JDK의 지원만으로는 불가능함.
        * 그 대신 별도의 AOP 컴파일러를 이용한 빌드 과정을 거치거나, 클래스가 메모리로 로딩될 때 바이트 코드를 조작하는 위빙과 같은 별도의 방법을 이용해야됨. 

[ AOP의 적용 단계 ]
- 1단계 : 미리 준비된 AOP 이용
    * 처음엔 스프링이 미리 만들어 제공하는 AOP기능을 그대로 가져다 적용. -> 트랜잭션.
    * @Configurable도 도메인 오브젝트에 DI를 자동적용해주는 AOP 기능이다.

- 2단계 : 전담팀을 통한 AOP 적용

- 3단계 : AOP의 자유로운 이용



[ 포터블 서비스 추상화(PSA) ]
* 환경과 세부 기술의 변화에 관계없이 일관된 방식으로 기술에 접근할 수 있게 해주는 PSA다. 
* POJO 코드가 기술에 직접 노출되어 만들어지지 않는 다는 말. -> 일관성있는 서비스 추상화 기술.

