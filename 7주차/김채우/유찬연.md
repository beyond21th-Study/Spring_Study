# 스프링의 정의

스프링 : 자바 엔터프라이즈 개발을 편하게 해주는 오픈 소스 경량급 애플리케이션 프레임 워크 

## 애플리케이션 프레임 워크

일반적인 라이브러리나 프레임 워크의 경우 특정 업무 분야나 한 가지 기술에 특화된 목표를 가지고 만들어짐.

하지만 스프링은 ‘애플리케이션 프레임 워크’라는 특징이 존재.

애플리케이션 프레임워크란? 

특정 계층이나 기술, 업무 분야에 국한되지 않고 애플리케이션의 전 영역을 포괄하는 범용적인 프레임워크 → 애플리케이션 개발의 전 과정을 빠르고 편리하게 효율적으로 진행하는 데 일차적인 목표를 둠.

스프링이 애플리케이션 프레임워크라 불리는 이유는 단지 여러 계층의 다양한 기술을 한 데 모아두었기 때문이 아님.

애플리케이션의 전 영역을 관통하는 일관된 프로그래밍 모델과 핵심 기술을 바탕으로 각 분야의 필요를 채워주기 때문.

## 경량급

스프링이 경량급이라는 것은 가볍거나 작은 규모의 코드로 이루어졌기 때문이 아님.

오히려 스프링은 매우 복잡하고 방대한 규모의 프레임워크.

헌데 어째서 스프링을 가볍다고 할까? → 불필요하게 무겁지 않기 때문.

과거 자바 주류 기술이었던 EJB 같은 과도한 엔지니어링이 적용된 기술과 스프링을 대비시켜 사용됐던 표현.

당시 EJB는 기술에 대한 과도한 욕심으로 개발 환경과 운용 서버, 개발과 빌드, 테스트 과정, 작성된 코드 모두를 매우 무겁고 복잡하게 만듦.

그에 반해 스프링은 가장 단순한 서버 환경(ex. Tomcat, Jetty)에서도 완벽하게 동작.

서블릿 컨테이너만으로 충분하니 복잡한 기능이 잔뜩 포함된 고급 WAS를 굳이 사용할 필요 x.

그로 인해 코드는 더 단순하고 개발 과정은 편리하면서도 EJB에서조차 불편했던 고급 기능을 세련된 방식으로 적용 가능.

스프링의 이런 특징은 개발 환경과 서버에만 국한된 것이 아님.

스프링 기반으로 제작되는 코드가 기존 EJB나 여타 프레임워크에서 동작하기 위해 만들어진 코드에 비해 상대적으로 작고 단순하다는 뜻이기도 함.

how? 불필요하게 등장하던 프레임워크와 서버 환경에 의존적인 부분을 제거해주기 때문. 

그 덕분에 지원하는 기술 수준은 비슷하더라도 그것을 훨씬 빠르고 간편하게 작성하게 해줌으로써 생산성과 품질 면에서 유리함.

## 자바 엔터프라이즈 개발을 편하게

자바 엔터프라이즈 개발을 편하게 한다는 것의 의미는 로우 레벨의 트랜잭션이나 상태 관리, 멀티스레딩, 리소스 풀링과 같은 복잡한 로우 레벨의 API 따위를 이해하지 못하더라도 아무 문제 없이 애플리케이션 개발이 가능하다는 것.

기존의 대부분의 자바 엔터프라이즈 기술과 프레임워크들이 주장했음.

심지어 EJB도.

하지만 EJB의 문제는 이 과정에서 다른 차원의 더 큰 복잡합을 애플리케이션 개발에 끌고 들어오는 실수를 저질렀다는 점.

스프링의 경우 초기에 기본 설정과 적용 기술만 잘 선택하고 준비해두면, 이후에는 개발자가 신경 쓸 부분이 거의 없음.

또한 엔터프라이즈 개발의 기술적인 복잡함과 그에 따른 수고를 제거해줌.

기술적인 필요를 무시하는 것이 아닌 엔터프라이즈 개발에서 필연적인 기술적인 요구를 충족하면서도 개발을 복잡하게 만들지 않음.

## 오픈 소스

오픈 소스 : 모두에게 공개되고 특별한 라이선스를 취득할 필요 없이 얼마든지 가져다 자유롭게 이용 가능한 소스. 

또한 필요에 의해 수정이 가능하고 수정된 제품과 소스를 다시 공개적으로 배포하는 자유도 허용됨. 물론 원 저작자에 대한 정보와 라이선스는 유지한 채로 사용하거나 배포해야 함.

스프링에 적용된 오픈 소스 라이선스는 Apache License Ver 2.0으로 비교적 제약이 적고 사용이 매우 자유로운 편.

오픈 소스 프로젝트의 경우 커뮤니티를 통해 자유롭게 개발에 관한 의견을 공유하거나 토론할 수 있고 버그를 발견하여 신고하거나 새로운 기능 추가 요청 가능.

그런 요청이나 버그 신고가 어떻게 처리되고 있는지도 이슈 트래커 시스템을 통해 공개적으로 확인 가능하며, 수정된 코드도 언제든지 확인 가능.

하지만 스프링의 공식적인 개발은 제한된 인원의 개발자에 한정됨.

그 이유는 오픈 소스 개발 모델의 장단점에 있음.

우선 장점으로는 매우 빠르고 유연한 개발이 가능하다는 것.

피드백이 빠르게 전달되어 개발 중인 경우에도 반영 가능.

또한 오픈 소스 제품을 사용하는 기업이나 사용자 입장에서 라이선스 비용에 대한 부담이 없다는 것도 큰 장점.

오픈 소스 개발 모델의 단점으로는 지속적이고 안정적인 개발에 대한 불확실성.

오픈 소스 프로젝트는 특히 개발자 개개인에 극히 의존적.

이런 한계로 인해 오픈 소스 개발이라는 방법을 선택했지만 사용자에게 지속적인 신뢰를 제공할 수 있도록 개발을 책임지고 진행할 수 있는 전문 기업을 만듦.

이를 통해 안정적이고 전문화된 개발과 품질 관리 가능.

### 스프링은 오픈 소스의 장점을 충분히 취하면서 동시에 단점과 한계를 잘 극복하고 있는 전문적이고 성공적인 오픈 소스 소프트웨어

# 스프링의 목적

단순히 스프링의 기능과 API 사용 방법을 잘 안다고 해서 잘 쓴다고 할 수 없음.

스프링의 목적을 바로 이해하고 그 목적을 이루는 도구로 스프링을 잘 활용해야만 스프링으로부터 제대로 된 가치 획득 가능.

스프링의 목적은 무엇인가.

## 엔터프라이즈 개발의 복잡함

과거 2000년대 초반 자바 엔터프라이즈 실패의 가장 대표적인 요인은 ‘엔터프라이즈 시스템 개발이 너무 복잡해서’

## 복잡함의 근본적 이유

### 기술적인 제약 조건과 요구 사항이 늘어나기 때문

엔터프라이즈 시스템이란? 

서버에서 동작하며 기업과 조직의 업무를 처리해주는 시스템.

많은 사용자의 요청을 동시에 처리해야 하기 때문에 서버의 자원을 효율적으로 공유하고 분배해서 사용 가능해야 하고 보안과 안정성, 확장성 면에서도 뛰어나야 함.

즉 엔터프라이즈 시스템을 개발하는 데는 순수한 비즈니스 로직을 구현하는 것 외에도 기술적으로 고려할 사항이 많다는 뜻.

추가로 웹을 통한 사용자 인터페이스 뿐 아니라 타 시스템과의 자동화된 연계와 웹 이외의 클라이언트와의 접속을 위한 리모팅 기술도 요구됨.

이러한 요구 사항들은 단순히 고가의 애플리케이션 서버나 툴을 사용한다고 충족되지 않아 이런 기술적인 문제를 고려하면서 개발해야한 다는 부담이 발생.

### 엔터프라이즈 애플리케이션이 구현해야 할 핵심 기능인 비즈니스 로직의 복잡합이 증가하기 때문

시간이 지남에 따라 엔터프라이즈 시스템을 이용해 기업의 핵심 업무를 처리하는 비율이 늘어가고 대부분의 업무 처리가 컴퓨터를 이용해야 할 정도로 의존도가 증가.

그로 인해 애플리케이션 개발이 힘들고 복잡해져 감.

또한 2000년 전후로 전 세계에 불어 닥친 경제 위기가 기업의 체질을 크게 바꾸어 경제 흐름과 사회의 변화, 업계의 추이에 따라 수시로 업무 프로세스를 변경하고 조종하는 것을 상시화 해야 할 만큼 변화의 속도가 빨라짐

결국 이런 변화를 뒷받침해줘야 하는 엔터프라이즈 시스템의 변경이 필연적.

버그나 오류로 인한 것이 아닌 기능 요구 사항과 업무 정책으로 인한 결과.

## 복잡합을 가중시키는 원인

엔터프라이즈 애플리케이션 개발이 실패하는 주요 원인 : 비즈니스 로직의 복잡함, 기술적인 복잡함.

여기서 복잡하다는 것의 의미는 세부 요소가 이해하기 힘든 방식으로 얽혀 있고, 때문에 쉽게 다루기 어렵다는 의미.

심지어 비즈니스 로직과 엔터프라이즈 기술이라는 두 가지 복잡함이 한데 얽혀 있어 복잡함이 몇 배로 가중됨.

# 복잡함을 해결하려는 도전

## 제거될 수 없는 근본적인 복잡함

근본적으로 엔터프라이즈 개발에 나타나는 복잡함의 원인은 제거 대상이 아님.

물론 구현해야 할 비즈니스 로직의 적용 범위를 줄이고, 기술적인 요구 조건을 일부 생략한다면 개발이 용이해지고 실패하지 않을 수도 있지만 현실적으로 불가능.

대신 그 복잡함을 효과적으로 상대할 수 있는 전략과 기법이 필요.

문제는 비즈니스 로직의 복잡함을 효과적으로 다루기 위한 방법과 기술적인 복잡함을 효과적으로 적용하는 방법이 다르다는 것.

이를 해결하기 위해서는 성격이 다른 두 가지 복잡함을 분리해내야 함.

### 실패한 해결책 : EJB

EJB의 기본 전략도 이 두 가지 종류의 복잡함을 분리하는 것이었으나 결과적으로 실패.

EJB는 기술적인 복잡함을 애플리케이션의 핵심 로직에서 일부 분리하는 데 성공.

선언적 트랜잭션이나 선언적 보안, 컨테이너를 통한 리모팅 기술의 적용, 컴포넌트 단위의 배치, JNDI를 통한 서비스 검색 지원, 서비스 오브젝트의 풀링, 컴포넌트 생명 주기 관리 등은 EJB의 목표를 어느 정도 충족.

반면 EJB 환경에서 동작하기 위해 특정 인터페이스를 구현하고, 특정 클래스를 상속하고, 서버에 종속적인 서비스를 통해서만 접근하고 사용이 가능하게 만드는 등의 EJB 개발 방식은 잘못된 선택.

why? 애플리케이션 로직을 담은 핵심 코드에서 일부 기술적인 코드가 제거된 건 사실이지만, 오히려 EJB라는 환경과 스펙에 종속되는 코드로 만들어져야 하는 더 큰 부담을 만듦.

일부 기술적인 복잡함을 덜어주려는 시도를 하다 오히려 더 큰 복잡함이 추가됨.

심지어 EJB라는 틀 안에서 자바 코드를 만드는 것이 강제함으로써 자바의 강점마저 잃어버리게 됨. → 상속 구조 적용 불가, 다형성 적용 근본적으로 제한 등.

결국 EJB는 객체 지향적인 특성은 잃은 채 밋밋한 서비스 스크립트 성 코드로 변질 

### 비침투적 방식을 통한 효과적인 해결책(스프링)

스프링은 EJB의 처음 목표와 마찬가지로 기술적인 복잡함을 애플리케이션 핵심 로직의 복잡함에서 제거하는 데 목표를 뒀지만 그 과정에서 EJB가 범했던 실수를 반복하지는 않음 → 개발자의 코드에 난입하여 지저분하고 복잡한 코드를 만드는 것.

침투적인 기술 : EJB처럼 어떤 기술을 적용할 때 기술과 관련된 코드나 규약 등이 코드에 등장하는 경우

물론 꼭 필요한 특정 기술의 API를 이용하기 위한 경우는 어쩔 수 없음

비침투적인 기술 : 기술의 적용 사실이 코드에 직접 반영되지 않는 경우

코드의 설계와 구현 방식을 제한하지 않는다는 것이 가장 큰 특징

# 복잡함을 상대하는 스프링의 전략

## 기술적 복잡함을 상대하는 전략

### 기술에 대한 접근 방식이 일관성이 없고, 특정 환경에 종속적

일관성 없는 기술과 서버 환경의 변화에 대한 스프링의 공략 방법으로 서비스 추상화 채택 가능

기술적인 복잡함은 추상화를 통해 로우 레벨의 기술 구현 부분과 기술을 사용하는 인터페이스를 분리하고, 환경과 세부 기술에 독립적인 접근 인터페이스를 제공하는 것이 가장 좋은 해결책

### 기술적인 처리를 담당하는 코드가 성격이 다른 코드에 섞여서 등장

AOP : 최후까지 애플리케이션 로직을 담당하는 코드에 남아 있는 기술 관련 코드를 분리하여 별도의 모듈로 관리하게 해주는 기술.

기술과 비즈니스 로직이 지저분하게 얽혀서 다루기 힘든 경우와 기술적인 코드가 중복돼서 나타나는 경우 AOP 적용을 통해 해결 가능

## 비즈니스와 애플리케이션 로직의 복잡함을 상대하는 전략

기술적인 코드, 침투적인 기술이 가져온 불필요한 코드들을 제거 → 애플리케이션의 주요 기능과 비즈니스 로직을 담은 코드만 독립적으로 존재.

이 중 기술적인 부분과 느슨하게 연관되는 데이터 처리 코드나 웹이나 리모트 인터페이스 코드 등을 제외 → 비즈니스 로직 코드를 다루는 코드

애플리케이션에서 핵심이 되는 부분이자 업무의 변화에 따라 자주 변경되거나 수정되는 부분 → 대체로 복잡.

자주 바뀌는 업무 정책, 비즈니스 규칙, 업무 흐름을 담고 있을 뿐만 아니라 복잡한 데이터 분석 및 그에 따른 작업 수행, 클라이언트가 필요한 결과를 생성해야 함.

만약 오류가 발생할 경우 업무 자체에 큰 지장을 주거나 치명적인 손실을 끼칠 수도 있음.

과거 SQL을 통해 비지니스 로직을 표현하고 DB에 동작하는 저장 프로시저를 통해 핵심 로직을 처리하는 경우가 많았지만, 엔터프라이즈 시스템의 규모가 커지고, 복잡함이 증가하면서 DB에 비즈니스 로직을 두는 건 매우 불편할 뿐더러 위험한 일이 됨.

가장 확장이 어렵고 확장하더라도 많은 비용이 드는 공유 자원인 DB에 커다란 부담을 주는 것과 데이터 액세스 중심으로 로직을 다루면 개발과 유지 보수는 물론이고 테스트도 어렵기 때문.

때문에 엔터프라이즈 시스템 개발의 흐름은 점차 애플리케이션 안에서 비즈니스 로직을 처리하도록 만드는 추세.

DB는 단지 데이터의 영구적인 저장과 복잡한 조건을 가진 자체적으로 특화된 기능에만 활용하고, 데이터를 분석하고 가공하고 그에 따라 로직을 처리하는 부분은 확장하기 쉽고, 비용도 싼 애플리케이션 서버 쪽으로 이동.

오브젝트에 담긴 로직은 테스트도 용이.

심지어 목 오브젝트를 이용하면 DB가 없어도 테스트 가능.

객체 지향 프로그래밍 기법과 언어가 주는 장점인 유연한 설계가 가능하고 재사용성이 높다는 점을 잘 활용하면 자주 바뀌고 조건이 까다로운 비즈니스 로직 효과적으로 구현 가능.

결국 비즈니스 로직의 복잡함을 상대하는 전략은 자바라는 객체 지향 기술.

## 핵심 도구 : 객체 지향과 DI

스프링의 기본 전략은  비즈니스 로직의 복잡함을 상대하는 가장 효과적인 객체 지향에 충실한 설계가 가능하도록 단순한 오브젝트로 개발 가능하고, 객체 지향의 설계 기법을 잘 적용할 수 있는 구조를 만들기 위해 DI 같은 유용한 기술을 편하게 적용하도록 도와주는 것.

서비스 추상화, 템플릿/콜백, AOP와 같은 스프링의 기술은 모두 DI 없이 존재 불가능한 것들.

객체 지향 언어를 쓴다고 자연스럽게 객체 지향 설계가 되고 객체 지향 프로그래밍이 되는 것은 아님.

DI는 객체 지향적인 설계와 개발로 자연스럽게 이끌어줌.

DI를 의식하다 보면 오브젝트를 설계할 때 DI를 적용할 후보가 더 있는 지에 대해 생각하게 되는데 그런 후보를 찾을 수 있다면 DI를 적용해서 오브젝트를 분리하고, 인터페이스를 도입하고 DI로 관계 연결 가능.

결국 DI는 좋은 오브젝트 설계의 결과물이기도 하지만, 반대로 DI를 열심히 적용하다 보면 객체 지향 설계의 원칙을 잘 따르고 그 장점을 살린 설계가 나올 수도 있음.

기술적인 복잡함을 해결하는 문제나 기술적인 복잡함이 비즈니스 로직에 침범하지 못하도록 분리하는 경우에도 DI가 바탕이 된 여러 가지 기법이 활용됨.

반면, 비즈니스 로직 자체의 복잡함을 해결하려면 DI보다는 객체 지향 설계 기법이 더 중요.

why? 순수한 비즈니스 로직만을 담고 있는 코드에는 객체 지향 분석과 설계에서 나온 도메인 모델을 쉽게 적용 가능하기 때문.

결국 모든 스프링의 기술과 전략은 객체 지향이라는 자바가 가진 강력한 도구를 극대화하여 사용 가능하도록 돕는 것.

# POJO 프로그래밍

스프링의 정수는 엔터프라이즈 서비스 기능을 POJO에 제공하는 것.

엔터프라이즈 서비스 : 보안, 트랜잭션과 같은 엔터프라이즈 시스템에서 요구되는 기술.

위의 말은 엔터프라이즈 서비스 기술과 POJO라는 애플리케이션 로직을 담은 코드를 분리했다는 뜻.

분리됐지만 반드시 필요한 엔터프라이즈 서비스 기술을 POJO 방식으로 개발된 애플리케이션 핵심 로직을 담은 코드에 제공하는 것이 스프링의 특징과 목표.

## 스프링의 핵심 : POJO

<img width="534" height="292" alt="{2F1E9B08-22CC-4D10-91D5-618344E579AA}" src="https://github.com/user-attachments/assets/7580e784-f455-41b1-b18a-6a159ff7fced" />

위의 그림은 스프링으로 개발한 애플리케이션의 기본 구조를 나타냄.

스프링 애플리케이션은 POJO를 이용해서 만든 애플리케이션 코드와 POJO가 어떻게 관계를 맺고 동작하는 지를 정의해 놓은 설계 정보로 구분.

DI의 개념은 유연하게 확장 가능한 오브젝트를 만들어두고 그 관계는 외부에서 다이나믹하게 설정해준다는 것.

스프링의 주요 기술인 IoC/DI, AOP, PSA는 애플리케이션을 POJO로 개발할 수 있게 해주는 가능 기술이라고 불림.

## POJO란?

POJO : Plain Old Java Object의 약자. 2000년대 초반 마틴 파울러는 EJB처럼 복잡하고 제한이 많은 기술을 사용하는 것보다 자바의 단순한 오브젝트를 이용해 애플리케이션의 비즈니스 로직을 구현하는 것이 낫다고 생각했지만 자바의 단순한 오브젝트를 이용하는 것에는 그럴싸한 이름이 없어 꺼려한다는 것을 알고 붙인 이름.

## POJO의 조건

POJO 프로그래밍이란 아래 세 가지 조건을 충족한 경우 성립.

### 특정 규약에 종속되지 않음

자바 언어와 꼭 필요한 API 외에는 종속되지 않아야 함.

특정 규약을 따라 만들게 하는 경우 대부분 규약에서 제시하는 특정 클래스 상속 요구.

그런 경우 자바의 단일 상속 제한으로 인해 해당 클래스에 객체 지향적인 설계 적용이 어려워짐.

또한 규약이 적용된 환경에 종속되어 다른 환경으로 이전이 힘듦.

### 특정 환경에 종속되지 않음

특정 환경에 종속적이어야만 동작하는 오브젝트도 POJO가 아님.

어떤 경우 특정 벤더의 서버나 특정 기업의 프레임 워크 안에서만 동작 가능한 코드로 작성되기도 하고, 환경에 종속적인 클래스나 API를 직접 쓴 경우도 존재.

이런 식으로 순수한 애플리케이션 로직을 담고 있는 오브젝트 코드가 특정 환경에 종속되게 만드는 경우라면 POJO가 아님.

특히 비즈니스 로직을 담고 있는 POJO 클래스는 웹이라는 환경 정보나 웹 기술을 담고 있는 클래스나 인터페이스를 사용해서는 안됨.

설령 나중에 웹 컨트롤러와 연결돼서 사용될 것이 뻔하더라도 직접 환경을 제한해버리는 오브젝트나 API에 의존하면 안됨.

소스 코드에 직접 메타 정보를 추가해주는 어노테이션 사용의 경우에는 환경에 종속되지만 않는다면 여전히 POJO.

하지만 어노테이션이나 앨리먼트 값에 특정 기술과 환경에 종속적인 정보를 담고 있다면 POJO로서의 가치를 잃어버린 것으로 간주.

그렇다고 특정 기술 규약과 환경에 종속되지 않는다고 모두 POJO는 아님.

책임과 역할이 각기 다른 코드를 한 클래스에 모두 넣어 만능 클래스로 만드는 경우, 재사용이 불가능할 정도로 다른 레이어와 영역의 코드와 강한 결합을 가지고 만들어지는 경우, 상속과 다형성을 적용하지 않고 if/switch 문으로 긴 메소드를 작성해 놓은 경우 등 → POJO 프로그래밍으로 보기 어려움.

진정한 POJO란 객체 지향적인 원리에 충실하면서, 환경과 기술에 종속되지 않고 필요에 따라 재활용될 수 있는 방식으로 설계된 오브젝트.

그런 POJO에 애플리케이션의 핵심 로직과 기능을 담아 설계하고 개발하는 방법이 POJO 프로그래밍.

## POJO의 장점

특정한 기술과 환경에 종속되지 않는 오브젝트. 즉, POJO는 그 자체로 장점.

why? 코드가 로우 레벨의 기술과 환경에 종속적이지 않아 깔끔하기 때문.

또한 자동화된 테스트에 매우 유리.

환경의 제약이 있는 코드의 경우 자동화된 테스트가 매우 복잡하고 번거로워 대부분 수동 테스트 방식을 선호.

하지만 어떤 환경에도 종속되지 않은 POJO 코드는 매우 유연한 방식으로 원하는 레벨에서 코드를 빠르고 명확하게 테스트 가능.

객체 지향적인 설계를 자유롭게 적용할 수 있다는 것도 매우 큰 장점.

객체 지향 프로그래밍은 지금까지의 프로그래밍 패러다임 중 가장 성공했고, 가장 많은 언어에 적용됐으며, 엔터프라이즈 시스템에서와 같이 복잡한 문제 도메인을 가진 곳에서 효과적으로 사용될 수 있음이 오랜 시간을 걸쳐 증명됨.

## POJO 프레임워크

POJO 프레임워크 : POJO 프로그래밍이 가능하도록 기술적인 기반을 제공하는 프레임워크.

대표적으로 스프링 프레임워크와 하이버네이트가 있음.

하이버네이트의 경우 DB 이용 기술에 POJO를 적용하는 것이 목적이지만, 스프링은 엔터프라이즈 애플리케이션 개발의 모든 영역과 계층에서 POJO 방식의 구현이 가능하게 하려는 목적.

<img width="676" height="392" alt="{7D1DA6F1-F50C-4093-BAB1-D71BFA8DC39D}" src="https://github.com/user-attachments/assets/3c29afd8-2cb2-4b8e-b495-e818a58387c5" />

스프링은 POJO 프레임워크로서 자신을 노출하지 않으면서 애플리케이션을 POJO로 쉽게 개발할 수 있게 지원.

how? 비즈니스 로직의 복잡함과 엔터프라이즈 기술의 복잡함을 분리해서 구성 가능케 하지만 기술 영역 외에는 모습을 드러내지 않음.

# 스프링의 기술

POJO 프로그래밍 적용을 지원하는 세 가지 가능 기술

IoC/DI, AOP, PSA.

스프링 이전에도 시도됐었고 발전하고 있었고 객체 지향의 설계와 개발 원리를 잘 적용하다 보면 자연스럽게 만들어 지는 것이었지만 스프링은 이를 통일성 있고 개발의 전 영역에 걸쳐 더 효과적으로 적용될 수 있도록 프레임워크 형태로 제공.

## 제어의 역전(IoC) / 의존 관계 주입(DI)

스프링의 핵심 개발 원칙으로 나머지 두 기술인 AOP와 PSA도 IoC/DI에 바탕을 둠.

또한 템플릿/콜백 패턴 역시 마찬가지.

왜 DI를 사용할까? 이 방식의 장점이 무엇일까?

유연한 확장에 유리한 구조이기 때문.

DI는 개방 폐쇄 원칙이라는 객체 지향 설계 원칙으로 설명이 가능.

유연한 확장, 변경에 닫혀있고, 재사용이 가능.

## DI의 활용 방법

### 핵심 기능의 변경

DI의 가장 대표적인 적용 방법 → 의존 대상의 구현을 바꾸는 것

### 핵심 기능의 동적인 변경

의존 오브젝트의 핵심 기능 자체를 동적으로 바꾸는 것.

이 경우 동적인 방식으로 연결되지만 한 번 DI되면 바뀌지 않는 정적인 관계를 맺어주는 것.

하지만 DI를 잘 활용하면 애플리케이션이 동작하는 중간에 의존 대상을 동적으로 변경 가능.

How? 객체 생성과 의존성 연결을 코드에서 하지 않고, 컨테이너가 대신 하는 방식으로.

이를 통해 유연하게 주입을 바꿀 수 있고, 상황에 따라 객체를 바꿔 쓰기 가능.

### 부가 기능의 추가

핵심 기능은 그대로 둔 채 부가 기능을 추가하는 것.

인터페이스를 두고 사용하게 하고, 실제 사용할 오브젝트는 외부에서 주입하는 DI를 적용해두면 핵심 기능과 클라이언트 코드에 전혀 영향을 주지 않으면서 부가적인 기능을 추가 가능.

### 인터페이스의 변경

사용하려고 하는 오브젝트가 가진 인터페이스가 클라이언트와 호환되지 않는 경우가 존재.

또는 여러 종류의 인터페이스를 가졌지만 사실은 비슷한 기능을 담당하는 오브젝트를 바꿔가며 사용하고 싶은 경우에도 DI가 유용.

How? 어댑터 오브젝트를 통해 DI해주는 방식으로 인터페이스가 다른 오브젝트를 클라이언트가 사용하는 인터페이스로 바꿔주는 기능을 이용하여.

이를 좀 더 일반화하여 아예 인터페이스가 다른 다양한 구현을 같은 방식으로 사용하도록 중간에 인터페이스 어댑터 역할을 해주는 레이어를 하나 추가하는 방법도 존재.

서비스 추상화가 대표적인 방법.

### 프록시

필요한 시점에 실제 사용할 오브젝트를 초기화하고 리소스를 준비하게 해주는 지연된 로딩을 적용하려면 프록시가 필요.

원격 오브젝트를 호출할 때 로컬에 존재하는 오브젝트처럼 사용 가능하게 해주는 원격 프록시를 적용할 때도 프록시가 필요.

위 두 가지 방법 모두 DI 필요.

### 템플릿과 콜백

반복적으로 등장하지만 항상 고정적인 작업 흐름과 그 사이 자주 바뀌는 부분을 분리해서 템플리솨 콜백으로 만들고 이를 DI를 통해 적용 → 코드가 간결해짐.

콜백을 통해 개방을 통한 유연한 확장성 확보, 템플릿을 통해 기능의 확장에도 변하지 않는다는 OCP의 폐쇄 원칙에 잘 들어 맞음

### 싱글톤과 오브젝트 스코프

DI가 필요한 이유 중 하나는 DI 할 오브젝트의 생명 주기 제어가 가능하다는 것

DI를 프레임 워크로 이용한다는 것은 DI 대상 오브젝트를 컨테이너가 관리한다는 것.

오브젝트의 생성부터 관계 설정, 이용, 소멸에 이르기까지 모든 과정을 DI 컨테이너가 주관하기 때문에 해당 오브젝트의 스코프를 자유롭게 제어 가능.

가장 기본이 되는 스코프는 싱글톤.

하나 또는 소수의 오브젝트가 수많은 클라이언트를 상대로 고성능 서비스를 제공하는 방식은 엔터프라이즈 개발에서 매우 중요.

상태를 갖지 않도록 만든 오브젝트가 동시에 여러 스레드의 요청을 처리하는 이런 방식을 적용하려면, 만들어지는 오브젝트의 개수를 제어하는 일이 매우 중요.

스프링의 DI는 기본적으로 싱글톤으로 오브젝트를 만들어서 사용하게 함.

때로는 단일 싱글톤이 아닌 임의의 생명 주기를 가진 오브젝트가 필요할 때도 존재.

스프링에서는 싱글톤 외에 다양한 스코프를 가지는 오브젝트를 만들어 DI에 사용 가능.

HTTP 요청 당 하나 또는 HTTP 세션 당 하나씩 오브젝트가 만들어지게도 가능.

### 테스트

여타 오브젝트와 협력하여 동작하는 오브젝트를 효과적으로 테스트하는 방법은 가능한 한 고립시키는 것. 

다른 오브젝트 사이에서 일어나는 일은 테스트를 위해 조작 가능하게 만들어 테스트 대상인 오브젝트의 기능에 충실하게 테스트 가능.

DI를 위해 만든 수정자 메소드를 사용하면 테스트 코드 안에서 수동으로 목 오브젝트 주입 가능.

# 애스펙트 지향 프로그래밍(AOP)

객체 지향 기술은 매우 성공적인 프로그래밍 방식인 한편 점점 복잡해져가는 애플리케이션의 요구 조건과 기술적 난해함을 모두 해결하는 데 한계가 존재.

AOP는 이런 한계를 극복하도록 도와주는 보조적인 프로그래밍 기술.

## AOP 적용 기법

### 스프링과 같이 다이나믹 프록시를 사용하는 방법.

기존 코드에 영향을 주지 않고 부가 기능을 적용하게 해주는 데코레이터 패턴을 응용한 방법.

자바 객체 지향 패턴을 활용한 방법이기에 만들기 쉽고 적용이 간단하지만 부가 기능을 부여할 수 있는 곳이 메소드의 호출이 일어나는 지점 뿐이라는 제약 존재.

### 자바 언어의 한계를 넘어서는 언어의 확장을 이용하는 방법.

AspectJ : 강력한 고급 기능을 가진 AOP 를 제공하는 오픈 소스 AOP 툴

메소드 호출뿐 아닌 인스턴스 생성, 필드 액세스, 특정 호출 경로를 가진 메소드 호출 등에 부가 기능 제공 가능.

자바 언어와 JDK의 지원만으로는 위의 고급 AOP 기능 적용 불가능 → 별도의 방법 이용 필요.

사용하기 까다롭고 번잡하지만 경우에 따라서 프록시 방식의 AOP로는 할 수 없는 경우 사용.

## AOP의 적용 단계

## 1단계 : 미리 준비된 AOP 이용

처음에는 스피링이 미리 만들어서 제공하는 AOP 기능 그대로 가져다 적용.

트랜잭션과 Configuration이 가장 대표적인 AOP 기능.

## 2단계 : 전담 팀을 통한 정책 AOP 적용

개발자 개개인이 직접 이용하기에는 이르지만 애플리케이션 전체적으로 이용 가능한 것을 소수의 AOP 담장자 관리 하에 적용 시도 가능.

대표적으로 비즈니스 로직을 가진 오브젝트에 대한 보안, 특정 계층의 오브젝트 이용 전후의 작업 기록을 남기는 로깅, 데이터 추적을 위한 트레이싱, 특정 구간의 실시간 성능 모니터링과 같은 정책적으로 적용할 만한 기능에 AOP를 이용하는 것.

이런 기능을 개발자 개인이 직접 추가하는 경우 개발 표준이나 가이드 라인이 완벽히 준비된 상태에서 개발해야 함.

하지만 변경 사항에 대해서 모두 수정하고 일일이 검증해야 하는 부담이 존재.

이런 일을 AOP를 이용해 한 번에 적용하는 경우 AOP를 책임지는 소수의 인원만 고생하면 됨.

또한 AOP는 언제든지 기능을 추가하거나 제거 가능.

AOP 모듈을 통해 정책 위반 코드에 예외를 던지고 관리자에게 통보가 가도록 할 수 있음.

이를 통해 동적으로 동작하면서 개발 정책을 위반한 코드를 잡는 데에도 유용.

개발이 끝난 뒤 실전 적용 시에는 AOP 설정을 간단히 제거도 가능.

## 3단계 : AOP이 자유로운 이용

AOP에 친숙해지고 장단점과 응용 전략, 위험성 등을 어느 정도 이해했다면 개발자 스스로가 AOP 활용 가능.

# 포터블 서비스 추상화(PSA)

세 번째 가능 기술은 환경과 세부 기술의 변화에 관계 없이 일관된 방식으로 기술에 접근할 수 있게 해주는 PSA.

POJO로 개발된 코드는 특정 환경이나 구현 방식에 종속적이지 않아야 함.

하지만 필요한 기술이나 환경에는 의존적일 수 있음.

이를 위해 스프링에서 제공되는 대표적인 기술이 바로 서비스 추상화.

스프링의 서비스 추상화의 개념과 장점을 잘 이해한다면 때에 따라 직접 서비스 추상화 기법 적용 필요.

서비스를 위해 필요한 기술은 DI 뿐이고 결국 DI 응용 방법의 한 가지이므로 DI를 적극 활용해서 개발한다면 서비스 추상화는 자연스레 만들어 쓸 수 있음.
