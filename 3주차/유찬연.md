개방 폐쇄 원칙 : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다는 객체 지향 설계의 핵심 원칙

이 원칙을 통해 알 수 있는 점
코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확자하려는 성질을 가지고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음

변화의 특성이 다른 부분을 구분해주고, 각기 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 바로 '개방 폐쇄 원칙'

템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용될 수 있도록 하는 방법

즉, 템플릿은 개방 폐쇄 원칙을 더 효과적으로 활용하기 위해 사용하는 방법

JDBC 코드에서 try/catch/finally 구문 사용을 권장하는 이유(예외 처리)
일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어 재사용 가능한 풀로 관리
DB 풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용 가능
그런데 오류로 인해 미처 반환되지 못하는 Connection이 계속 쌓이면 어느 순간 커넥션 풀에 여유가 없어지고 리소스가 부족해지는 오류가 발생하며 서버가 중단될 수 도 있음
장시간 운영되는 다중 사용자를 위한 서버에 적용하기에는 치명적인 위험을 내포

사용한 리소스는 가능한 빠르게 반환되어야 함
그렇지 않으면 풀에 있는 리소스가 고갈되고 결국 문제가 발생

<img width="783" height="651" alt="image" src="https://github.com/user-attachments/assets/c4fc5ca2-c14b-402a-bf45-e803040bbf78" />

ps와 c가 널일 때 close() 메소드가 호출되면 NullPointerException이 발생하므로 두 변수 값이 null인 경우에 관해 예외 처리

<img width="712" height="874" alt="image" src="https://github.com/user-attachments/assets/36ccd464-5564-4bed-9e28-0d6948e2ff47" />
<img width="733" height="213" alt="image" src="https://github.com/user-attachments/assets/1422786a-4b0f-4ca0-a1d5-c982f96afe87" />

조회 기능의 예외 처리에서도 마찬가지로 try/catch/finally를 통해 수정
ResultSet이 추가되기에 ResultSet의 close() 메소드가 반드시 호출되도록 작성

JDBC try/catch/finally 코드의 문제점은 변하지 않지만 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내어 해결 가능

메소드 추출 : 변하는 부분을 메소드로 추출하여 해결하는 방법
<img width="741" height="529" alt="image" src="https://github.com/user-attachments/assets/3f3786ea-74ba-42e8-a171-51a7d50cd77d" />

보통 메소드 추출 리팩토링을 적용하는 경우 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하지만,
이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어 확장돼야 하는 부분
따라서 큰 이득이 없음.

템플릿 메소드 패턴 : 상속을 통해 기능을 확장해서 사용하는 부분
변하지 않는 부분을 슈퍼 클래스에 두고 변하는 부분은 추상 메소드로 정의하여 서브 클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것
<img width="726" height="259" alt="image" src="https://github.com/user-attachments/assets/05accabb-9e90-43c5-9bb5-caa9f20ee92f" />

이 방법은 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장 가능하고, 
확장으로 인한 기존의 상위 클래스에 불필요한 변화는 생기지 않도록 할 수 있음
하지만 템플릿 메소드 패턴으로의 접근은 제한이 많음
가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점
이것 역시 메리트가 크지 않음.

전략 패턴의 적용
개방 폐쇄 원칙을 잘 지키는 구조이면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어남
오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴.
전략 패턴 : OCP 관점에서 확장에 해당하는 변하는 부분을 별도의 클래스를 만들어 추상화된 인터페이스를 통해 위임하는 방식
<img width="673" height="267" alt="image" src="https://github.com/user-attachments/assets/1a39ab39-452b-43e4-b994-8d1b3d6e82c6" />
좌측의 Context의 contextMethod()에서 일정한 구조를 가지고 동작하다가 
특정 확장 기능은 Strategy 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것
contextMethod()가 변하지 않는 부분을 의미.
전략이 변하는 부분을 의미.

전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스를 상속하여 전략 부분을 작성
<img width="767" height="210" alt="image" src="https://github.com/user-attachments/assets/ca52ee6e-1229-4786-ad91-011d82b4b551" />
<img width="628" height="243" alt="image" src="https://github.com/user-attachments/assets/e8d77b3c-7312-43bc-966b-991a36386896" />
<img width="754" height="390" alt="image" src="https://github.com/user-attachments/assets/10cb3e37-9e62-4a1e-b95c-c17e47882b96" />

위 이미지들은 전략 패턴을 그럭저럭 적용시켰지만 문제점이 있음
전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는 것인데,
이렇게 컨텍스트 안에 구체적인 전략 클래스를 사용하도록 고정되어 있음.

이를 해결하기 위한 실제적인 전략 패턴의 사용 방법.
전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적.
Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것.

그런데 이는 의존 관계 주입과 동일.
결국 DI란 이러한 전략 패턴의 장저을 일반적으로 활용할 수 있도록 만든 구조.

<img width="788" height="563" alt="image" src="https://github.com/user-attachments/assets/ccc75efd-5dfa-4277-8f76-c1c846548e18" />
이를 적용시켜 컨텍스트에 해당하는 부분을 별도의 메소드로 독립시킨 이미지

<img width="706" height="179" alt="image" src="https://github.com/user-attachments/assets/a6c6421f-b9ca-4171-9ef9-34a02f5f5644" />
클라이언트 책임을 담당할 deleteAll() 메소드

구조로 볼 때 완벽한 전략 패턴의 모습을 갖춤.
비록 클라이언트와 컨텍스트는 클래스를 분리하지는 않았지만, 의존 관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계

DI의 가장 중요한 개념 : 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것.

PreparedStatment를 만드는 코드를 AddStatement 클래스에 작성한 이미지
<img width="795" height="435" alt="image" src="https://github.com/user-attachments/assets/a16d4e86-c639-4bb5-b7a8-9252fbc48fbc" />

하지만 클래스를 분리하고 나니 컴파일 에러가 발생 why? add()에서는 user라는 부가적인 정보가 필요하기 때문

클라이언트로부터 User 타입 오브젝트를 받을 수 있도록 AddStatement의 생성자를 통해 제공받도록 수정.
<img width="767" height="310" alt="image" src="https://github.com/user-attachments/assets/65816732-867d-4086-9c8d-0a0ed2d7baba" />
<img width="732" height="281" alt="image" src="https://github.com/user-attachments/assets/dac7ed6e-2031-4a89-b88d-a90863ecbbe6" />

user 정보를 생성자를 통해 클라이언트의 add() 메소드로 전달해주도록 수정한 이미지
<img width="721" height="180" alt="image" src="https://github.com/user-attachments/assets/a3cdbbc8-899b-4061-95ac-fbd3fa42ab61" />

지금 만들어진 구조의 불편한 점.
1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점.
2. DAO 메소드에서 StatementStrategy에 전달할 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와
   이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점.

우선 첫번째 문제 해결 방법으로는 StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의하는 것(로컬 클래스)
<img width="704" height="564" alt="image" src="https://github.com/user-attachments/assets/befc60e4-e415-4445-a13b-39550d4da977" />
<img width="732" height="227" alt="image" src="https://github.com/user-attachments/assets/aa4364e2-9550-4946-a638-a2b7297cf6e9" />

중첩 클래스 : 다른 클래스 내부에 정의되는 클래스
중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스(static class)와 
자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분
내부 클래스는 다시 범위(scope)에 따라 세 가지로 구분됨
멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스(member inner class),
메소드 레벨에 정의되는 로컬 클래스(local class),
이름을 갖지 않는 익명 내부 클래스(anonymous inner class)
익명 내부 클래스의 범위는 선언된 위치에 따라 다름

로컬 클래스는 마치 로컬 변수 선언하듯이 선언하면 됨.
로컬 클래스는 선언된 메소드 내에서만 사용 가능.
또한 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있음.
덕분에 번거롭게 생성자를 통해 오브젝트를 전달해줄 필요가 없음. 
why?
내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문.
다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수가 반드시 final로 선언되어야 함.
