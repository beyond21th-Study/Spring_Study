개방 폐쇄 원칙 : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다는 객체 지향 설계의 핵심 원칙

이 원칙을 통해 알 수 있는 점
코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확자하려는 성질을 가지고, 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음

변화의 특성이 다른 부분을 구분해주고, 각기 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 바로 '개방 폐쇄 원칙'

템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용될 수 있도록 하는 방법

즉, 템플릿은 개방 폐쇄 원칙을 더 효과적으로 활용하기 위해 사용하는 방법

JDBC 코드에서 try/catch/finally 구문 사용을 권장하는 이유(예외 처리)
일반적으로 서버에서는 제한된 개수의 DB 커넥션을 만들어 재사용 가능한 풀로 관리
DB 풀은 매번 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용 가능
그런데 오류로 인해 미처 반환되지 못하는 Connection이 계속 쌓이면 어느 순간 커넥션 풀에 여유가 없어지고 리소스가 부족해지는 오류가 발생하며 서버가 중단될 수 도 있음
장시간 운영되는 다중 사용자를 위한 서버에 적용하기에는 치명적인 위험을 내포

사용한 리소스는 가능한 빠르게 반환되어야 함
그렇지 않으면 풀에 있는 리소스가 고갈되고 결국 문제가 발생

<img width="783" height="651" alt="image" src="https://github.com/user-attachments/assets/c4fc5ca2-c14b-402a-bf45-e803040bbf78" />

ps와 c가 널일 때 close() 메소드가 호출되면 NullPointerException이 발생하므로 두 변수 값이 null인 경우에 관해 예외 처리

<img width="712" height="874" alt="image" src="https://github.com/user-attachments/assets/36ccd464-5564-4bed-9e28-0d6948e2ff47" />
<img width="733" height="213" alt="image" src="https://github.com/user-attachments/assets/1422786a-4b0f-4ca0-a1d5-c982f96afe87" />

조회 기능의 예외 처리에서도 마찬가지로 try/catch/finally를 통해 수정
ResultSet이 추가되기에 ResultSet의 close() 메소드가 반드시 호출되도록 작성

JDBC try/catch/finally 코드의 문제점은 변하지 않지만 많은 곳에서 중복되는 코드와 로직에 따라 자꾸 확장되고 자주 변하는 코드를 잘 분리해내어 해결 가능

메소드 추출 : 변하는 부분을 메소드로 추출하여 해결하는 방법
<img width="741" height="529" alt="image" src="https://github.com/user-attachments/assets/3f3786ea-74ba-42e8-a171-51a7d50cd77d" />

보통 메소드 추출 리팩토링을 적용하는 경우 분리시킨 메소드를 다른 곳에서 재사용할 수 있어야 하지만,
이건 반대로 분리시키고 남은 메소드가 재사용이 필요한 부분이고, 분리된 메소드는 DAO 로직마다 새롭게 만들어 확장돼야 하는 부분
따라서 큰 이득이 없음.

템플릿 메소드 패턴 : 상속을 통해 기능을 확장해서 사용하는 부분
변하지 않는 부분을 슈퍼 클래스에 두고 변하는 부분은 추상 메소드로 정의하여 서브 클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것
<img width="726" height="259" alt="image" src="https://github.com/user-attachments/assets/05accabb-9e90-43c5-9bb5-caa9f20ee92f" />

이 방법은 클래스의 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장 가능하고, 
확장으로 인한 기존의 상위 클래스에 불필요한 변화는 생기지 않도록 할 수 있음
하지만 템플릿 메소드 패턴으로의 접근은 제한이 많음
가장 큰 문제는 DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다는 점
이것 역시 메리트가 크지 않음.

전략 패턴의 적용
개방 폐쇄 원칙을 잘 지키는 구조이면서 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어남
오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴.
전략 패턴 : OCP 관점에서 확장에 해당하는 변하는 부분을 별도의 클래스를 만들어 추상화된 인터페이스를 통해 위임하는 방식
<img width="673" height="267" alt="image" src="https://github.com/user-attachments/assets/1a39ab39-452b-43e4-b994-8d1b3d6e82c6" />
좌측의 Context의 contextMethod()에서 일정한 구조를 가지고 동작하다가 
특정 확장 기능은 Strategy 인터페이스를 통해 외부의 독립된 전략 클래스에 위임하는 것
contextMethod()가 변하지 않는 부분을 의미.
전략이 변하는 부분을 의미.

전략 패턴의 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스를 상속하여 전략 부분을 작성
<img width="767" height="210" alt="image" src="https://github.com/user-attachments/assets/ca52ee6e-1229-4786-ad91-011d82b4b551" />
<img width="628" height="243" alt="image" src="https://github.com/user-attachments/assets/e8d77b3c-7312-43bc-966b-991a36386896" />
<img width="754" height="390" alt="image" src="https://github.com/user-attachments/assets/10cb3e37-9e62-4a1e-b95c-c17e47882b96" />

위 이미지들은 전략 패턴을 그럭저럭 적용시켰지만 문제점이 있음
전략 패턴은 필요에 따라 컨텍스트는 그대로 유지되면서 전략을 바꿔 쓸 수 있다는 것인데,
이렇게 컨텍스트 안에 구체적인 전략 클래스를 사용하도록 고정되어 있음.

이를 해결하기 위한 실제적인 전략 패턴의 사용 방법.
전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적.
Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것.

그런데 이는 의존 관계 주입과 동일.
결국 DI란 이러한 전략 패턴의 장저을 일반적으로 활용할 수 있도록 만든 구조.

<img width="788" height="563" alt="image" src="https://github.com/user-attachments/assets/ccc75efd-5dfa-4277-8f76-c1c846548e18" />
이를 적용시켜 컨텍스트에 해당하는 부분을 별도의 메소드로 독립시킨 이미지

<img width="706" height="179" alt="image" src="https://github.com/user-attachments/assets/a6c6421f-b9ca-4171-9ef9-34a02f5f5644" />
클라이언트 책임을 담당할 deleteAll() 메소드

구조로 볼 때 완벽한 전략 패턴의 모습을 갖춤.
비록 클라이언트와 컨텍스트는 클래스를 분리하지는 않았지만, 의존 관계와 책임으로 볼 때 이상적인 클라이언트/컨텍스트 관계

DI의 가장 중요한 개념 : 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다는 것.

PreparedStatment를 만드는 코드를 AddStatement 클래스에 작성한 이미지
<img width="795" height="435" alt="image" src="https://github.com/user-attachments/assets/a16d4e86-c639-4bb5-b7a8-9252fbc48fbc" />

하지만 클래스를 분리하고 나니 컴파일 에러가 발생 why? add()에서는 user라는 부가적인 정보가 필요하기 때문

클라이언트로부터 User 타입 오브젝트를 받을 수 있도록 AddStatement의 생성자를 통해 제공받도록 수정.
<img width="767" height="310" alt="image" src="https://github.com/user-attachments/assets/65816732-867d-4086-9c8d-0a0ed2d7baba" />
<img width="732" height="281" alt="image" src="https://github.com/user-attachments/assets/dac7ed6e-2031-4a89-b88d-a90863ecbbe6" />

user 정보를 생성자를 통해 클라이언트의 add() 메소드로 전달해주도록 수정한 이미지
<img width="721" height="180" alt="image" src="https://github.com/user-attachments/assets/a3cdbbc8-899b-4061-95ac-fbd3fa42ab61" />

지금 만들어진 구조의 불편한 점.
1. DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야 한다는 점.
2. DAO 메소드에서 StatementStrategy에 전달할 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와
   이를 저장해둘 인스턴스 변수를 번거롭게 만들어야 한다는 점.

우선 첫번째 문제 해결 방법으로는 StatementStrategy 전략 클래스를 매번 독립된 파일로 만들지 말고 UserDao 클래스 안에 내부 클래스로 정의하는 것(로컬 클래스)
<img width="704" height="564" alt="image" src="https://github.com/user-attachments/assets/befc60e4-e415-4445-a13b-39550d4da977" />
<img width="732" height="227" alt="image" src="https://github.com/user-attachments/assets/aa4364e2-9550-4946-a638-a2b7297cf6e9" />

중첩 클래스 : 다른 클래스 내부에 정의되는 클래스
중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스(static class)와 
자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분
내부 클래스는 다시 범위(scope)에 따라 세 가지로 구분됨
멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스(member inner class),
메소드 레벨에 정의되는 로컬 클래스(local class),
이름을 갖지 않는 익명 내부 클래스(anonymous inner class)
익명 내부 클래스의 범위는 선언된 위치에 따라 다름

로컬 클래스는 마치 로컬 변수 선언하듯이 선언하면 됨.
로컬 클래스는 선언된 메소드 내에서만 사용 가능.
또한 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보에 접근할 수 있음.
덕분에 번거롭게 생성자를 통해 오브젝트를 전달해줄 필요가 없음. 
why?
내부 메소드는 자신이 정의된 메소드의 로컬 변수에 직접 접근할 수 있기 때문.
다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수가 반드시 final로 선언되어야 함.

내부 클래스의 장점을 이용해 간결해진 AddStatment 이미지.
<img width="788" height="582" alt="image" src="https://github.com/user-attachments/assets/ca479ca8-d925-4145-85f0-e6690dccc193" />

로컬 클래스로 작성시 장점
- 메소드마다 추가해야 했던 클래스 파일을 하나 줄일 수 있다는 것
- 내부 클래스의 특징을 이용해 로컬 변수를 바로 가져다 사용할 수 있다는 것

익명 내부 클래스 : 이름을 갖지 않는 클래스. 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며, 
상속할 클래스나 구현할 인터페이스를 생성자 대신 사용. 
클래스 재사용 필요 x, 구현한 인터페이스 사용할 경우 유용.
new 인터페이스 이름() {클래스 본문};

익명 내부 클래스로 작성된 AddStatement 이미지
<img width="764" height="462" alt="image" src="https://github.com/user-attachments/assets/5b699b99-d411-4172-8832-2acb912510a1" />

<img width="717" height="134" alt="image" src="https://github.com/user-attachments/assets/658ad420-d225-4390-bdd4-d9198705ebf5" />
<img width="760" height="445" alt="image" src="https://github.com/user-attachments/assets/8f4ac13a-978b-4843-b8fe-b07b2ca9e349" />
익명 내부 클래스는 파라미터에서 바로 생성하여 더 간결하게 작성 가능.
익명 내부 클래스는 딱 한번만 사용되기 때문에.

같은 방법으로 적용된 deleteAll() 메소드 이미지
<img width="748" height="355" alt="image" src="https://github.com/user-attachments/assets/e8acf3e2-eda6-49ae-9e9c-c23be3f0185b" />

JDBC의 일반적인 작업 흐름을 담고 있는 jdbcContextWithStatementStrategy()는 다른 DAO에서도 사용 가능
그러므로 jdbcContextWithStatementStrategy()를 UserDao 클래스 밖으로 독립시켜 모든 DAO가 사용 가능하게끔 작성

클래스 분리 이후 DB 커넥션을 필요로 하는 코드가 UserDao가 아닌 JdbcContext가 돼버려 DB 연결이 필요한 곳인 JdbcContext에 DI 필요
아래는 클래스 분리와 의존성 주입 대상 변경이 적용된 코드 이미지.
<img width="794" height="704" alt="image" src="https://github.com/user-attachments/assets/daa6b062-81df-498a-888e-6bc52d5a2d71" />
<img width="781" height="585" alt="image" src="https://github.com/user-attachments/assets/3ec988b3-cba3-482d-a10a-1b1d0fb48aee" />

스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔 사용하도록 하는 게 목적.
but, 이 경우에서는 JdbcContext가 그 자체로 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고 구현 방법이 바뀔 가능성이 없음.
따라서 인터페이스 구현 x.

이 흐름을 나타내는 클래스 다이어그램 이미지.
<img width="736" height="252" alt="image" src="https://github.com/user-attachments/assets/ceda7fc8-b54f-4f9b-bbb1-8d4b9a79a01e" />

빈 오브젝트 관계 흐름에 대한 이미지.
<img width="765" height="160" alt="image" src="https://github.com/user-attachments/assets/5224b5ee-c695-4671-9409-04b81f6060b4" />

인터페이스를 사용하지 않고 DI를 적용하는 것이 문제가 되지는 않을까?
꼭 그럴 필요는 없음.

의존 관계 주입이라는 개념에 충실히 따르자면, 인터페이스를 사이에 둬서 클래스 레벨에서는 의존 관계가 고정되지 않게 하고, 런타임 시에 의존할 오브젝트와의 관계를 동적으로 주입하는 것이 맞음.

하지만 스프링의 DI는 넓게 보자면 개게 생성과 관계 설정에 대한 제어 권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC(제어의 역전) 개념을 포괄

JdbcContext를 UserDao와 DI 구조로 만들어야 할 이유
- JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문.
  JdbcContext는 JDBC 컨텍스트 메소드를 제공해주는 일종의 서비스 오브젝트로서 의미가 있고, 그래서 싱글톤으로 등록돼서 여러 오브젝트에서 공유해 사용되는 것이 이상적
- JdbcContext가 DI를 통해 다른 빈에 의존하기 때문.
  DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록돼어야 함.
  스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문에 다른 빈을 받기 위해서라도 스프링 빈으로 등록되어야 함.

인터페이스를 사용하지 않는 이유
인터페이스가 없다는 것은 UserDao와 JdbcContext가 매우 긴밀한 관계를 가지고 강하게 결합되어 있다는 의미.
클래스는 구분되어 있지만 이 둘은 강한 응집도를 가짐.
이런 경우는 굳이 인터페이스를 두지 않고 강력한 결합을 가진 관계를 허용하면서 위의 두 이유인 싱글톤으로 만드는 것과 JdbcContext에 대한 DI 필요성을 위해 스프링의 빈으로 등록해서 UserDao에 DI 되도록 만들어도 좋음.
하지만 이런 클래스를 바로 사용하는 코드 구성을 DI에 적용하는 것은 가장 마지막 단계에서 고려해볼 사항.
인터페이스 만들기 귀찮으니 그냥 클래스를 사용하는 것은 x.

UserDao 내부에서 직접 DI를 적용하는 방법 -> JdbcContext를 스프링의 빈으로 등록해서 UserDao에 DI 하는 대신 사용 가능
이 방법을 쓰기 위해서는 JdbcContext를 싱글톤으로 만드는 것을 포기해야 함.
물론 DAO 메소드가 호출될 때마다 오브젝트를 새롭게 생성하는 것은 아님.
DAO마다 하나의 JdbcContext 오브젝트를 갖고 있게 하는 것.
JdbcContext에는 내부에 두는 상태 정보가 없어 수십, 수백개가 만들어지더라도 메모르에 주는 부담은 거의 x.
또한 자주 만들어졌다가 제거되는게 아니기 때문에 GC(가비지 컬렉션)에 대한 부담도 x.

JdbcContext를 스프링 빈으로 등록하지 않았으므로 다른 누군가가 생성과 초기화를 책임져야 함.
이는 자신이 사용할 오브젝트를 직접 만들고 초기화하는 전통적인 방법을 사용.

UserDao에서 JdbcContext를 직접 생성해서 사용하는 경우에도 여전히 JdbcContext는 DataSource 타입 빈을 동적으로 주입받아서 사용.
그렇지 않으면 DataSource 구현 클래스를 자유롭게 바꿔가며 적용 불가.
이런 경우 사용 가능한 방법으로는 JdbcContext에 대한 제어권을 갖고 생성과 관리를 담당하는 UserDao에 DI까지 맡기는 것.

UserDao가 임시로 DI 컨테이너처럼 동작하게 만든 DI 구조.
<img width="736" height="272" alt="image" src="https://github.com/user-attachments/assets/d3121b39-631f-4721-b259-8c5cd18291da" />
UserDao와 dataSource 두 개만 빈으로 정의(단순화).
DataSource -> UserDao -> (내부 생성) JdbcContext.
이를 통해 구조를 단순화하고 불필요한 빈을 제거할 수 있음.

JdbcContext 내부 생성 및 DI 작업을 수행하는 setDataSource() 메소드
<img width="739" height="378" alt="image" src="https://github.com/user-attachments/assets/d0033381-719c-4898-9bda-4beeefc1c5b5" />

이 방법의 장점은 굳이 인터페이스를 따로 두지 않아도 될 정도의 긴밀한 관계를 갖는 DAO클래스와 JdbcContext를 어색하게 따로 빈으로 분리하지 않고 내부에서 직접 만들어 사용하면서도 다른 오브젝트에 대한 DI를 적용할 수 있다는 점.

이와 같이 인터페이스를 사용하지 않고 DI를 적용할 수 있음.
하지만 선택한 방법에 대한 분명한 이유와 근거가 있어야 하고, 이유나 근거가 부족한 경우 인터페이스를 만들어서 평범한 DI 구조로 만드는 게 나을 수 있음.
