[ Spring Study Week3 : 템플릿 ]

- 개방폐쇠의 원칙(OCP) : 확장에는 자유롭게 열려 있고, 변경에는 굳게 닫혀 있다는 객체지향 설계의 핵심 원칙.
    * 어떤부분은 변경을 통해 기능이 다양해지고 확장하려는 성질 있고.
    * 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있다.
    * 각기 다른 목적과 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조.

    * 개방 폐쇄 원칙(OCP, Open-Close Principle)
        * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

    * 설계 원칙(SOLID)
        * SRP(Single Responsibility Principle) : 단일 책임 원칙.
        * OCP(Open-Close Principle) : 개방 폐쇄 원칙.
        * LSP(Liskov Substitution Principle) : 리스코프 치환 원칙.
        * ISP(Interface Segregation Principle) : 인터페이스 분리 원칙.
        * DIP(Dependeny Inversion Principle) : 의존관계 역전 원칙.

* 개방 폐쇄 원칙
    * 높은 응집도와 낮은 결합도
        * 높은 응집도 : 화가 일어나면 변하는 부분이 크다. 일부분만 바뀌면 오류를 일일이 확인해야된다.
        * 낮은 결합도 : 변화에 대응하는 속도 up, 확장하기 매우 편리.

- 그래서 템플릿이란?
    * 성절이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜 효과적으로 활용할 수 있도록 하는 방법.


- 예외처리 기능을 갖춘 DAO
    * DB커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC코드에는 지켜야할 원칙이 있다.

    * 바로 예외처리!

    * 정상적인 코드의 흐름을 따르지 않고 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리로스를 반드시 반환해야하기 때문.



- JDBC 수정 기능의 예외처리 코드
￼
    * 위의 그림은 UserDao의 deleteAll() 메소드이다.
    * Connection과 PreparedStatement라는 두개의 공유 리소스를 사용하고 close()로 리소스를 반환한다.
    * 하지만 PreparedStatement처리중 예외가 발생하면? -> 메소드는 실행되지못하고 메소드 나감.
    * 리소스가 반환되지 않을 수 있음.

    * 일반 서버에서는 제한된 개수의 DB커넥션을 만들어 재사용 가능한 풀로 관리하는데 DB풀은 getConnection()으로 가져간 커넥션을 명시적으로 close()해서 돌려줘야하지만 다시 풀에 넣었다가 재사용한다.

    * 이런식 오류가 날 때마다 미처 반환되지 못한 Connection이 쌓이면 풀에 여유 X, 리소스 모자란 오류-> 서버 중단.
    * 그래서 위의 코드는 장시간 운영 다중사용자를 위한 서버에는 적용하기 위험.


- 리소스 반환과 close()
    * 단순히 생각하면 종료의 의미지만 보통 리소스를 반환한다고 생각하면 좋다.
    * 위의 Connection과 PreparedStatement는 보통 풀(pool)방식으로 운영된다. 
    * 미리 정해진 풀 안에 제한된 수의 리소스를 만들어두고 필요할때 이를 할당하고, 반환하면 다시 풀에 넣는 방식.

    * 요청이 많은 서버환경에서는 매번 새로운 리소스 생성대신 풀에 만들어둔 리소스를 돌려쓰는게 편리하고 유리함.
    * BUT 사용한 리소스는 빠르게 반환해야됨. -> 풀에있는 리소스가 고갈될 수 있기 때문.

    * 만약 리소스가 고갈되면 : 
        * 요청 대기 상태나 오류발생.
        * 오류 및 장애 발생
        * 응답성 저하 및 애플리케이션 불안정

    * 방지 및 대응 방법
        * Pool 크기 조정 및 모니터링
        * Connection Leak Detection
        * 대기 전략 설정
            * Pool 고갈시 동장을 정해서 예측 가능한 상황에 맞게 처리.


- 그래서 JDBC 코드에서는 리소스 반환하도록 try/catch 구문을 쓴다.
￼
    * finally는 try 블록을 수행한 후 예외가 발생하든 정상처리가 되든 반드시 실행되는 코드를 넣는다.
    * Connection이나 PreparedStatement의 close() 호출로 리소스 반환을 무조건 해야되는데, 문제는 예외가 어느 시점에 나는지에 따라 어떤 것의 close()메소드를 호출해야될지 달라진다는 것이다.

    * 만약 DB서버 문제나, 네트워크 문제처럼 예외상황이 발생하면 ps도 c도 null상태일 것이다. 여기에 close() 메소드를 호출하면 NullPointerException이 발생할 것이니 호출하면 안된다.

    * 그래서 finally에서는 반드시 c, ps가 null이 아닌지 확인후 close()메소드를 호출해야 함.


- JDBC 조회기능의 예외처리에는 ResultSet 추가된다.
    * ResultSet도 반환해야하는 리소스로 예외상황에서도 close()메소드가 반드시 호출되도록 만든다.
￼
    * 모든 메소드에 동일 방식인 try/catch/finally 블록을 적용했다. 테스트 수행후 이상없는지 확인하면 된다.



- JDBC try / catch / finally의 문제점
    * 복잡한 블록들이 2중으로 중첩되고, 모든 메소드마다 반복됨.
    * 이런 코드에서 효과적인 방법은 복사해서 붙이기, 일명 Copy&Paste임.
    * 메스다마다 달라지는 try 블록 코드만 수정. -> close같은 메소드만 빼먹어도 언젠가 DB 풀의 커넥션 개수를 넘고 서버에 리소스가 꽉찼다는 에러가 나올 것 임.


- 문제의 핵심은 변하지 않는, 그러나 많은 곳에서 중복되는 코드와 로직에 따라 확장되고 자주 변하는 코드를 분리.
￼

- 메소드 추출 : 변하지 않는 메소드를 뺀다.
￼

- 템플릿 메소드 패턴의 적용
    * 상속을 통해 기능을 확장해서 사용하는 부분. 변하지 않는 부분은 슈퍼 클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브 클래스에서 오버라이드하여 새롭게 정의해 쓰도록 하는 것.
￼
    * 이제 위의 그림처럼 UserDao 클래스 기능을 확장하고 싶을 떄마다 상속을 통해 자유롭게 확장할 수 있고, 상위 DAO 클래스에 불필요한 변화는 생기지 않도록 할 수 있으니 개방 패쇄 원칙을 나름 잘 지키는 구조를 만들 수 있다.

    * 하지만 템플릿 메소드 패턴으로의 접근은 제한이 많다. 가장 큰 문제 -> DAO로직마다 상속을통해 새로운 클래스 생성.
￼
    * 단점. 유연성이 떨어져버림.


- 전략 패턴의 이용
    * 오브젝트를 아예 둘로 분리하고 클래스 레벨에서는 인터페이스를 통해서만 의존하도록 만드는 전략 패턴.
    * OCP 관점에 보면 확장에 해당하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 위임하는 방식.
￼
    * deleteAll() 메소드에서 변하지 않는 부분이라고 명시한 것이 바로 contextMethod()가 된다.
    * deleteAll()은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락을 갖는다.
    * 아래 사진은 deleteAll()의 컨텍스트를 정리한 것이다.
￼
    * 두 번째 작업에서 사용하는 PreparedStatement를 만들어주는 외부 기능이 바로 전략 패턴에서 말하는 전략이다.
    * 전략 패턴 구조를 따라 이 기능을 인터페이스로 만들어두고 인터페이스 메소드로 만들어두고 메소드를 통해 PreparedStatement 생성 전략을 호출해주면 된다. 여기서 중요한 점은 호출할 때 컨텍스트 내에서 만들어둔 DB 커넥션을 전달해야 한다는 점이다. 커넥션이 없으면 PReparedStatement도 만들 수 없을테니깐….(아래 그림) 
￼


* 위의 인터페이스를 상속해서 실제 전략, 즉 바뀌는 부분인 PreparedStatement를 생성하는 클래스. deleteAll() 메소드의 기능을 위해 만든 전략 클래스는 아래 그림과 같다.
￼


* 이제 확장된 PReparedStrategy 전략인 DeleteAllStatement가 만들어 졌다. 이것을 contextMethod()에 해당하는 UserDao의 deleteAll()메소드에서 사용하면 전략패턴을 사용했다고 볼 수 있다.
￼

    * 하지만 전략 패턴은 컨텍스트는 유지되면서 전략을 바꿔쓸 수 있는데, 이미 구체적인 전략 클래스인 DeleteAllStatement를 사용하도록 고정되어 있다면 뭔가 이상하다. 
    * 컨텍스트가 StatementStrategy 인터페이스 뿐만 아니라 특정 구현 클래스인 DeleteAllStatement를 직접 알고 있는건 OCP에 잘 들어맞는다고 볼 수 없기 때문.


- DI 적용을 위한 클라이언트 / 컨텍스트 분리
    * 전략 패턴은 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는게 일반적이다. Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context로 전달하는 것이다. 
    * Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용한다.(아래 그림)
￼

* 결국 이 구조에서 전략 오브젝트 생성과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 바로 ObjectFactory이며, 이를 일반화 한것이 의존 관계 주입(DI)었다. 
* -> DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조.


- 마이크로 DI
    * DI의 중요 개념은 제 3 자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정.
    * DI가 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 한다.



- JDBC 전략 패턴의 최적화
￼
    * deleteAll()과 add()두군데서 메소드를 사용하는데. AddStatement에서 User 타입의 오브젝트를 받을 수 있도록 한다.
￼
￼
    * 미리 준비해둔 테스트가 있기에 DAO코드를 자유롭게 개선할 수 있는 것이다.

- 전략과 클라이언트의 동거
    * 지금까지 문제점 해결을 했지만 개선할 부분이 있다.
    * DAO 메소드마다 새로운 StatementStrategy 구현 클래스를 만들어야된다.-> 클래스 파일 갯수 늘어남
    * User와 같은 부가정보가 생기면 인스턴스 변수를 번거롭게 만들어야된다.

- 로컬 클래스
    * 위의 두가지 문제를 해결!
    * StatementStrategy 전략클래스를 UserDao 클래스 안에 내부 클래스로 정의.
￼
    * 로컬 변수 선언하듯이 하면 된다.
    * 그리고 로컬 클래스는 클래스가 내부클래스라서 자신이 선언된 곳의 정보에 접근할 수 있다는 장점.
    * 다만, 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 final로 선언해야함.


- 익명 내부 클래스
    * ￼
    * 익명 내부 클래스는 선언과 동시에 오브젝트 생성.
    * 이름이 없어서 클래스 자신의 타입을 가질 수 없고, 구현한 인터페이스 타입의 변수에만 저장할 수 있음.
￼
￼
￼



- JdbcContext의 분리
    * 분리한 클래스 이름을 JdbcContext라 하자.
￼

- 빈 의존관계 변경
    * 독립적인 JDBC 컨텍스트를 제공해주는 서비스 오브젝트로서 의미가 있을 뿐이고 구현 방법이 바뀔 가능성은 없다. 따라서 인터페이스를 구현하도록 만들지 않았고, UserDao와 JdbcContext는 인터페이스를 사이에 두지 않고 DI를 적용하는 특별한 구조가된다.
￼
￼


- 스프링 빈으로 DI
    * JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문. 
    * JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 떄문.(중요)
        * 인터페이스 사용 여부, 왜 안쓸까?
            * UserDao와 JdbcContext가 매우 긴밀한 관계를 가지고 결합되어있다는 뜻.
            * 마지막에 고려해야할 사항임.


- 코드를 이용하는 수동 DI
    * UserDao 내부에서 직접 DI를 적용하는 방법
        * 싱글톤으로 만드는것은 포기해야함.
        * DAO마다 하나의 JdbcContext 오브젝트를 갖고 있게 하는 것.

    * 스프링 빈으로 JdbcContext를 등록해서 사용했던 것.
