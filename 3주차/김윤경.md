## 템플릿
- 반복되는 코드나 공통적인 흐름을 미리 만들어 두고, 사용자가 필요한 부분만 바꿔서 쓰는 구조
----

## 예외처리
<예외처리>
- DB커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC코드에서는 정상적인 JDBC 코도의 흐름을 따르지 않고, 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야하기 때문에, 예외처리가 필요하다.

-> 데어터 베이스 연결-이런 자원들은 사용이 끝나면 꼭 반환해야한다. 안그러면 다른 곳에서 못 쓰게 되고 결국 시스템이 느려자거나 멈출 수 있기 때문. 예외처리는 에러가 나더라도 리소스를 안전하게 반환하고 프로그램이 안정적으로 돌아가게 한다)

<img width="794" height="351" alt="image" src="https://github.com/user-attachments/assets/40b39e3a-861d-4d8d-895f-4cc57ce2500d" />

-> close()를 사용하는 것처럼!

<img width="883" height="722" alt="{3D4E0A17-E5D4-404C-9F55-9E5A11AE4D86}" src="https://github.com/user-attachments/assets/62d60a6b-1539-4450-9898-d2400acc1163" />

-> JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용이 권장된다.


<분리와 재사용을 위한 디자인 패턴 적용> 
- UserDao의 메소드를 개선하는 작업
 - 성격이 다른 것 찾아내기
  1. 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정되는 부분
  2. 각 메소드마다 로직에 따라 변하는 부분
 
<템플릿 메소드 패턴의 적용>
  - 상위클래스 (부모)가 전체 알고리즘의 골격(흐름)을 정의하고 하위클래스(자식)가 세부 단계의 구현만 바꾸는 디자인 패턴
  - 상속을 통해 기능을 확장해서 사용
  - 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드해서 새롭게 정의해 쓰도록 함
  - 장점
      - 코드 재사용성 햘상 : 공통 로직(흐름)은 부모 클래스에 작성하고, 자식 클래스는 다른 부분만 구현하면 됨 -> 중복 코드 줄어듦
      - 유지보수 용이 : 알고리즘의 큰 틀을 한 곳(부모 클래스)에서 관리하기 때문에, 흐름을 수정해도 하위 클래스 전부에 자동 반영됨
      - 일관된 처리 흐름 유지 : 모든 자식 클래스가 동일한 프로세스 구조를 따르기 때문에, 시스템 동작이 일관됨
      - 변경에 유연함 : 세부 동작(훅 메서드, abstract 메서드)만 바꾸면 다른 형태의 알고리즘을 쉽게 적용할 수 있음
      - 라이브러리 설계에 적합 : 프레임워크(Swing, Spring 등)는 기본 템플릿을 제공하고, 사용자가 필요한 부분만 오버라이드해서 사용 가능
   
  - 단점
      - 클래스 간 결합도 증가 (상속 의존) : 템플릿 메서드 패턴은 상속(inheritance) 을 기반으로 하기 때문에, 상위 클래스의 변경이 하위 클래스에 바로 영향을 줌.
      - 유연성이 떨어질 수 있음 : 이미!! 클래스를 설계하는 시점에서 확장구조가 고정되어 버림

<전략 패턴의 적용>
- 전략 패턴은 템플릿 메소드 패의 대안이 될 수 있음. 왜??
  - 전략 패턴은 상속 대신 구성(composition) 을 사용
  - 알고리즘의 구체적인 전략(동작)을 별도의 클래스로 분리하고, 필요할 때 객체 내부에 주입(inject)해서 런타임에 자유롭게 변경할 수 있음 -> 동적으로 알고리즘을 바꿀 수 있는 구조라서 유연성이 훨씬 높다.

<img width="734" height="267" alt="image" src="https://github.com/user-attachments/assets/b4550f01-7156-4ddd-ae47-d3a344b3424b" />

<DI 적용을 위한 클라이언트/컨텍스트 분리>
- Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 client가 결정하는게 일반적임
- Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달 -> Context는 전달받은 그 strategy 구현 클래스의 오브젝트를 사용함.

- 컨텍스트에 해당하는 부분을 변도의 메소드로 독립
  - 클라이언트는 전략 클래스의 오브젝트를 컨텍스트의 메소드를 호출하며 전달해야 한다
     = 컨텍스트사 어떤 전략(로직)을 쓸지 모르는 상태에서, 실행할 때 외부에서 전략 객체를 넘겨주는 것.
    -> 전략패턴은 1. 컨텍스트 2. 전략 인터페이스 3. 구체 전략 클래스 총 3가지 구성요소로 이루어져 있음.


- 전략 인터페이스 
 ```
interface Engine {
    void start();
}
```


- 구체 전략들
```
class GasEngine implements Engine {
    public void start() {
        System.out.println("가솔린 엔진 시동!");
    }
}

class ElectricEngine implements Engine {
    public void start() {
        System.out.println("전기 엔진 시동!");
    }
}
```

- 컨텍스트
```
class Car {
    public void run(Engine engine) {   //  전략을 “메서드 인자로 전달받음”
        engine.start();
    }
}
```

- 실행
```
public class Main {
    public static void main(String[] args) {
        Car car = new Car();

        car.run(new GasEngine());       // 가솔린 전략 사용
        car.run(new ElectricEngine());  // 전기 전략으로 교체
    }
}
```



컨텍스트(Car)가 어떤 전략(Engine)을 쓸지 모르기 때문에, 실행할 때 외부에서 주입해야 한다- 라는 뜻.

<마이크로 DI>
- DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우. 코드에 의한 DI라는 의미로 수동 DI라고 부를 수도 있다.

- 불만)
  - 1. DAO 메소드 마다 새로운 StatementStrategy 구현 클래스를 만들어야함. -> 클래스가 많아짐
  - 2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해 둘 인스턴스 변수를 만들어야함
- 해결방법) ?

<로컬 클래스>
- 로컬클래스의 장점
  - 캡슐화(Encapsulation) 강화 : 로컬 클래스는 선언된 메서드 내부에서만 접근 가능. 따라서 외부에서 쓸 일이 없는 클래스를 감추어 코드의 가독성과 보안성을 높일 수 있음.
  - 메서드 내의 변수나 상태에 쉽게 접근 가능 : 로컬 클래스는 자신이 선언된 메서드의 final 또는 effectively final 변수를 사용할 수 있음. 즉, 메서드 내부의 값을 간단히 가져다 쓸 수 있어, 메서드 관련 로직을 묶기에 좋음.
  - 코드 구조 단순화 : 굳이 파일 밖에 클래스를 새로 만들지 않아도 되니까, 짧고 한정적인 역할을 하는 클래스를 만들 때 편리함.
  - 익명 클래스보다 조금 더 명확한 구조 : 이름이 있는 클래스라 디버깅이나 재사용(같은 메서드 안에서)은 익명 클래스보다 쉬움.
 
<익명 내부 클래스>
 - 익명 내부 클래스는 이름을 갖지 않는 클래스. 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며, 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용한다. 클래스를 재사용할 필요가 없고, 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.


## 3.4 컨텍스트와 DI

- 1. 컨텍스트(Context)
   -스프링 컨테이너라고도 부르는 ApplicationContext는 객체(빈, Bean)의 생성, 초기화, 관리, 소멸을 담당. 즉, 객체를 직접 new로 만드는 대신, 컨텍스트가 대신 생성하고 주입해주는 환경. -> 개발자는 객체 간의 의존 관계를 직접 관리하지 않아도 됩니다.

- 2. DI (Dependency Injection, 의존성 주입)
  - 객체가 필요로 하는 다른 객체(의존성)를 직접 생성하지 않고 외부에서 주입받는 방식. 이로 인해 결합도가 낮아지고, 테스트나 유지보수가 쉬워집니다.

- 3. 클래스 분리
  - **단일 책임 원칙(SRP)**에 따라, 각 클래스는 하나의 역할만 담당
    
- 4. 빈(Bean) 의존 관계 변경
  - 스프링에서는 설정 파일(@Configuration 클래스나 applicationContext.xml)을 통해 의존 관계를 변경할 수 있음. 코드를 수정하지 않고도, 설정만 바꾸면 다른 구현체로 교체 가능하죠.
 
<인터페이스를 사용해서 클래스를 자유롭게 변경할 수 있게 하지는 않았지만,  JdbcContext를 UserDao와 DI구조로 만들어야할 이유?>
 - 1. JdbcContext가 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 되기 때문
 - 2. JdbcContext가 DI를 통해 다른 빈에 의존하고 있기 때문
  
<코드를 이용하는 수동 DI>
- 수동 DI (Manual Dependency Injection)”는 스프링 같은 프레임워크의 자동 주입 없이, 개발자가 직접 객체를 생성하고 주입하는 방식 -> 스프링이 대신 해주는 걸 직접 코드로 하는 것
  - 코드 레벨에서 객체 생성과 주입 구조를 명확히 볼 수 있다.
  - 스프링 같은 컨테이너를 몰라도 DI 개념 자체를 이해하는 데 매우 도움이 된다.
  - 테스트 환경에서 원하는 구현체로 쉽게 교체 가능하다.
  - but! JdbcContext를 여러 오브젝트가 사용하더라도 싱글톤으로 만들 수 없고, DI작업을 위한 부가적인 코드가 필요하다는 단점이 있음.
 
 ## 3.5 템플릿과 콜백
 - 템플릿 : **변하지 않는 전체 구조나 흐름(공통 코드)**을 정의하는 부분. 즉, “이건 항상 이렇게 돌아간다”라는 고정된 틀을 잡는 역할. 예를 들어, try/catch, 자원 닫기, 예외 처리 같은 반복되는 부분을 템플릿이 담당.

 - 콜백 : **변하는 부분(구체적인 동작)**을 외부에서 주입받아 실행하는 함수나 객체. 즉, “상황에 따라 다르게 해야 하는 코드”를 템플릿이 대신 호출해주는 구조.
-  -> 얘네 왜 쓰는데? -> 복되는 코드(템플릿)는 재사용하고, 바뀌는 부분(콜백)은 자유롭게 바꾸기 위해.

 - <동작원리>
  - : 템플릿이 “전체 흐름”을 잡고, 콜백이 “특정 시점에 실행될 구체적인 동작”을 전달받아 실행한다.
   - 1. 개발자가 템플릿에게 콜백을 전달 -> “이때 이 동작을 해줘!” 라고 요청
   - 2. 템플릿이 내부에서 정해진 순서로 흐름을 실행
       - 공통 로직 수행 (자원 연결, 예외 처리 등)
       - 필요한 시점에 콜백 호출 (callback.doSomething())
       - 자원 정리, 종료 등 마무리 처리
   - 3. 결과를 반환하거나 로그를 남김

- <콜백의 재활용>
  - 한 번 정의된 콜백은 다양한 템플릿 실행에 재활용 가능
    - 공통 로직을 한 번만 정의
    - 여러 템플릿 실행에 재사용 가능
    - 테스트, 유지보수, 확장 용이
   
- <콜백의 분리와 재활용>
  - 콜백은 템플릿 안에 감춰두지 말고, 외부 클래스로 분리
    - 템플릿은 **흐름 제어(공통 구조)**만 담당
    - 콜백은 구체적 실행 로직만 담당
    - -> 템플릿과 콜백의 결합도가 낮아지고, 재사용성↑, 확장성↑
      
- <콜백과 템플릿의 결합>
  - 템플릿이 실행 흐름 중 특정 시점에서 콜백을 “호출(callback)”한다
    - 사용자 → 템플릿 실행 요청→ 템플릿 내부에서 콜백 호출 → 콜백이 특정 동작 수행 → 템플릿이 흐름 마무리
   
- <템플릿/콜백의 응용>
  - 템플릿은 “흐름”을 고정하고, 콜백만 교체해서 다양한 작업 수행 가능.

- <중복의 제거와 템플릿/콜백 설계>
  - try/catch, 자원 정리, 반복 흐름이 매번 중복되는게 문제.
     - 템플릿이 그 중복된 흐름을 하나의 공통 구조로 캡슐화.
     - 콜백이 “변하는 부분”만 담당.
     - -> 코드 중복 제거
     - -> 유지보수 시 한 곳만 수정하면 전체 흐름 변경 가능
  - 좋은 콜백의 설계
     - 작고 명확한 역할 — 한 가지 일만 한다.
     - 상태에 의존하지 않는다 — 외부 상태에 덜 의존해야 재사용 가능.
     - 템플릿과 느슨하게 결합된다 — 템플릿 내부 구조에 종속되지 않는다.
     - 인터페이스 기반 설계 — 인터페이스로 정의해 다양한 구현체 가능.
      
- <템플릿/콜백의 재설계>
- <img width="802" height="437" alt="image" src="https://github.com/user-attachments/assets/d4d814d9-826a-4c10-83bf-182fe0e62070" />

## 스프링의 JdbcTemplate

- <update()>
  - 데이터 변경(INSERT, UPDATE, DELETE) SQL 실행용 메서드
  - 동작원리
    - 템플릿이 Connection, PreparedStatement 생성 -> SQL 실행 (콜백 내부에서) -> 영향을 받은 행(row) 개수 반환
- <queryForInt()>
  - 과거 메서드, 지금은 queryForObject로 대체됨)
  - 단일 정수값(카운트 등)을 반환할 때 사용
  - 동작원리
     - 템플릿이 SQL 실행 -> 결과셋의 첫 번째 컬럼 값을 정수형으로 반환 -> 내부적으로 ResultSetExtractor 콜백 사용
- <queryForObject()>
   - 단일 객체 한 개 반환 (1 row, 1 object)
   - 동작원리
      - 템플릿이 SQL 실행 -> 결과셋의 첫 번째 컬럼 값을 정수형으로 반환 -> 내부적으로 ResultSetExtractor 콜백 사용
      - 결과가 0개면 EmptyResultDataAccessException 발생,
      - 2개 이상이면 IncorrectResultSizeDataAccessException 발생
- <query()>
  - 여러 행을 조회할 때 사용
  - 동작원리
     - 템플릿이 SQL 실행 -> 결과셋을 한 줄씩 RowMapper 콜백에 전달 -> 매핑된 객체들을 리스트로 반환






 
    
 
    







