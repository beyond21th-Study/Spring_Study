## 템플릿
- 반복되는 코드나 공통적인 흐름을 미리 만들어 두고, 사용자가 필요한 부분만 바꿔서 쓰는 구조
----

## 예외처리
<예외처리>
- DB커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC코드에서는 정상적인 JDBC 코도의 흐름을 따르지 않고, 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야하기 때문에, 예외처리가 필요하다.

-> 데어터 베이스 연결-이런 자원들은 사용이 끝나면 꼭 반환해야한다. 안그러면 다른 곳에서 못 쓰게 되고 결국 시스템이 느려자거나 멈출 수 있기 때문. 예외처리는 에러가 나더라도 리소스를 안전하게 반환하고 프로그램이 안정적으로 돌아가게 한다)

<img width="794" height="351" alt="image" src="https://github.com/user-attachments/assets/40b39e3a-861d-4d8d-895f-4cc57ce2500d" />

-> close()를 사용하는 것처럼!

<img width="883" height="722" alt="{3D4E0A17-E5D4-404C-9F55-9E5A11AE4D86}" src="https://github.com/user-attachments/assets/62d60a6b-1539-4450-9898-d2400acc1163" />

-> JDBC 코드에서는 어떤 상황에서도 가져온 리소스를 반환하도록 try/catch/finally 구문 사용이 권장된다.


<분리와 재사용을 위한 디자인 패턴 적용> 
- UserDao의 메소드를 개선하는 작업
 - 성격이 다른 것 찾아내기
  1. 비슷한 기능의 메소드에서 동일하게 나타날 수 있는 변하지 않고 고정되는 부분
  2. 각 메소드마다 로직에 따라 변하는 부분
 
<템플릿 메소드 패턴의 적용>
  - 상위클래스 (부모)가 전체 알고리즘의 골격(흐름)을 정의하고 하위클래스(자식)가 세부 단계의 구현만 바꾸는 디자인 패턴
  - 상속을 통해 기능을 확장해서 사용
  - 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드해서 새롭게 정의해 쓰도록 함
  - 장점
      - 코드 재사용성 햘상 : 공통 로직(흐름)은 부모 클래스에 작성하고, 자식 클래스는 다른 부분만 구현하면 됨 -> 중복 코드 줄어듦
      - 유지보수 용이 : 알고리즘의 큰 틀을 한 곳(부모 클래스)에서 관리하기 때문에, 흐름을 수정해도 하위 클래스 전부에 자동 반영됨
      - 일관된 처리 흐름 유지 : 모든 자식 클래스가 동일한 프로세스 구조를 따르기 때문에, 시스템 동작이 일관됨
      - 변경에 유연함 : 세부 동작(훅 메서드, abstract 메서드)만 바꾸면 다른 형태의 알고리즘을 쉽게 적용할 수 있음
      - 라이브러리 설계에 적합 : 프레임워크(Swing, Spring 등)는 기본 템플릿을 제공하고, 사용자가 필요한 부분만 오버라이드해서 사용 가능
   
  - 단점
      - 클래스 간 결합도 증가 (상속 의존) : 템플릿 메서드 패턴은 상속(inheritance) 을 기반으로 하기 때문에, 상위 클래스의 변경이 하위 클래스에 바로 영향을 줌.
      - 유연성이 떨어질 수 있음 : 이미!! 클래스를 설계하는 시점에서 확장구조가 고정되어 버림

<전략 패턴의 적용>
- 전략 패턴은 템플릿 메소드 패의 대안이 될 수 있음. 왜??
  - 전략 패턴은 상속 대신 구성(composition) 을 사용
  - 알고리즘의 구체적인 전략(동작)을 별도의 클래스로 분리하고, 필요할 때 객체 내부에 주입(inject)해서 런타임에 자유롭게 변경할 수 있음 -> 동적으로 알고리즘을 바꿀 수 있는 구조라서 유연성이 훨씬 높다.

<img width="734" height="267" alt="image" src="https://github.com/user-attachments/assets/b4550f01-7156-4ddd-ae47-d3a344b3424b" />

<DI 적용을 위한 클라이언트/컨텍스트 분리>
- Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 client가 결정하는게 일반적임
- Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달 -> Context는 전달받은 그 strategy 구현 클래스의 오브젝트를 사용함.

- 컨텍스트에 해당하는 부분을 변도의 메소드로 독립
  - 클라이언트는 전략 클래스의 오브젝트를 컨텍스트의 메소드를 호출하며 전달해야 한다
     = 컨텍스트사 어떤 전략(로직)을 쓸지 모르는 상태에서, 실행할 때 외부에서 전략 객체를 넘겨주는 것.
    -> 전략패턴은 1. 컨텍스트 2. 전략 인터페이스 3. 구체 전략 클래스 총 3가지 구성요소로 이루어져 있음.


- 전략 인터페이스 
 ```
interface Engine {
    void start();
}
```


- 구체 전략들
```
class GasEngine implements Engine {
    public void start() {
        System.out.println("가솔린 엔진 시동!");
    }
}

class ElectricEngine implements Engine {
    public void start() {
        System.out.println("전기 엔진 시동!");
    }
}
```

- 컨텍스트
```
class Car {
    public void run(Engine engine) {   //  전략을 “메서드 인자로 전달받음”
        engine.start();
    }
}
```

- 실행
```
public class Main {
    public static void main(String[] args) {
        Car car = new Car();

        car.run(new GasEngine());       // 가솔린 전략 사용
        car.run(new ElectricEngine());  // 전기 전략으로 교체
    }
}
```



컨텍스트(Car)가 어떤 전략(Engine)을 쓸지 모르기 때문에, 실행할 때 외부에서 주입해야 한다- 라는 뜻.

<마이크로 DI>
- DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우. 코드에 의한 DI라는 의미로 수동 DI라고 부를 수도 있다.

- 불만)
  - 1. DAO 메소드 마다 새로운 StatementStrategy 구현 클래스를 만들어야함. -> 클래스가 많아짐
  - 2. DAO 메소드에서 StatementStrategy에 전달할 User와 같은 부가적인 정보가 있는 경우, 이를 위해 오브젝트를 전달받는 생성자와 이를 저장해 둘 인스턴스 변수를 만들어야함
- 해결방법) ?

<로컬 클래스>












