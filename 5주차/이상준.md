[ Spring Study - week5 ]

- 예외 처리

￼
    * JdbcTemplate 적용 이전에는 있었던 throws SQLException 선언이 적용 후에는 사라졌다.


- 초난감 예외처리
    * 일단 왜 사라졌는지 보기전에 초난감 예외처리의 대표주자들을 알아보자.

- 예외 블랙홀
￼
    * 자바를 배우는 단계에서 흔히 볼 수 있는 코드다.
    * Try/catch 블록을 사용해서 고친 모습이다.
    * BUT 아무것도 하지않고 넘어가면 정말 위험한 일이다. Why? -> 프로그램 실행 중에 어디선가 오류가 있어서 발생한 예외로 인해 예상치 못한 다른 문제를 일으킬 것이다. And 시스템 오류나 이상한 결과의 원인도 찾기 힘듦.

    * 아래 그림도 마찬가지다.
￼


    * 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 한 가지다.
        * 모든 예외는 적절하게 복구되던지 or 작업을 중단하고 운영자, 개발자에게 통보되어야한다.
    * SQLException은 SQL문법 에러가 있거나 DB에서 처리할 수 없을 정도로 데이터 액세스 로직에 심각한 버그 O, 서버가 죽거나 네트워크가 끊기는 등 심각한 상황이 벌어졌기 때문.





- 무의미하고 무책임한 throws
    *  아래 그림처럼 메소드에 throws Exception가 만사는 아니다.
￼
    * 모든 예외를 무조건 던져버리는 선언을 기계적으로 습관적으로 넣는건 좋지X.
    * 이런 메소드에서는 의미 있는 정보 얻을 수 X
    *  적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당하는 상황이 나온다.\



- 예외의 종류와 특징
    * 체크 예외 : 체크 예외는 Java 컴파일러가 컴파일 타임에 명시적으로 검사하는 예외입니다. 메서드에서 체크 예외를 발생시킬 가능성이 있다면, 해당 메서드를 호출하는 코드는 반드시 예외를 처리하거나 다시 던져야 합니다. 만약 이러한 처리 없이 코드를 작성하면 컴파일 오류가 발생하게 됩니다.  체크 예외의 가장 핵심적인 특징은 Exception 클래스를 직접 상속하면서. RuntimeException을 상속하지 않는다는 점입니다. 이러한 구조적 특징 때문에 컴파일러는 이러한 예외들을 구별하여 강제. 처리를 요구합니다.

    * 언체크 예외와 체크의 근본적 차이  : 예외 처리가 강제되는 시점입니다. 체크 예외는 컴파일 타임에 처리를 강제하여 개발자가 명시적으로 예외 상황을 인식하고 대비하도록 유도합니다. 반면 언체크 예외(RuntimeException)는 런타임에만 발생하므로 컴파일러의 검사 대상이 아니며, 개발자가 선택적으로 처리할 수 있습니다

    * Error 
        * java.lang.Error 클래스의 서브클래스. -> 시스템에 뭔가 비정상적인 상황이 발생했을 경우 사용.
        * 그래서 자바 VM에서 발생시키고 애플리케이션에서 잡으려하면 안된다.
        * OutOfMempryError나 ThreadDeath같은 에러는 catch로도 안잡힘. -> 애플리케이션에서는 신경 X.

    * Exception과 체크 예외
        * Java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 엘러와 달리 코드 작업 중 예외상황이 발생했을 경우 사용함.
        * Exception 클래스는 다시 체크 예외와 언체크 예외로 구분된다.
        * 체크 예외 -> RuntimeException 상속하지 않음. 
        * 언체크 예외 -> RuntimeException을 상속함.
￼




- RuntimeException과 언체크/런타임 예외
    * java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않아서 언체크 예외라고 함. 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것.
        * NullPointException이나 허용되지 않는 값을 사용해서 발생하는 IllegalArgumentException 등…

    * 이건 코드에서 미리 조건을 체크하도록 주의 깊게 만들면 피할 수 있음. 그래서 예상하지 못했던 예외상황에서 발생하지 않기 때문에 굳이 catch나 throws를 사용하지 않아도 된다.




- 예외처리 방법 : 일반적인 방법 알려드림ㅋ

- 1. 예외 복구
    * 예를 들어 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없다거나 다른 문제가 있어 IOException이 발생했다하자. 그럼 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내해서 예외상황 해결 가능.

    * 하지만 IOException 에러 메세지가 사용자에게 그냥 던져지는 것은 예외 복구가 아니다. -> 예외 처리됐으면 기능적으로는 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정ㅇ상적으로 설계된 흐름을 따라 진행되야한다.

    * 이렇게 예외처리 코드를 강제하는 체크 예외들은 어떤 식으로든 복구할 가능성이 있는 경우에 사용한다.



￼
    * 위의 그림처럼 최대 횟수만큼 반복적으로 시도함으로써 예외사황에서 복구할 수 있다.



- 2. 예외처리 회피
    * 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것이다. 예외처리를 회피하려면 반드시 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 아래 그림처럼 던져줘야한다.
￼



    * JdbcContext나 JdbcTemplate이 사용하는 콜백 오브젝트는 메소드 선언을 보면 알겠지만 ResultSet이나 PreparedStatement 등을 이용해서 작업하다 발생하는 SQLException을 자신이 처리하지 않고 템플릿으로 던진다. SQLException을 처리하는 일은 콜백 오브젝트의 역할이 아니라고 보기 때문. -> 예외를 회피하고 템플릿 레벨에서 처리하도록 던져준다.

    * 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다. 콜백/템플릿처럼 긴밀한 관게에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는게 최선의 방법이라는 분명한 확신이 있어야함.



- 예외 전환(Exception transiation)
    * 예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것이다.
    * BUT 예외 회피와 달리, 발생한 예외를 그대로 넘기는게 아니라 적절한 예외로 전환해서 던지는 특징이 있음.

    * 첫 번째로 내부에서 발생환 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우에, 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서다. API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다.


    * 예를 들어, 새로운 사용자를 등록하려고 시도했을 때 아이디가 사용자가 있어서 DB 에러가 발생하면 JDBC API는 SQLException을 발생시킨다. 이 경우 던져버리면 DAO를 이용해 사용자를 추가하려고 한 서비스 계층 등에서는 왜 SQLException이 발생했는지 쉽게 알 방법이 없다.

    * 로그인 아이디 중복은 예상 가능한 복구 가능한 예외상황이다. SQLException의 정보를 해석해서 DuplicateUserIdException 같은 예외로 바꿔서 던지면 된다. 이처럼 DAO 메소드에서 기술에 독립적이며 의미가 분명한 예외로 전환해서 던져 줄 필요가 있다.




    * 아래 그림은 사용자 정보를 등록하려고 시도해보고, 만약 중복된 아이디 값 때문에 에러가 나는 경우에 이를 확인하고 의미있는 DulicateKeyException으로 전환해주는 DAO메소드의 예이다. 
￼



    * 보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외(nested exception)로 만드는 것이 좋다. 
    * 중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 알 수 있다.
    * 아래 그림들처럼 새로운 예외를 만들면서 생성자나 initCause()메소드로 근본 원인이되는 예외를 넣어주면된다.
￼
* 장점
    * 근본 원인 파악 : 최초 발생한 예외를 찾고 디버깅에 활용 가능.
    * 예외의 문맥 제공 : 예외 발생의 전체적인 문맥파악에 용이함.
    * 예외 묶기 : 다양한 종류의 예외들을 하나의 상위 예외로 묶어서 처리할 때 각기 다른 원인들을 getCause()를 통해 구분하고 각각에 맞는 후속처리 가능.




- 두 번째 예외 전환
    * 예외 처리하기 쉽고 단순하게 만들기 위해 포장하는 것.
    * 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다.
    * 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용함.

    * 대표적으로 EJBException
        * EBJ컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비즈니스 로직으로 볼 때 의미 있는 예외이거나 복구 가능한 예외가 아니다. 이런 경우 런타임 예외인 EJBException으로 포장해서 던지는 편이 낫다.
￼
    * 이렇게 런타임 예외로 만들어서 전달하면 이를 시스템 익셉션으로 인식하고 트랜잭션을 자동으로 롤백해준다.
    * 이런 예외는 잡아도 복구할만한 방법이 없기 때문에 예외를 잡거나 던질 수고를 덜 수 있다.


    * 반면에 애플리케이션 로직상에서 예외 조건이 발견되거나 예외상황이 발생할 수 있다. 이런것은 API가 던지는 예외가 아니라 애플리케이션 코드에서 의도적으로 던지는 예외이다.**************(말이 이해가 안된다.)
    * 이럴땐 체크 예외를 사용하는 것이 적절함. -> 비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응이나 복구 작업이 필요하기 때문.

    * 복구 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던져서 다른 계층의 메소드를 작성할때 불필요한 throws 선언이 들어가지 않도록 해야한다.
    * 대부분 서버환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일관적으로 다룰 수 있는 기능을 제공한다. 
    * 그래서 런타임 예외로 포장해서 던지고, 예외처리 서비스 등을 이용해 자세한 로그를 남기고, 관리자에게는 메일 등으로 통보, 사용자에게는 친절한 안내 메세지를 보여주는게 바람직하다.



- 예외처리 전략
    * 지금까지 살펴본 예외의 종류와 처리 방법 등을 기준으로 일관된 예외처리 전략을 정리해보자


- 런타임 예외의 보편화
    * 체크 예외가 일반적인 예외를 다루고, 언체크 예외는 시스템 장애나 프로그램상의 오류에 사용한다.
    * 여기서 문제? -> 체크 예외는 복구할 가능성이 조금이라도 있는 말. 예외적인 상황이기 때문에 catch블록이나 throws의 선언을 강제하고 있다는 점. 
    * 이렇게 예외처리를 강제하는 것은 예외가 발생할 가능성이 있는 API 메소드르르 사용하는 개발자를 위한 배려지만, 실제로는 예외를 제대로 다루고 싶지 않을 만큼 짜증나게 만드는 원인이 되기도한다.

    * 자바초기에는 통제 불가능한 예외도 직접 상황을 복구해야했다.
    * BUT 자바 엔터프라이즈 서버환경은 다르다.
    * 뭐가? -> 수 많은 사용자가 동시에 요청을 보내고 요청이 달라도 독립적인 작업으로 취급된다. 하나의 요청에 예외가 발생하면 해당 작업만 중단시키면 된다. 



    * 요즘 등장하는 오픈소스 프레임워크에서는 API가 발생시키는 예외를 체크 예외 대신 언체크 예외로 하는게 일반화되고있다.



- add() 메소드의 예외처리
￼
    * 위에 나온 add() 메소드는 DuplicatedUserIdException과 SQLException 두 가지의 체크 예외를 던지게 되어있다.
    * SQL은 대부분 복구 불가능한 예외라 잡아봤자 처리할 것이 없고,  DU예외는 복구 가능한 예외이므로 잡아서 대응할 수 있음.


    * DUE처럼 의미 있는 예외는 add()메소드 바로 호출한 오브젝트 대신 더 앞단의 오브젝트에서 다룰 수 있다.
* 왜 의미 있을까? 
* 복구 가능성, 기술 독립적인 추상화, 역할의 분리가 가능하기 때문
* —> 단순 에러가 아니라 비즈니스 로직에서 ‘다른 아이디 요칭’등 다음 행동을 취해야하는 중요한 사건이고, 상위 책임자에게 보고하기 위함이다.

    * 아래 그림이 설명한대로 예외 클래스를 만든 것이다.
    * 별도의 예외로 정의하기도 하지만, 필요 없다면 신경쓰지 않아도 되도록 RuntimeException을 상속한 런타임 예외로 만든다.
    * 중첩 예외를 만들 수 있도록 생성자를 추가해주는 것도 잊지 말아야한다.
￼




    * 이제 DUE를 냅두고 SQL예외는 언체크 예외가 되었다.
￼
    * 이제 add() 메소드를 사용하는 오브젝트는 불필요한 throws를 선언 할 필요가 없으며, 필요한 경우 중복 상황을 처리하기위해 DUE를 이용할 수 있다.
    * 이렇게 런타임 예외를 일반화해서 사용하면 장점이 많다 -> BUT 런타임 예외라서 주의 기울일 필요 있음.
        * 비즈니스 로직 집중과 코드의 간결화
        * 복구 불가능한 예외의 신속한 처리
        * 의존성 제거
    * 주의를 기울여야 하는 이유
        * 컴파일러가 예외 처리를 강제하지 않음(가장 큰 위험)
        * 문서화와 소통이 필수
        * 포괄적인 예외 처리의 위험



- 애플리케이션 예외
    * 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외를 말함.

- 이런 기능을 담은 메소드를 설계하는 2가지 방법
    * 1. 각각 다른 종류의 리턴 값을 돌려준다. Ex) 정상적인 출금처리를 했을 경우와 잔고 부족이 발생했을 경우 리턴값을 일종의 결과 상태를 나타내는 정보로 활용.  둘다 리턴 값이 있기 때문에 기술적으로보면 모두 정상 흐름이다.
    * BUT 리턴 값으로 결과를 확인하고, 예외상황을 체크하면 불편한 점이 있음.
        * 일관된 예외상황에서의 결과 값에 대한 정책이 완벽하게 갖춰져있고, 사전에 상수로 정의해둔 표준 코드를 사용하지 않는다면 -> 개발자들 사이에 의사소통문제로 오류날 수 있음.
        * 그리고 결과 값 확인하는 if문이 자주 등장함.

    * 2. 정상적인 흐름을 따르는 코드는 그대로 두고, 잔고 부족과 같은 예외상황에서 비즈니스적인 의미를 띤 예외를 던지는것.
        * Ex) 잔고 부족인 경우 INsufficientBalanceException을 던짐. 예외상황을 처리하는 catch 블록을 메소드 호출 직후에 둘 필요는 없다. 
        * 정상 흐름을 따라가지만 예외가 발생할 수 있는 코드를 try 블록에 예외상황 처리는 catch 블록에 모아둬서 코드 이해도 쉽고 if문 남발 안해도된다.

        * 이때 사용하는 예외는 의도적으로 체크 예외로 만든다. 그래야 잊지 않고 잔고 부족처럼 자주 발생 가능한 예외상황에 대한 로직을 구현하도록 강제할 수 있기 때문. 그리고 런타임 예외보다 상대적으로 안전함.

    * 아래 그림은 2번째 방법을 사용한 것
￼
    * 두번째 방식을 선호
        * 정상적인 흐름과 예외 흐름의 분리(catch에 몰아 넣기 때문에 직관적)
        * 처리의 강제성(자바 컴파일러가 반드시 처리해야된다고 얼굴이 빨개짐 ㅠ)
    * 이것이  객체지향 언어인 자바가 예외를 사용하는 주된 목적 중 하나.




- SQLException은 어떻게 됐을까?
    * 일단 SQLException은 코드 레벨에서는 복구할 방법이 없다. EX) SQL문법이 틀, 제약조건 위반, DB서버 다운, 네트워크 불안정, DB 커넥션 풀이 꽉차는 상황 등등… 

    * 할 수 있는건 입력 단계에서 검증을 강화해서 개발자가 빨리 인식할 수 있도록 발생한 예외를 빨리 전달하는게 최선.
        * 따라서 예외처리 전략을 적용해야 하는것(throws선언을 방치하지 말고 간으한 빨리 언체크/런타임예외로 전환).

    * 스프링의 API 메소드에 정의도어 있는 대부분의 정의되어 있는 대부분의 예외는 런타임 예외이다. 따라서 발생 가능한 예외가 있다고 하더라도 이를 처리하도록 강제하지 않는다.


- 예외 전환
    * 스프링의 JdbcTemplate이 던지는 DataAccessException은 일단 런타임 예외로 SQLException을 포장해주는 역할을 한다. 그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서는 그렇게 신경을 안쓰도록 해준다. 또한 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는ㄴ 예외로 전환해서 추상화해주려는 용도로도 쓰인다.

- JDBC의 한계
    * JDK에서 가장 많이 사용되는 기능중 하나임. DB를 이용해 데이터를 저장하고, 필요한 정보를 조회하는 기능은 대부분 프로그램에서 필요하기 때문. DB마다 다른 API를 제공한다면 DB가 바뀔때마다 DAO코드도 바뀔 것이고 상상만해도 끔찍함ㅠ

    * JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고. 표준 드라이버를 제공해줌. -> 그래서 개발자들은 JDBC의 표준화된 API만 익숙해지면 일관된 방법으로 프로그램 개발 가능하다. 
    * BUT DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장은 X.
        * 그래서 두가지 걸림돌이 있음.

    * 1. 비표준 SQL
        * JDBC 코드에서 사용하는 SQL이다. 대용량 데이터를 처리하는 경우 성능을 향상시키기 위해 최적화된 기법을 SQL에 적용하거나, 웹 화면의 펭지 처리를 위해 가져오는 로우의 시작 위치와 개수를 지정, 쿼리에 조건을 포함시킨다거나 등등 대부분 비표준 SQL 문장이 만들어진다.
        * 비표준 SQL은 DAO코드에 들어가면 종속적인 코드가 되고마는 것이다.

        * 보통 DB가 자주 변경되지도 않고, 사용하는 DB에 최적화하는 것이 중요하므로 비표준 SQL을 사용하지만 DB 변경의 가능성을 고려해서 유연하게 만들어야한다면 큰 걸림돌이 될 것이다.


    * 2. 호환성 없는 SQLException의 DB 에러정보
        * DB에서 나는 에러는 SQL만 다른 것이 아니라 에러의 종류와 원인도 제 각각이라는 점이다.
        * 하지만 JDBC는 이런 예외들을 그냥 SQLException하나에 모두 담아버린다.
        * 예외가 발생한 예외는 SQLException 안에 담긴 에러 코드와 SQL 상태정보를 참고해봐야함. -> SQLException의 getErrorCode()로 가져올 수 있는 DB 에러 코드는 DB별로 다르다. DB벤더가 정의한 고유한 에러코드를 사용하기때문

    * 앞에서 만든 add()메소드에선 새로운 사용자를 등록했다가 키가 중복되서 예외가 발생하는 경우를 확인하기위해 아래 그림과 같은 방법을 사용했다.
￼
    * SQLException의 에러 코드를 이용해 중복된 값의 등록이 원인인지 확인하는 것.
    * 여기서 사용한 에러 코드는 Mysql 전용코드지만. 오라클이나 다른것으로 바뀌면 에러 코드도 달라져 동작하지 못함.
    * 그래서 SQLException은 예외가 발생했을 때 DB 상태를 담은 SQL 상태정보를 부가적으로 제공함.
    * getSQLState() 메소드로 예외상황에 대한 상태정보를 가져올 수 있다.

    * SQLException이 이러한 상태 코드를 제공하는 이유는 DB에 독립적인 에러정보를 얻기 위해서다. 
    * BUT 문제는 JDBC 드라이브에서 SQLException을 담을 상태 코드를 정확하게 만들어주지않음.
    * 결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 SQLException 만으로 DB에 독립적인 유연한 코드를 작성하는건 불가능에 가깝다.



- DB 에러 코드 매핑을 통한 전환
    * DB전용 에러코드가 더 정확한 정보이다. JDBC 드라이버를 만들 때 들어가는 것이므로 같은 DB라 하더라도 드라이버를 만들때마다 달라지기도 하지만, DB 에러 코드는 DB에서 직접 제공해주는 것이니 버전이 올라가더라도 어느정도 일관성 유지함.

    * 해결 방법 : DB별 에러 코드를 참고해 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만드는 것.
        * DB 종류에 상관없이 동일한 상황에서 일관된 예외를 전달받을 수 있다면 효과적인 대응이 가능.

    * 스프링은 DataAccessException이라는 SQLException을 대체할 수 있는 런타임 예외를 정의하고 있을 뿐 아니라 DataAccessException의 서브 클래스로 세분화된 예외 클래스들을 정의하고 있다.
        * SQL 문법이 문제라면 : BasSqlGrammerException
        * DB 커넥션을 못가져오면 : DataAcessResourceFailureException
        * 데이터 제약조건 위배했거나 일관성을 지키지 않았을 때 : DataIntegrityViolationExceprion
        * 중복 키 : DuplicateKeyException 등등

    * 문제는 DB마다 에러 코드가 나오면 일일이 코드에서 에러 코드 종류를 확인하는건 부담이 크다.
    * 그래서 스프링은 DB별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑정보 테이블을 만들어두고 이를 활용함. 아래그림처럼!
￼
    * JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException으로 포장하는 것이 아니라 에러 코드 계층 구조와 클래스 중 하나로 매핑해준다.



    * 중복 키 에러를 따로 분류해서 예외처리를 해줬던 add() 메소드를 스프링의 JdbcTemplate을 사용하면 아래 그림처럼 간단해진다.
￼
    * SQLException을 런타임 예외인 DataAcessException계층 구조의 예외로 포장해주기 때문에 add() 메소드에 예외 포장을 위한 코드가 따로 필요 없다.



    * 만약 애플리케이션 레벨 체크 예외인 DuplicateUserIdException을 던지게 하고 시다면 아래 그림과 같이 DuplicateKeyException 예외를 전환해주는 코드를 DAO 안에 넣으면 된다.
￼




- DAO인터페이스와 DataAcessException 계층구조
    * DataAcessException은 JDBC의 SQLException을 전환하는 용도로만 만들어진 건 아니다.
    * JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용된다. 
    * DataAccessException은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것.


스프링이 왜 DataAccessException 계층 구조를 이용해 기술에 독립적인 예외를 정의하고 사용할까?
- DAO 인터페이스와 구현의 분리
    * 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위함.
    * 또한 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있기 때문.

    * DAO를 사용하는 쪽에선 내부에 어떤 데이터 액세스 기술을 사용하는지 신경 안써도 된다.

    * User와 같은 자바빈으로 만들어진, 특정 기술에 독립적인 단순한 오브젝트를 주고 받으면서 데이터 액세스 기능을 사용하기만하면된다. -> DI를 통해 제공되도록 만드는게 바람직함.

    * 클라이언트에겐 감출 수 있지만 메소드 선언에 나타나는 예외정보가 문제될 수 있어서 UserDao의 인터페이스를 분리해서 기술에 독립적인 인터페이스로 만들려면 아래 그림처럼 하면된다.
￼
    * 하지만 메소드 선언은 사용할 수 없다.
    * WHY? DAO에서 사용하는 데이터 액세스 기술의 API가 예외를 던지기 때문.
    * 그래서 인터페이스 메소드는 아래 그림과 같이 선언되어야함.
￼
    * 이렇게 예외를 던지면 DAO 구현을 전환할 수 없다. 
    * 결국 인터페이스로 메소드의 구현은 추상화했지만 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라진다는 문제가 ㅂ라생한다. -> 모든 예외를 다 받아주는 throws Exception으로 선언이  무식하지만 제일 단순함.
￼

    * 하지만 DAO메소드 내에서 SQLException같은 메소드를 런테임 예외로 포장해서 던질 수 있다.
    * DAO를 사용하는 클라이언트 입장에서는 DAO 사용 기술에 따라서 예외 처리 방법이 달라야함
        * Client가 DAO 기술에 의존적이기 때문.



- 데이터 액세스 예외 추상화와 DataAessException 계층구조
    * 스프링은 자바의 다양하나 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException 계층 구조안에 정리해놨다.

    * 데이터 액세스 기술을 부정확하게 사용했을 때는 InvalidDataAccessResourceUsageException 예외가 던져진다.
    * 스프링이 기술 종류에 상관없이 이런 성격의 예외를 InvalidDataAccessResourceUsageException 예외로 던지기 때문에 시스템 레벨의 예외처리 작업을 통해 개발자에게 빠르게 통보해주도록 만들 수 있다.

    * 또는 JDO, JPA, 하이버네이트처럼 오브젝트/엔티티 단위로 정보를 업데이트하는 경우에 낙관적인 락킹이 발생할 수 있다.
        * 낙 킹 : 같은 정보를 두 명 이상의 사용자가 동시에 조회하고 순차적으로 업데이트 할 때, 뒤늦게 업데이트 한 것이 먼저 업데이트한 것을 덮어쓰지 않도록 막아주는 편리한 기능

    * 스프링의 예외 전환 방법을 적용하면 깃ㄹ에 상관없이 DataAccessException의 서브 클래스인 ObjectOptimisticLockingFailureException으로 통일시킬 수 있음.
￼
    * 위의 그림처럼 OptimisticlockingFailureException을 상속해서 사용할 수도 있음.

    * DataAccessException 계층구조에는 템플릿 메소드나 DAO 메소드에서 직접 활용할 수 있는 예의도 정의되어있음





- 기술에 독립적인 UserDao 만들기

-  : 인터페이스 적용
￼
    * Public 접근자를 가진 메소드긴 하지만 UserDao의 setDataSource() 메소드는 인터페이스에 추가하면 안된다.
        * UserDao의 구현방법에 따라 변경될 수 있는 메소드이고, UserDao를 사용하는 클라이언트가 알고 있을 필요가 없기 때문에 setDataSource()는 포함시키지 않는다.
    * 아래 그림처럼 선언도 해준다.
￼





- 테스트 보완
    * UserDao 인스턴스 변수도 UserDaoJdbc로 변경해야 할까?
        * Nope! -> @Autowired는 인스턴스 변수에 주입 가능한 타입의 빈을 찬아주기 때문.
    * BUT 특정 기술을 사용한 UserDao의 구현 내용에 관심을 가지고 테스트하려면 테스트에서 @Autowired로 DI를 받을 때 UerDaoJdbc와 같은 특정 타입을 사용해야한다.
    * 구현이 목적이 아닌 테스트이기 때문에 스프링 빈을 인터페이스로 가져오게 만드는게 편하다.
￼





    * 스프링이 데이터 액세스 예외를 다루는 기능을 직접 확인해보자. 일종의 학습테스트임.
￼
    * 아이디가 같은 사용자를 두번 add() 메소드로 등록하면 USER 테이블의 기본키 중복 때문에 예외가 발생할 것.
    * DataAccessException 예외 중 하나가 던져지면 성공 아니면 실패이다.






- DataAccessException 활용 시 주의 상황
    * DuplicateKeyException은 아직까지 JDBC를 이용하는 경우에만 발생함.
        * Why? SQLException에 담긴 DB의 에러코드를 바로 해석하는 JDBC와 달리 JPA나 하이버네이트, JDO 에서는 세분화 되어있지 않기 때문.

    * DataAccessException이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주지만 이런 근본적인 한계 때문에 완벽하다고 할 수 없다. 그래서 사용에 주의를 기울이자!

￼
￼
￼

