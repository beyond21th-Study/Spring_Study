# 예외
<img width="704" height="325" alt="image" src="https://github.com/user-attachments/assets/3b392ce4-920c-4adb-8197-a6cd850ff700" />

## 사라진 SQLException

<img width="710" height="215" alt="image" src="https://github.com/user-attachments/assets/5b2e3e0f-0aa8-4784-929a-fbfee6249708" />

JdbcContext로 만들었던 코드를 스프링의 JdbcTemplate을 적용하도록 바꾸면서 이전에는 적용되어 있던 throws SQLException이 사라진 것을 확인할 수 있음

비록 로그를 남기기 위해 catch를 했다고 해도 다시 JDBC 템플릿 메소드 밖으로 던져서 예외상황이 발생했다는 사실을 알려야 함.

하지만 JdbcTemplate을 적용한 코드에서는 모두 이 SQLException이 사라짐.

## 예외 처리

이를 알아보기에 앞서 개발자들의 코드에서 종종 발견되는 예외 처리의 대표 사례를 살펴보자.

### 예외 블랙홀

<img width="711" height="208" alt="image" src="https://github.com/user-attachments/assets/6619ba1f-4386-41cc-8f68-3c4537f99e12" />

JDBC API를 썼더니 ‘처리되지 않은 예외가 있다’고 에러 표시를 해줌.

이를 try/catch 블록으로 감싸주어 해결 → 컴파일러 에러 메시지도 사라지고 간단한 예제에서는 문제 없이 동작.

But, 그냥 이렇게 넘어가는 경우에는 매우 위험.

why? 프로그램 실행 중 어디선가 오류가 발생하여 예외가 생겨도 그것을 무시하고 계속 진행하기 때문.

결국 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리나 리소스가 소진되거나, 예상치 못한 다른 문제 발생 가능.

최종적으로 오작동 하거나 시스템 오류가 난 경우 조치를 취하기에 이미 늦음.

또한 그 문제에 대한 원인을 찾아내기가 매우 힘듦.

따라서 연습이더라도 이와 같이 코드를 만드는 것은 금물.

<img width="704" height="325" alt="image" src="https://github.com/user-attachments/assets/539ee171-3c30-431b-babd-d990ae1bd2b8" />

또한, 위와 같은 경우도 금물.

why? 개발 중에는 콘솔이나 서버 실행 창에 이 메시지가 보여 문제가 생겨도 금방 알아차릴 수 있고 뭔가 조치를 취할 수 있을지도 모르지만, 로그나 다른 메시지에 금방 묻혀버리는 경우 조치가 어려움.

콘솔 로그를 계속 모니터링하지 않으면 이 예외 코드는 심각한 폭탄으로 남음.

예외는 처리돼야 하는데 이 코드에서는 예외를 처리한 것이 아닌 그저 메시지를 출력한 것.

예외를 처리할 때 반드시 지켜야 할 핵심 원칙

→ 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 함.

SQLException이 발생하는 이유는 SQL 문법에 에러가 있거나 DB에서 처리할 수 없을 정도로 데이터 액세스 로직에 심각한 버그가 있거나, 서버가 죽거나 네트워크가 끊기는 등의 심각한 상황이 벌어졌기 때문.

<img width="701" height="190" alt="image" src="https://github.com/user-attachments/assets/7cbbc369-eccf-443e-8e50-dd09439a389c" />

차라리 위와 같이 하는 것이 나음.

물론 실전에서 이렇게 하면 안됨.

## 무의미하고 무책임한 throws

<img width="705" height="418" alt="image" src="https://github.com/user-attachments/assets/6ded8cbf-0ecf-4afd-ba0f-56a6fea3f9a3" />

매번 정확하게 예외 이름을 적어서 선언하기 귀찮으니 아예 throws Exception이라는 모든 예외를 무조건 던져버리는 선언을 모든 메소드에 기계적으로 넣는 코드.

이런 코드에서는 의미 있는 정보를 얻을 수 없음.

위의 두 사례처럼 catch문에 그저 메시지만 출력하거나 모든 예외를 던지는 식의 코드는 매우 안 좋은 예외 처리 방법.

## 예외의 종류와 특징

### Error

java.lang.Error 클래스의 서브클래스들.

에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용됨

그래서 주로 자바 VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안됨.

OutOfMemoryError나 ThreadDeath 같은 에러는 catch 블록으로 대응할 수 있는 방법 x.

따라서 시스템 레벨에서 특별한 작업을 하는 게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓸 필요 x.

### Exception과 체크 예외

java.lang.Exception 클래스와 그 서브 클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중 예외 상황이 발생했을 경우 사용됨.

Exception 클래스는 다시 체크 예외와 언체크 예외(Unchecked exception)로 구분.

체크 예외는 Exception 클래스의 서브 클래스이면서 RuntimeException 클래스를 상속하지 않은 것들.

언체크 예외는 RuntimeException을 상속한 클래스들.

RuntimeException은 Exception의 서브 클래스이므로 Exception의 일종이긴 하지만 자바는 이 RuntimeException과 그 서브 클래스는 특별하게 다룸.

<img width="708" height="352" alt="image" src="https://github.com/user-attachments/assets/4d06758d-5218-4e5e-b3c8-a4fd5927ebf6" />

일반적으로 예외라고 하면 Exception 클래스의 서브 클래스 중 RuntimeException을 상속하지 않은 것만을 말하는 체크 예외로 간주 가능.

체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 함.

사용할 메소드가 체크 예외를 던지는 경우 catch 문으로 잡거나 throws를 정의해서 메소드 밖으로 던져야 컴파일 에러가 발생하지 않음.

IOException, SQLException을 비롯해서 예외적인 상황에서 던져질 가능성이 있는 대부분의 것들은 체크 예외.

### RuntimeException과 언체크/런타임 예외

java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외 처리를 강제하지 않기 때문에 언체크 예외라 불림.

또한 대표 클래스 이름을 따서 런타임 예외라고도 함.

에러와 마찬가지로 이 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 됨.

명시적으로 하더라도 상관 x.

런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것.

대표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 NullPointerException이나, 허용되지 않은 값을 사용해 메소드를 호출할 때 발생하는 IllegalArgumentException 등.

이런 예외는 코드에서 미리 조건을 체크하도록 주의 깊게 만드는 경우 피할 수 있지만, 개발자의 부주의로 인해 발생하는 경우에 발생하도록 만든 것이 런타임 예외.

따라서 런타임 예외는 예상하지 못했던 예외 상황에서 발생하는 게 아니기에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것.

## 예외 처리 방법

### 예외 복구

예외 상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것.

예시로 사용자가 요청한 파일을 읽으려고 시도했는데 해당 파일이 없다거나 다른 문제가 있어서 읽히지 않아 IOException이 발생한 경우.

이 때 사용자에게 상황을 알려주고 다른 파일을 이용하도록 안내하여 예외 상황 해결 가능.

예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도해주는 것.

이런 경우 예외 상황은 다시 정상으로 돌아오고 예외를 복구했다고 볼 수 있지만, IOException 에러 메시지가 사용자에게 그냥 던져지는 것은 예외 복구가 아님.

또 다른 예시로 네트워크가 불안해서 가끔 서버에 접속이 잘 안 되는 열악한 환경에 있는 시스템이라면 원격 DB 서버에 접속하다 실패해서 SQLException이 발생하는 경우에 재시도 가능.

네트워크 접속이 원활하지 않아 예외가 발생했다면 일정 시간 대기한 뒤 다시 접속을 시도해보는 방법을 사용해서 예외 상황으로부터 복구 시도 가능.

물론 정해진 횟수만큼 재시도해서 실패한 경우 예외 복구는 포기해야 함.

예외 처리 코드를 강제하는 체크 예외들은 이렇게 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용.

API를 사용하는 개발자로 하여금 예외 상황이 발생할 수 있음을 인식하도록 도와주고 이에 대한 적절한 처리를 시도해보도록 요구하는 것.

ㅇ<img width="709" height="451" alt="image" src="https://github.com/user-attachments/assets/35be39fd-a529-41b6-8155-326c8b1711c8" />

통제불능의 외부 요인으로 인해 예외 발생 시 maxretry만큼 재시도하는 간단한 코드.

### 예외 처리 회피

예외 처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것.

throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch 문으로 일단 예외를 잡은 후 로그를 남기고 다시 예외를 던지는 것.

<img width="706" height="493" alt="image" src="https://github.com/user-attachments/assets/563d6d8e-4fb5-46be-870c-2b993aa75831" />

위와 같이 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 던져주어야 함.

콜백 오브젝트의 메소드는 모두 throws SQLException이 붙어 있음.

why? SQLException을 처리하는 일은 콜백 오브젝트의 역할이 아니라고 보기 때문.

콜백 오브젝트의 메소드는 SQLException에 대한 예외를 회피하고 템플릿 레벨에서 처리하도록 던져줌.

But, 콜백과 템플릿처럼 긴밀하게 역할을 분담하는 관계가 아니라면 자신의 코드에서 발생한 예외를 그냥 던져버리는 것은 무책임한 책임 회피일 수 있음.

예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 함.

콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외 처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이라는 분명한 확신이 필요.

### 예외 전환

예외 회피와 비슷하게 예외를 복구해서 정상적인 상태로는 만들 수 없기 때문에 예외를 메소드 밖으로 던지는 것.

하지만 예외 회피와 달리, 발생한 예외를 그대로 넘기는 것이 아니라 적절한 예외로 전환해서 던진다는 것이 특징.

예외 전환은 보통 두 가지 목적으로 사용됨.

1. 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못하는 경우 → 의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서.(API가 발생하는 기술적인 로우 레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것.)

예시로 새로운 사용자를 등록하려고 시도했을 때 아이디가 같은 사용자가 있어서 DB 에러가 발생하면 JDBC API는 SQLException을 발생시킴.

이 경우 DAO 메소드가 SQLException을 그대로 밖으로 던져버리면, DAO를 이용해 사용자를 추가하려고 한 서비스 계층 등에서는 왜 SQLException이 발생했는지 쉽게 알 방법이 없음. 

로그인 아이디 중복 같은 경우 충분히 예상 가능하고 복구 가능한 예외 상황.

이런 경우 SQLException의 정보를 해석하여 DuplicateUserIdException 같은 예외로 바꿔서 던져주는 게 좋음.

의미가 분명한 예외가 던져지면 서비스 계층 오브젝트에서 적절한 복구 작업 시도 가능.

<img width="707" height="411" alt="image" src="https://github.com/user-attachments/assets/49907b18-9186-457c-b055-e3b203bb86b8" />

보통 전환하는 예외에 원래 발생한 예외를 담아서 중첩 예외로 만드는 것이 좋음.

중첩 예외는 getCause() 메소드를 이용해서 처음 발생한 예외가 무엇인지 확인 가능.

<img width="709" height="328" alt="image" src="https://github.com/user-attachments/assets/a3803bbb-d85f-49dc-aa72-34fc24df409e" />

1. 예외를 처리하기 쉽고 단순하게 만들기 위해 포장하는 것.

→ 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식은 같지만 의미를 명확하게 하려고 다른 예외로 전환하는 것은 아님.

주로 예외 처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우 사용.

EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비즈니스 로직으로 볼 때 의미 있는 예외이거나 복구 가능한 예외가 아님.

이런 경우 런타임 예외인 EJBException으로 포장해서 던지는 편이 나음.

<img width="701" height="339" alt="image" src="https://github.com/user-attachments/assets/c12f03cf-5bb1-4ea9-98d3-76611d5f6632" />

EJBException은 RuntimeException 클래스를 상속한 런타임 예외.

이렇게 런타임 예외로 만들어 전달하면 EJB는 이를 시스템 익셉션으로 인식하고 트랜잭션을 자동으로 롤백해 줌.

런타임 예외이기 때문에 EJB 컴포넌트를 사용하는 다른 EJB나 클라이언트에서 일일이 잡거나 다시 던지는 수고를 할 필요 x 

why? 잡아도 복구할 만한 바업이 없기 때문.

반대로 애플리케이션 로직 상에서 예외 조건이 발견되거나 예외 상황이 발생하는 경우는 API가 던지는 예외가 아니라 애플리케이션 코드에서 의도적으로 던지는 예외.

이런 경우에는 체크 예외를 사용하는 것이 적절 → 비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응이나 복구 작업이 필요하기 때문.

일반적으로 체크 예외를 계속 throws를 사용해 넘기는 것은 무의미.

어차피 복구가 불가능한 예외라면 가능한 한 빨리 런타임 예외로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws 선언이 들어가지 않도록 해주어야 함.

대부분의 서버 환경에서는 애플리케이션 코드에서 처리하지 않고 전달된 예외들을 일괄적으로 다룰 수 있는 기능을 제공.

어차피 복구하지 못할 예외라면 애플리케이션 코드에서는 런타임 예외로 포장해서 던져버리고, 예외 처리 서비스 등을 이용해 자세한 로그를 남기고, 관리자에게는 메일 등으로 통보해주고, 사용자에게는 안내 메시지를 보여주는 식으로 처리하는 게 바람직.

## 예외 처리 전략

예외의 종류와 처리 방법 등을 기준으로 일관된 예외 처리 전략을 정리.

### 런타임 예외의 보편화

원래 자바는 복구 가능한 상황을 체크 예외로 만들고, 컴파일러 차원에서도 처리하도록 강제했음.

하지만 서버/웹 환경에서는 대부분의 예외가 개발자가 복구할 수 없는 오류 → 굳이 잡을 필요 x

체크 예외는 매번 try-catch 또는 throws를 강제해서 코드만 더럽게 만듦.

그래서 현대 프레임워크는 대부분 언체크 예외를 사용.

항상 복구할 수 있는 예외가 아니라면 일단 언체크 예외로 만드는 경향이 있음.

언체크 예외라도 필요하다면 얼마든지 catch 블록으로 잡아서 복구하거나 처리 가능.

하지만 대개는 복구 불가능한 상황이고 보나마나 RuntimeException 등으로 포장해서 던져야 할 테니 아예 API 차원에서 런타임 예외를 던지도록 만드는 것.

### add() 메소드의 예외 처리

add() 메소드는 DuplicatedUserIdException과 SQLException, 두 가지의 체크 예외를 던지게 되어 있음.

DuplicatedUserIdException은 충분히 복구 가능한 예외이므로 add() 메소드를 사용하는 쪽에서 잡아서 대응 가능하지만, SQLException은 대부분 복구 불가능한 예외이므로 잡아봤자 처리할 것도 없고 결국 throws를 타고 계속 앞으로 전달되다가 애플리케이션 밖으로 던져질 것.

그럴 바에는 그냥 런타임 예외로 포장해 던져버려서 그 밖의 메소드들이 신경 쓰지 않게 해주는 편이 나음.

DuplicatedUserIdException도 굳이 체크 예외로 둬야 하는 것은 아님.

DuplicatedUserIdException처럼 의미 있는 예외는 add() 메소드를 바로 호출한 오브젝트 대신 더 앞단의 오브젝트에서 다룰 수 있음.

어디에서든 DuplicatedUserIdException를 잡아서 처리 가능하다면 굳이 체크 예외로 만들지 않고 런타임 예외로 만드는 게 나음.

대신 add() 메소드는 명시적으 DuplicatedUserIdException를 던진다고 선언 필요.

그래야 add() 메소드를 사용하는 코드를 만드는 개발자에게 의미 있는 정보 전달 

<img width="631" height="187" alt="image" src="https://github.com/user-attachments/assets/e46e6aa2-24bc-4a04-85e9-95d41b1f2ef1" />

먼저 사용자 아이디가 중복됐을 때 사용하는 DuplicatedUserIdException을 생성.

필요하면 언제든 잡아서 처리 가능하도록 별도의 예외로 정의하기는 하지만, 필요 없다면 신경 쓰지 않아도 되도록 RuntimeException을 상속한 런타임 예외로 생성.

+중첩 예외를 만들 수 있도록 생성자 추가. 메시지나 예외 상황을 전달하는 데 필요한 정보를 더 넣을 수도 있음.

<img width="615" height="338" alt="image" src="https://github.com/user-attachments/assets/a55020d2-9e1d-4fcf-9e9b-1d25f9bdcff7" />

다음으로는 add() 메소드를 변경된 예외 처리 전략을 이용하여 수정.

이전에는 SQLException을 직접 메소드 밖으로 던지게 했지만, 이제는 런타임 예외로 전환해서 던지도록 수정.

기존의 아이디 중복 때문에 SQLException이 발생한 경우에는 DuplicatedUserIdException을 던지게 하는 코드는 그대로.

이제 DuplicatedUserIdException 외에 시스템 예외에 해당하는 SQLException은 언체크 예외가 됨.

따라서 메소드 선언의 throws에 포함 시킬 필요 x.

반면 역시 언체크 예외로 만들어지기는 했지만 add() 메소드를 사용하는 쪽에서 아이디 중복 예외를 처리하고 싶은 경우 활용 가능함을 알려주도록 DuplicatedUserIdException을 throws 선언에 포함시킴.

이제 위 add() 메소드를 사용하는 오브젝트는 SQLException을 처리하기 위해 불필요한 throws 선언을 할 필요는 없으면서 필요한 경우 아이디 중복 상황을 처리하기 위해 DuplicatedUserIdException 이용 가능.

이렇게 런타임 예외를 일반화해서 사용하는 방법은 여러모로 장점이 많지만, 런타임 예외로 만들었기 때문에 사용에 더 주의 필요.

why? 컴파일러가 예외 처리를 강제하지 않으므로 신경 쓰지 않으면 예외 상황을 충분히 고려하지 않을 수도 있기 때문.

### 애플리케이션 예외

런타임 예외 중심의 전략은 복구할 수 있는 예외가 없다고 가정하고 예외가 생겨도 어차피 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고, 꼭 필요한 경우는 런타임 예외라도 잡아서 복구하거나 대응해줄 수 있으니 문제 될 것이 없다는 낙관적인 태도를 기반으로 함.

이런 면에서 직접 처리할 수 없는 예외가 대부분이라고 하더라도 혹시 놓치는 예외가 있을 수 있으니, 일단 잡고 보도록 강제하는 체크 예외의 비관적인 접근 방법과 대비됨.

반면에 시스템 또는 외부의 예외 상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고, 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 존재하고 이를 일반적으로 애플리케이션 예외라고 함.

이 기능을 담은 메소드를 설계하는 방법

1. 정상 동작 시와 예외가 발생한 경우에 각각 다른 종류의 리턴 값을 돌려주는 것.

리턴 값을 일종의 결과 상태를 나타내는 정보로 활용.

이 메소드를 호출한 쪽은 반드시 리턴 값을 확인.

물론 이것은 시스템 오류가 아니므로 기술적으로 보면 두 가지 경우 모두 정상 흐름.

하지만 이렇게 리턴 값으로 결과를 확인하고, 예외 상황을 체크하면 불편한 점이 존재.

우선 예외 상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란 발생 가능.

정상적인 처리가 되지 않았을 경우 전달하는 값의 표준 같은 것은 없기에 개발자마다 다른 값을 반환하는 경우 존재.

일관된 예외 상황에서의 결과 값에 대한 정책이 완벽하게 갖춰져 있고, 사전에 상수로 정의해둔 표준 코드를 사용하지 않는다면 개발자 사이의 의사소통 문제로 인해 제대로 동작하지 않을 위험 존재.

또한 결과 값을 확인하는 조건문이 자주 등장하여 코드가 지저분해지고 흐름 파악이 어려워질 수 있음.

1. 정상적인 흐름을 따르는 코드는 그대로 두고, 예외 상황에서는 비즈니스적인 의미를 띈 예외를 던지도록 만드는 것.

정상적인 흐름을 따르지만 예외가 발생할 수 있는 코드를 try 블록 안에 깔끔하게 정리해두고 예외 상황에 대한 처리는 catch 블록에 모아둘 수 있어 코드를 이해하기에 용이.

이 때 사용하는 예외는 의도적으로 체크 예외로 생성.

그래서 개발자가 자주 발생 가능한 예외 상황에 대한 로직을 구현하도록 강제해주는 것이 좋음.

<img width="628" height="342" alt="image" src="https://github.com/user-attachments/assets/46f11604-46fb-4155-a0dd-3d458f662678" />

사용자가 요청한 금액을 은행 계좌에서 출금하는 기능을 애플리케이션 예외를 사용하여 작성.

### SQLException

SQLException의 99%는 코드 레벨에서 복구 불가.

why? 보통 프로그램의 오류 또는 개발자의 부주의 때문에 발생하는 경우이거나, 통제 불가한 외부 상황으로 인해 발생하기 때문.

시스템의 예외라면 당연히 애플리케이션 레벨에서 복구할 방법 x.

관리자나 개발자에게 빨리 예외가 발생한 사실을 알려지도록 전달하는 게 전부.

따라서 예외 처리 전략 적용 필요.

필요도 없는 throws 선언으로 방치하지 않고 언체크/런타임 예외로 전환 필요.

스프링의 JdbcTemplate은 바로 이 예외 처리 전략을 따름.

템플릿과 콜백 안에서 발생하는 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던져줌.

따라서 꼭 필요한 경우에만 런타임 예외인 DataAccessException을 잡아서 처리하면 되고 그 외의 경우 무시.

# 예외 전환

예외를 다른 것으로 바꿔서 던지는 예외 전환의 목적은 두 가지.

1. 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것.
2. 로우 레벨의 예외를 좀 더 의미 있고 추상화된 예외로 바꿔서 던져주는 것.

스프링의 Jdbc Template이 던지는 DataAccess Exception은 일단 런타임 예외로 SQLException을 포장해주는 역할을 함.

그래서 대부분 복구가 불가능한 예외인 SQLException에 대해 애플리케이션 레벨에서는 신경 쓰지 않도록 해주는 것이고  또한, DataAccessException은 SQLException에 담긴 다루기 힘든 상세한 예외정보를 의미 있고 일관성 있는 예외로 전환해서 추상화해주려는 용도로 쓰이기도 함.

## JDBC의 한계

JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의해놓고, 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해줌.

내부 구현은 DB에 따라 다르겠지만 JDBC의 표준 인터페이스를 통해 그 기능을 제공해주기 때문에 표준화된 JDBC의 API에 익숙해지면 DB의 종류에 상관없이 일관된 방법으로 프로그램 개발 가능.

하지만 DB 종류에 상관 없이 사용할 수 있는 데이터 액세스 코드를 작성하는 일은 쉽지 않음.

표준화된 JDBC API가 DB 프로그램 개발 방법을 학습하는 부담은 확실히 줄여주지만 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지는 않음.

### 비표준 SQL

SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있기는 하지만, 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공. 

이로 인해 특정 DB에 종속적인 코드가 되기도 함.

하지만 DB의 변경 가능성을 고려해서 유연하게 만들어야 한는 경우 호환 가능한 표준 SQL만 사용하거나 DB 별로 별도의 DAO를 만들거나 SQL을 외부에 독립시켜서 DB에 따라 변경해 사용하는 방법이 존재.

표준 SQL만을 사용할 경우, 당장 웹 프로그램에서 자주 필요로 하는 페이징 쿼리에서부터 문제 발생 → 현실성 x

결국 사용할 수 있는 방법은 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 하는 것.

## 호환성 없는 SQLException의 DB 에러 정보

DB마다 SQL만 다른 것이 아니라 에러의 종류와 원인도 제각각인데 JDBC는 데이터 처리 중에 발생하는 다양한 예외를 그냥 SQLException 하나에 모두 담아버림.

그런데 SQLException의 getErrorCode() 로 가져올 수 있는 DB 에러 코드는 DB 별로 모두 다름.

만일 사용된 에러코드와 다른 DB의 에러 코드가 나오는 경우 기대한 대로 동작하지 못함.

그래서 SQLException은 예외가 발생했을 때의 DB 상태를 담은 SQL 상태 정보를 부가적으로 제공.

getSQLState() 메소드로 예외 상황에 대한 상태 정보를 가져올 수 있음.

SQLException이 이러한 상태 코드를 제공하는 이유는 DB에 독립적인 에러 정보를 얻기 위함.

하지만 DB의 JDBC 드라이버에서 SQLException을 담을 상태 코드를 정확하게 만들어주지 않음.

아예 표준 코드와 상관없는 엉뚱한 값이 들어 있기도 하고, 어떤 DB는 클래스 코드까지는 바로 오지만, 서브 클래스 코드는 일체 무시하고 값을 다 0으로 넣는다거나 하는 식.

결과적으로 이 SQL 상태 코드를 믿고 결과를 파악하도록 코드를 작성하는 것은 위험.

### DB 에러 코드 매핑을 통한 전환

SQLException의 비표준 에러 코드와 SQL 상태 정보에 대한 해결책.

SQLException에 담긴 SQL 상태 코드는 신뢰할 만한 게 아니므로 고려 x.

해결 방법은 DB 별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해주는 기능을 만들어 주는 것.

이런 에러 코드 값을 확인할 수 있다면, 키 중복 때문에 발생하는 SQLException을 의미가 분명히 드러나는 예외로 전환 가능.

문제는 DB마다 에러 코드가 제각각이라는 점.

DAO 메소드나 JdbcTemplate 등의 코드에서 일일이 DB 별로 에러 코드의 종류를 확인하는 작업을 수행하는 것은 부담이 너무 큼.

대신 스프링은 DB 별 에러 코드를 분류해서 스프링이 정의한 예외 클래스와 매핑해놓은 에러 코드 매핑 정보 테이블을 만들어두고 이를 이용. (스프링 짱짱맨)

<img width="613" height="451" alt="image" src="https://github.com/user-attachments/assets/3b0af2a1-c157-4d60-b4c1-4727ffa7e185" />

JdbcTemplate은 SQLException을 단지 런타임 예외인 DataAccessException으로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException 계층구조의 클래스 중 하나로 매핑해 줌.

드라이버나 DB 메타 정보를 참고해서 DB 종류를 확인하고 DB 별로 미리 준비된 매핑 정보를 참고해서 적절한 예외 클래스를 선택하기 때문에 DB가 달라져도 같은 종류의 에러라면 동일한 예외를 받을 수 있음.

JdbcTemplate을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 겨의 신경 쓸 필요 x.

그런데 중복키 에러가 발생했을 때 애플리케이션에서 직접 정의한 예외를 발생시키고 싶은 경우 애플리케이션 레벨의 체크 예외인 DuplicateUserIdException을 던지게 하고 싶다면 스프링의 DuplicateUserIdException 예외를 전환해주는 코드를 DAO 안에 넣으면 됨

<img width="647" height="282" alt="image" src="https://github.com/user-attachments/assets/4453094a-58aa-4a17-9a3d-980d519577c1" />

## DAO 인터페이스와 DataAccessException 계층 구조

DataAccess Exception은 JDBC의 SQLException을 전환하는 용도로만 만들어진 것이 아닌 JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용됨.

DataAccess Exception은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어 줌.

데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것.

### DAO 인터페이스와 구현의 분리

DAO를 굳이 따로 만들어서 사용하는 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓기 위함.

또한 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들기 위해서이기도 함.

DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경 쓸 필요 X.

특정 기술에 독립적인 단순한 오브젝트를 주고 받으면서 데이터 액세스 기능을 사용하기만 하면 됨.

DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고 DI를 통해 제공되도록 만드는 것이 바람직하지만 DAO의 메소드 선언에 나타나는 예외 정보가 문제가 될 수 있음.

<img width="496" height="126" alt="image" src="https://github.com/user-attachments/assets/6c1f819a-16a3-44cc-acf0-99da1cd6e88f" />

위와 같은 메소드 선언은 사용 불가.

why? DAO에서 사용하는 데이터 액세스 기술의 API가 예외를 던지기 때문.

만약 JDBC API를 사용하는 UserDao 구현 클래스의 add() 메소드라면 SQLException을 던질 것.

따라서 인터페이스 메소드도 다음과 같이 선언.

<img width="349" height="60" alt="image" src="https://github.com/user-attachments/assets/cffba59b-6268-4846-81a2-527102f29b6e" />

이렇게 정의한 인터페이스는 JDBC 가 아닌 데이터 액세스 기술로 DAO 구현을 전환하면 사용할 수 없음.

액세스 기술의 API는 자신만의 독자적인 예외를 던지기 때문에 다음과 같이 인터페이스 메소드를 바꿔주면 모르겠지만, SQLException을 던지도록 선언한 인터페이스 메소드는 사용할 수 없음.

ㄴ<img width="508" height="98" alt="image" src="https://github.com/user-attachments/assets/fe24a2d5-2d55-4170-bca2-ca4c98df0ed9" />

결국 인터페이스로 메소드의 구현은 추상화했지만 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라진다는 문제 발생.

이를 해결하는 가장 단순한 방법은 모든 예외를 다 받아주는 throws Exception으로 선언하는 것.

<img width="338" height="42" alt="image" src="https://github.com/user-attachments/assets/cb8aed0f-aa0c-4010-9adb-d21eb0abedec" />

간단하지만 무책임함.

JDBC는 SQLException이라는 체크 예외를 던지는데 JPA/Hibernate같은 신기술은 런타임 예외만 씀.

그래서 DAO에서만 그 체크 예외를 받아서 런탕미 예외로 감싸서 던지면 나머지 계층은 체크 예외를 신경 쓸 필요 x.

<img width="225" height="37" alt="image" src="https://github.com/user-attachments/assets/d98f9f3c-7da2-415d-b691-5885a110bc50" />

이제 DAO에서 사용하는 기술에 완전히 독립적인 인터페이스 선언 가능.

대부분의 데이터 액세스 예외는 애플리케이션에서는 복구 불가능하거나 할 필요가 없음.

그렇다고 모든 예외를 다 무시해야 하는 것은 아님. 

비즈니스 로직에서 의미있게 처리 가능한 예외의 경우나 애플리케이션에서 사용하지 않더라도 시스템 레벨에서 데이터 액세스 예외를 의미 있게 분류할 필요 있음.

하지만 데이테 액세스 기술이 달라지면 같은 상황에서도 다른 종류의 예외가 던져짐.

때문에 DAO를 사용하는 클라이언트 입장에서는 DAO의 사용 기술에 따라서 예외 처리 방법이 달라져야 함.

그로 인해 클라이언트가 DAO의 기술에 의존적이게 될 수 밖에 없음.

단지 인터페이스로 추상화하고, 일부 기술에서 발생하는 체크 예외를 런타임 예외로 전환하는 것만으로는 불충분.

### 데이터 액세스 예외 추상화와 DataAccess Exception 계층구조

스프링은 데이터 액세스 기술마다 예외가 제각각이라 혼란스럽기 때문에 전부 DataAccessException 하나의 계층으로 통일해서 던지도록 만들어 놓음.

그래서 기술마다 다른 예외를 catch 할 필요 x.

개발자는 기술이 달라도 같은 예외만 잡으면 되고 기술을 갈아끼우더라도 예외 처리 코드 바꿀 필요 없음.

이를 예외 추상화 라고 함.

낙관적 락킹(optimistic locking)도 기술마다 다름

JPA(OptimisticLockException), Hibernate(StaleObjectStateException) 등.

그런데 스프링은 이걸 전부 **ObjectOptimisticLockingFailureException으로 바꿔서 던짐.**

<img width="629" height="276" alt="image" src="https://github.com/user-attachments/assets/586e2608-1099-475c-8bbf-711e873a1b1f" />

이 덕분에 기술 종속이 사라지고, 개발자가 더 이상 각 기술의 예외를 알 필요가 없어짐.

DataAccessException 계층구조에는 템플릿 메소드나 DAO 메소드에서 직접 활용할 수 있는 예외도 정의되어 있음.

JDBC는 쿼리 결과가 0개 또는 2개 이상인 경우 예외를 던지지 않음.

하지만 스프링의 JdbcTemplate은 1개만 있어야 하는 상황에서 결과 수가 맞지 않는 경우 DataAccessException 예외를 던짐.

이런 경우 사용할 수 있도록 DataAccessException 계층 구조에는 IncorrectResultsizeDataAccessException이 정의되어 있음

JdbcTempate과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 던질 수 있고, 결국 인터페이스 사용, 런타임 예외 전환과 함께 DataAccessException 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수 있음

## 기술에 독립적인 UserDao 만들기

### 인터페이스 적용

지금까지 만들어서 써왔던 UserDao 클래스를 인터페이스와 구현으로 분리.

<img width="624" height="231" alt="image" src="https://github.com/user-attachments/assets/e9df9595-f808-4b20-9c0d-758428ef4d66" />

public 접근자를 가진 메소드이긴 하지만 setDataSource() 메소드는 인터페이스에 추가하면 안됨.

setDataSource() 메소드는 User Dao의 구현 방법에 따라 변경될 수 있는 메소드이고, UserDao를 사용하는 클라이언트가 알고 있을 필요도 없음.

UserDaoJdbc 클래스는 UserDao 인터페이스를 구현하도록 만들고, 스프링 설정에서는 userDao 빈을 UserDaoJdbc 클래스로 등록하면 됨.

<img width="608" height="141" alt="image" src="https://github.com/user-attachments/assets/0c308bc7-9565-4439-9b07-c07915cfcb2d" />

### 테스트 보완

<img width="423" height="83" alt="image" src="https://github.com/user-attachments/assets/d084c975-c334-4af0-9c2c-a84e42e931db" />

UserDao인스턴스 변수 선언을 굳이 UserDaoJdbc로 변경할 필요 x

why? @Autowired는 스프링의 컨텍스트 내에서 정의된 빈 중 인스턴스 변수에 주입 가능한 타입의 빈을 찾아주기 때문에 UserDaoTest의 dao 변수에 UserDaoJdbc 클래스로 정의된 빈을 넣는 데 아무런 문제가 없음.

<img width="540" height="253" alt="image" src="https://github.com/user-attachments/assets/ff138f70-58bd-4c6a-ae4e-de4c80a15051" />

UserDao의 인터페이스와 구현을 분리함으로써 데이터 액세스의 구체적인 기술과 UserDao의 클라이언트 사이에 DI가 적용된 모습을 보여줌

아직 UserDao를 사용하는 애플리케이션 코드를 만들지는 않았지만 일단 테스트를 하나의 클라이언트로 간주.

다음으로는 UserDaoTest에 중복된 키를 가진 정보를 등록했을 때 발생하는 예외 확인용 테스트 추가.

<img width="610" height="237" alt="image" src="https://github.com/user-attachments/assets/a1ad1bd6-88e0-4a5b-ada1-c5e27b5c155f" />

아이디가 같은 사용자를 두 번 add() 메소드로 등록하면 USER 테이블의 기본키 때문에 예외가 발생할 것.

이 때 스프링의 DataAccessException 예외 중의 하나가 던져지면 성공.

예외가 발생하면 성공이고 아니면 실패이기 때문에 @Test (expected=..) 를 이용.

이번엔 expected=DataAccessException.class 부분을 빼고 테스트를 실행.

<img width="599" height="111" alt="image" src="https://github.com/user-attachments/assets/a7b7eaf8-4cc8-4ced-b7ae-4350b4646dcc" />

에러 메시지를 통해 어떤 예외 클래스가 던져졌는지 확인 가능.

DuplicateKeyException은 DataAccessException의 서브 클래스로 DataIntegrityViolationException의

한 종류임을 확인 가능.

### DataAccessException 활용 시 주의사항

스프링의 DataAccessException 계층이 모든 기술(JDBC, JPA, Hibernate)에서 **완전히 동일한 예외를 보장하지는 않음.**

특히 중복 키 예외는 JDBC에서만 정확히 잡히고, JPA/Hibernate에서는 더 포괄적인 IntegrityViolation 예외로만 변환.

완전한 일관성을 원하는 경우 직접 커스텀 예외를 만들어 DAO에서 강제로 통일 필요.

에러 코드 변환에 필요한 DB의 종류를 알아내기 위해 현재 연결된 DataSource를 필요.

<img width="645" height="137" alt="image" src="https://github.com/user-attachments/assets/14dce94b-1465-4fee-853d-9b2841ed9adf" />

<img width="639" height="297" alt="image" src="https://github.com/user-attachments/assets/19cc28ff-e3a0-45d8-8508-be46f004196e" />

<img width="618" height="240" alt="image" src="https://github.com/user-attachments/assets/6c0aa97e-1260-454f-8c55-4ee0ddcaea12" />

스프링은 JDBC 중복키 오류를 DuplicateKeyException으로 자동 전환하는데, 이 예외 안에는 원래 발생한 SQLException이 중첩되어 있음.
이를 직접 검증하려면 getRootCause()로 내부 SQLException을 꺼내고, SQLErrorCodeSQLExceptionTranslator를 이용해 같은 SQLException을 수동으로 translate()에 넣어 동일한 DuplicateKeyException이 생성되는지 확인하면 됨. 
이 방식은 JdbcTemplate을 쓰지 않을 때나, JPA/Hibernate처럼 기본적으로 DuplicateKeyException을 만들지 않는 기술에서도 중첩된 SQLException을 꺼내 동일한 예외로 통일하고 싶을 때 활용
