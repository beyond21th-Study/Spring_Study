## 6.5.4 AOP란 무엇인가?

### 트랜잭션 서비스 추상화

- 트래잭션 경계 설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 생기는 문제점은 특정 트랜잭션 기술에 종속되는 코드가 돼 버린다는 것이다.
- JDBC의 로컬 트랜잭션 방식을 적용한 코드를 JTA를 이용한 글로벌분산 트랜재션 방식으로 바꾸려면 모든 트랜잭션 적용 코드를 수정해야한다는 문제점이 발생한다.
- 그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 '서비스 추상화 기법'을 적용한다.
- 트랜잭션 추상화란 인터페이스와 DI를 통해 무엇을 하는지 남기고 그것을 어떻게 하는지를 분리한 것이다.
  <br> 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.
  

### 프록시와 데코레이터 패턴

- 트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다는 점과
<br> 트랜잭션의 경계 설정을 담당하는 코드의 특성 때문에 단순환 추상화와 메소드 추출 방법으로는 더이상 제거할 방법이 없다는 점을 해결하기위해
<br> DI를 이용해 데코레이터 패턴을 적용한다.
<br> 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스와 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만든다.
- 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만든다.
- 그래서 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 된다.
- 결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고, 독립적으로는 로직을 검증하는 고립된 단위 테스트를 만들 수도 있게 됐다.

### 다이내믹 프록시와 프록시 팩토리 빈

- 프록시 클래스 없이도 프록시 오브젝트를런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용하면 프록시 클래스 코드 작성의 부담도 덜고, 부가기능 부여코드가
<br> 여기저기 중복돼서 나타나는 문제도 일부 해결 할 수 있다. 일부 메소드에만 트랜잭션을 적용해야 하는 경우에는 메소드를 선정하는 패턴 등을 이용할 수도 있었다.
<br> 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제를 해결하지 못했다.
- 그래서 JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI를 도입했다.
- 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고
<br> 여러 프록시에서 공유해서 사용할 수 있게 됐다. 

### 자동 프록시 생성 방법과 포인트컷

- 트랜잭선 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야한다는 부담이 남아 있었다.
- 이를 해결하기 위해 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.
- 또한 프록시를 적용할 대상을 일일히 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다.
- 결국 트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다.

### 부가기능의 모듈화

- 트랜잭션 같은 부가기능을 어떻게 모듈로 분리 할 수 있을까?
- 코드를 분리하거나 한데 모으거나, 인터페이스를 도입하고 DI를 통해 런타임 시에 의존 관계를 만들어줌으로써 대부분의 문제를 해결 할 수 있었다. 하지만 이 트랜잭션 적용 코드는 기존에 써왔던 방법으로는 간단하게 분리해서 독립된 모듈로 만들 수가 없었다.
<br> 왜냐하면 트랜잭션 경계설정 같은 부가기능은 핵심 코드 여기저기에 끼어들어야 해서 단순 분리로는 모듈화가 어렵다.
- 그래서 이 문제를 해결하기 위해서 DI, 다이내믹 프록시, 데코레이터, 자동 프록시 생성, 포인트컷 같은 기법을 사용한다.
- 그 결과 트랜잭션 코드를 TransactionAdvice 같은 독립 모듈로 분리할 수 있고, 독립적으로 모듈화되어 있기때문에 이 코드는 중복되지 않으며 변경이 필요하면 한 곳만 수정하면 되며 핵심 기능 코드를 건들이지 않아도 된다.
- 결국 어드바이스와 포인트컷을 결합한 어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어 지게 됐다. 

### AOP : 애스펙트 지향 프로그래밍

- 애스펙트란?
- 그 자체로 애플리케이션의 핵심 기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중용한 한 가지 요소이고, 핵심 기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다,
- 애스펙트는 부가될 기능을 정의한 어드바이스와, 어드바이스를 어디에 적용할지를 결정하는 포인트컥으 함께 갖고 있다.
- 애스펙트는 단어 의미 그대로 애플리케이션을 구성하는 '한 가지 측면'이라고 생각할 수 있다.

<img width="433" height="186" alt="image" src="https://github.com/user-attachments/assets/78411b47-b650-461b-b231-005ed557ca2a" />

- 6-21 그림에서 왼쪽네모에는 핵심 기능 코드들이 들어있는걸 볼 수 있다. 부가기능1과 2가 여기저기 흩어져 있다.
- 하지만 AOP를 적용한 오른쪽 그림은 3차원으로 그러져 있는데, 위쪽에는 핵심 기ㄴㅇ 코드만 모여있고 옆과 아래의 '면'에는 부가기능들이 각각 애스펙트로 분리되어있는것을 볼 수 있다. 즉 부가기능들은 핵심코드에서 빠지고 '애스펙트'라는 독립적인 모듈이 따로 존재하게 된다
- 설계와 개발 관점에서는 핵심기능코드와 부가기능 코드를 분리해서 작성이 가능하고
- 런타임 관점에서는 실제 부가기능이 필요한 시점에 자동으로 결합되어 함께 실행된다.

- 이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을
  <br> '애스펙트 지향 프로그래밍(AOP)'이라고 한다.
- AOP는 OOP를 대체하는 게 아니라, OOP가 핵심 기능을 깔끔하게 유지하도록 도와주는 보조 기술이다.
- 부가기능을 “다른 관점(측면)”으로 따로 설계/개발하게 해줘서 핵심 로직을 침범하지 않게 만든다.
- 예를 들어 트랜잭션만 다루고 싶으면 TransactionAdvice만 개발하면 되고 적용 대상은 transactionPointcut 설정만 신경 쓰면 된다.
- 이렇게 애플리케이션을 특정하 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 관점 지향 프로그래밍이라고도 한다.


## 6.5.5 AOP 적용기술

### 프록시를 이용한 AOP

- 스프링은 IoC/DI 컨테이너 + 다이내믹 프록시 + 데코레이터/프록시 패턴 + 자동 프록시 생성 + 빈 후처리 같은 여러 기술을 조합해서 AOP를 구현한다.
- 그중 가장 핵심은 ‘프록시’를 이용하는 것이다.
- 스프링 AOP는 타깃의 메서드 호출 과정에 프록시가 끼어들어 부가기능을 실행하도록 만든다. 그래서 특별한 JVM 설정이나 별도 환경 없이도 스프링 컨테이너만 있으면 AOP를 쓸 수 있다.
- Advice는 MethodInterceptor 같은 인터페이스로 구현되며, 프록시가 호출 정보를 전달받아 타깃 메서드를 실행하기 전/후로 부가기능을 적용한다.
- 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가낭 중요한 역할을 맡고 있는게 프록시다. 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.
  
### 바이트코드 생성과 조작을 통한 AOP

- 프록시 방식이 아닌 AOP도 있다. AOP 기술의 원조이면서 가장 강력한 AOP 프레임워크로 꼽히는 AspetJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.
- AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다.
- 부가기능을 넣는다고 타깃 오브젝트의 소스코드를 수정할 수는 없으니 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.
- AspectJ가 바이트코드 조작을 쓰는 이유?
  - 컨테이너 없이도 AOP 가능하기 때문이다. -> 스프링처럼 DI 컨테이너 없이도 적용 가능해서 스프링 환경이 아닌 곳에서도 AOP를 쓸 수 있다.
  - 프록시보다 훨씬 강력하고 유연하다. -> 록시는 기본적으로 메서드 호출 시점에만 부가기능을 넣을 수 있는데 바이트코드 조작은 더 넓게 적용이 가능하다. 

# 6.5.6 AOP 용어

- 타깃 : 타깃은 부가기능을 부여할 대상이다. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.

- 어드바이스 : 어드바이스는 타깃에게 제공할 부가기능을 담은 모듈이다. 어드바이스는 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다. 어드바이스는 여러 가지 종류가 있다. MethodInterceptor처럼 메소드 호출 과정에 전반적으로 참여하는 것도 있지만, 예외가 발생했을 때만 동작하는 어드바이스처럼 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.

- 조인 포인트 : 조인 포인트(join point)란 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다. 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 된다.

- 포인트컷 : 포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다. 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다. 그래서 포인트컷 표현식은 메소드의 실행이라는 의미인 execution으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 이용한다. 메소드는 클래스 안에 존재하는 것이기 때문에 메소드 선정이란 결국 클래스를 선정하고 그 안의 메소드를 선정하는 과정을 거치게 된다.

- 프록시 : 프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트다. DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여한다. 스프링은 프록시를 이용해 AOP를 지원한다.

- 어드바이저 : 어드바이저는 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저는 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈이다. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보 로 활용한다. 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고, 일반적인 AOP에서는 사용되지 않는다.

- 애스펙트 : OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다. 따라서 클래스와 같은 모듈 정의와 오브젝트와 같은 실체(인스턴스)의 구분이 특별히 없다. 두 가지 모두 애스펙트라고 불린다. 스프링의 어드바이저는 아주 단순한 애스펙트라고 볼 수도 있다.

## 6.5.7 AOP 네임스페이스

- 스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 애플리케이션의 로직을 담은 UserDao나 UserService 빈과는 성격이 다르다. 비즈니스 로직이나 DAO처럼 애플리케이션의 일부 기능을 담고 있는 것도 아니고, dataSource 빈처럼 DI를 통해 애플리케이션 빈에서 사용되는 것도 아니다.
- 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다. 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

- 자동 프록시 생성기 : 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI 하지도 않고 자신도 DI 되지 않으며 독립적으로 존재한다. 따라서 id도 굳이 필요하지 않다. 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.

- 어드바이스 : 부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.

- 포인트컷 : 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다. 코드를 작성할 필요는 없다.

- 어드바이저 : 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동 프록시 생성기에 의해 자동 검색돼서 사용된다.

- 이 중에서 부가기능을 담은 코드로 만든 어드바이스를 제외한 나머지 세 가지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다. 이 세 가지 클래스를 이용해 선언하는 빈은 AOP를 적용하면 반복적으로 등장하게 된다.


### AOP 네임스페이스

<img width="811" height="398" alt="image" src="https://github.com/user-attachments/assets/1dd0ac4b-8a15-413d-97c3-36c54452e6eb" />

- beans 는 기본 네임스페이스라서 <bean> 태그를 그냥 쓸 수 있다.
- aop 는 따로 등록해야 <aop:...> 태그를 쓸 수 있다. 


<img width="861" height="344" alt="image" src="https://github.com/user-attachments/assets/a0fb838a-42c8-465e-acc3-892540b55f3d" />

- 기존에는 AOP 적용하려면 자동프록시생성기, 포인트컷, 어드바이저 등 빈을 여러 개 직접 등록해야 했는데
  <br> aop 네임스페이스를 쓰면 필요한 것만 태그로 간단히 선언하면 된다. 



### 어드바이저 내장 포인트컷

<img width="689" height="163" alt="image" src="https://github.com/user-attachments/assets/c150d84e-6138-45e4-a6c2-166f18a0a6bd" />

- 기존방식인 그림 6-67에서는 포인트컷을 따로 정의하고, advisor가 그걸 ref로 참조했다면
- 6-68에서는 포인트컷을 따로 만들지 않고 <aop:advisor> 안에 직접 pointcut 표현식을 넣었다.
- 태그가 하나 줄어듦으로써 설정이 더 짧고 간단해졌다.

### 트랜잭션 속성

<img width="612" height="325" alt="image" src="https://github.com/user-attachments/assets/02638414-a81e-41ba-8dc4-52ec575d1b4e" />

- 트랜잭션 매니저에게 트랜잭션을 가져오거나 생성하도록 요청하고
- 타깃(핵심 기능) 메서드를 실행한다.
- 정상종료되면 트랜잭션 커밋이고
- 예외가 발생하면 트랜잭션 롤백 후 예외 다시 던져진다.
- 트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전달하는 DefaultTransactionDefinition은 용도가 무엇인지 알아보자.

# 6.6 트랜잭션 속성

### 격리수준

### 제한시간

### 읽기전용

## 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

### TransactionInterceptor

### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정

### tx 네임스페이스를 이용한 설정 방법

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.

### 공통된 메소드 이름 규칙을 토앻 최소한의 트랜잭션 어드바이스와 속성을 정의한다.

### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.

# 6.6.4 트랜잭션 속성 적용

### 트랜잭션 경계설정의 일원화

### 서비스 빈에 적용되는 포인트컷 표현식 등록

### 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록

### 트랜잭션 속성 테스트




