## 6.5.4 AOP란 무엇인가?

### 트랜잭션 서비스 추상화

- 트래잭션 경계 설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 생기는 문제점은 특정 트랜잭션 기술에 종속되는 코드가 돼 버린다는 것이다.
- JDBC의 로컬 트랜잭션 방식을 적용한 코드를 JTA를 이용한 글로벌분산 트랜재션 방식으로 바꾸려면 모든 트랜잭션 적용 코드를 수정해야한다는 문제점이 발생한다.
- 그래서 트랜잭션 적용이라는 추상적인 작업 내용은 유지한 채로 구체적인 구현 방법을 자유롭게 바꿀 수 있도록 '서비스 추상화 기법'을 적용한다.
- 트랜잭션 추상화란 인터페이스와 DI를 통해 무엇을 하는지 남기고 그것을 어떻게 하는지를 분리한 것이다.
  <br> 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경할 수 있게 됐다.
  

### 프록시와 데코레이터 패턴

- 트랜잭션은 거의 대부분의 비즈니스 로직을 담은 메소드에 필요하다는 점과
<br> 트랜잭션의 경계 설정을 담당하는 코드의 특성 때문에 단순환 추상화와 메소드 추출 방법으로는 더이상 제거할 방법이 없다는 점을 해결하기위해
<br> DI를 이용해 데코레이터 패턴을 적용한다.
<br> 클라이언트가 인터페이스와 DI를 통해 접근하도록 설계하고, 데코레이터 패턴을 적용해서, 비즈니스 로직을 담은 클래스와 코드에는 전혀 영향을 주지 않으면서 트랜잭션이라는 부가기능을 자유롭게 부여할 수 있는 구조를 만든다.
- 트랜잭션을 처리하는 코드는 일종의 데코레이터에 담겨서, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만든다.
- 그래서 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근할 수 있게 된다.
- 결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고, 독립적으로는 로직을 검증하는 고립된 단위 테스트를 만들 수도 있게 됐다.

### 다이내믹 프록시와 프록시 팩토리 빈

- 프록시 클래스 없이도 프록시 오브젝트를런타임 시에 만들어주는 JDK 다이내믹 프록시 기술을 적용하면 프록시 클래스 코드 작성의 부담도 덜고, 부가기능 부여코드가
<br> 여기저기 중복돼서 나타나는 문제도 일부 해결 할 수 있다. 일부 메소드에만 트랜잭션을 적용해야 하는 경우에는 메소드를 선정하는 패턴 등을 이용할 수도 있었다.
<br> 하지만 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로는 중복이 일어나는 문제를 해결하지 못했다.
- 그래서 JDK 다이내믹 프록시와 같은 프록시 기술을 추상화한 스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성방법에 DI를 도입했다.
- 내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가기능을 담은 어드바이스와 부가기능 선정 알고리즘을 담은 포인트컷은 프록시에서 분리될 수 있었고
<br> 여러 프록시에서 공유해서 사용할 수 있게 됐다. 

### 자동 프록시 생성 방법과 포인트컷

- 트랜잭선 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야한다는 부담이 남아 있었다.
- 이를 해결하기 위해 스프링 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동으로 프록시를 만들어주는 방법을 도입했다.
- 또한 프록시를 적용할 대상을 일일히 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다.
- 결국 트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다.

### 부가기능의 모듈화

- 트랜잭션 같은 부가기능을 어떻게 모듈로 분리 할 수 있을까?
- 코드를 분리하거나 한데 모으거나, 인터페이스를 도입하고 DI를 통해 런타임 시에 의존 관계를 만들어줌으로써 대부분의 문제를 해결 할 수 있었다. 하지만 이 트랜잭션 적용 코드는 기존에 써왔던 방법으로는 간단하게 분리해서 독립된 모듈로 만들 수가 없었다.
<br> 왜냐하면 트랜잭션 경계설정 같은 부가기능은 핵심 코드 여기저기에 끼어들어야 해서 단순 분리로는 모듈화가 어렵다.
- 그래서 이 문제를 해결하기 위해서 DI, 다이내믹 프록시, 데코레이터, 자동 프록시 생성, 포인트컷 같은 기법을 사용한다.
- 그 결과 트랜잭션 코드를 TransactionAdvice 같은 독립 모듈로 분리할 수 있고, 독립적으로 모듈화되어 있기때문에 이 코드는 중복되지 않으며 변경이 필요하면 한 곳만 수정하면 되며 핵심 기능 코드를 건들이지 않아도 된다.
- 결국 어드바이스와 포인트컷을 결합한 어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어 지게 됐다. 

### AOP : 애스펙트 지향 프로그래밍

- 애스펙트란?
- 그 자체로 애플리케이션의 핵심 기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중용한 한 가지 요소이고, 핵심 기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다,
- 애스펙트는 부가될 기능을 정의한 어드바이스와, 어드바이스를 어디에 적용할지를 결정하는 포인트컥으 함께 갖고 있다.
- 애스펙트는 단어 의미 그대로 애플리케이션을 구성하는 '한 가지 측면'이라고 생각할 수 있다.

<img width="433" height="186" alt="image" src="https://github.com/user-attachments/assets/78411b47-b650-461b-b231-005ed557ca2a" />

- 6-21 그림에서 왼쪽네모에는 핵심 기능 코드들이 들어있는걸 볼 수 있다. 부가기능1과 2가 여기저기 흩어져 있다.
- 하지만 AOP를 적용한 오른쪽 그림은 3차원으로 그러져 있는데, 위쪽에는 핵심 기ㄴㅇ 코드만 모여있고 옆과 아래의 '면'에는 부가기능들이 각각 애스펙트로 분리되어있는것을 볼 수 있다. 즉 부가기능들은 핵심코드에서 빠지고 '애스펙트'라는 독립적인 모듈이 따로 존재하게 된다
- 설계와 개발 관점에서는 핵심기능코드와 부가기능 코드를 분리해서 작성이 가능하고
- 런타임 관점에서는 실제 부가기능이 필요한 시점에 자동으로 결합되어 함께 실행된다.

- 이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을
  <br> '애스펙트 지향 프로그래밍(AOP)'이라고 한다.
- AOP는 OOP를 대체하는 게 아니라, OOP가 핵심 기능을 깔끔하게 유지하도록 도와주는 보조 기술이다.
- 부가기능을 “다른 관점(측면)”으로 따로 설계/개발하게 해줘서 핵심 로직을 침범하지 않게 만든다.
- 예를 들어 트랜잭션만 다루고 싶으면 TransactionAdvice만 개발하면 되고 적용 대상은 transactionPointcut 설정만 신경 쓰면 된다.
- 이렇게 애플리케이션을 특정하 관점을 기준으로 바라볼 수 있게 해준다는 의미에서 AOP를 관점 지향 프로그래밍이라고도 한다.


## 6.5.5 AOP 적용기술

### 프록시를 이용한 AOP

- 스프링은 IoC/DI 컨테이너 + 다이내믹 프록시 + 데코레이터/프록시 패턴 + 자동 프록시 생성 + 빈 후처리 같은 여러 기술을 조합해서 AOP를 구현한다.
- 그중 가장 핵심은 ‘프록시’를 이용하는 것이다.
- 스프링 AOP는 타깃의 메서드 호출 과정에 프록시가 끼어들어 부가기능을 실행하도록 만든다. 그래서 특별한 JVM 설정이나 별도 환경 없이도 스프링 컨테이너만 있으면 AOP를 쓸 수 있다.
- Advice는 MethodInterceptor 같은 인터페이스로 구현되며, 프록시가 호출 정보를 전달받아 타깃 메서드를 실행하기 전/후로 부가기능을 적용한다.
- 독립적으로 개발한 부가기능 모듈을 다양한 타깃 오브젝트의 메소드에 다이내믹하게 적용해주기 위해 가낭 중요한 역할을 맡고 있는게 프록시다. 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.
  
### 바이트코드 생성과 조작을 통한 AOP

- 프록시 방식이 아닌 AOP도 있다. AOP 기술의 원조이면서 가장 강력한 AOP 프레임워크로 꼽히는 AspetJ는 프록시를 사용하지 않는 대표적인 AOP 기술이다.
- AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용한다.
- 부가기능을 넣는다고 타깃 오브젝트의 소스코드를 수정할 수는 없으니 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.
- AspectJ가 바이트코드 조작을 쓰는 이유?
  - 컨테이너 없이도 AOP 가능하기 때문이다. -> 스프링처럼 DI 컨테이너 없이도 적용 가능해서 스프링 환경이 아닌 곳에서도 AOP를 쓸 수 있다.
  - 프록시보다 훨씬 강력하고 유연하다. -> 록시는 기본적으로 메서드 호출 시점에만 부가기능을 넣을 수 있는데 바이트코드 조작은 더 넓게 적용이 가능하다. 

# 6.5.6 AOP 용어

- 타깃 : 타깃은 부가기능을 부여할 대상이다. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라서는 다른 부가기능을 제공하는 프록시 오브젝트일 수도 있다.

- 어드바이스 : 어드바이스는 타깃에게 제공할 부가기능을 담은 모듈이다. 어드바이스는 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수도 있다. 어드바이스는 여러 가지 종류가 있다. MethodInterceptor처럼 메소드 호출 과정에 전반적으로 참여하는 것도 있지만, 예외가 발생했을 때만 동작하는 어드바이스처럼 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.

- 조인 포인트 : 조인 포인트(join point)란 어드바이스가 적용될 수 있는 위치를 말한다. 스프링의 프록시 AOP에서 조인 포인트는 메소드의 실행 단계뿐이다. 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 된다.

- 포인트컷 : 포인트컷이란 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈을 말한다. 스프링 AOP의 조인 포인트는 메소드의 실행이므로 스프링의 포인트컷은 메소드를 선정하는 기능을 갖고 있다. 그래서 포인트컷 표현식은 메소드의 실행이라는 의미인 execution으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 이용한다. 메소드는 클래스 안에 존재하는 것이기 때문에 메소드 선정이란 결국 클래스를 선정하고 그 안의 메소드를 선정하는 과정을 거치게 된다.

- 프록시 : 프록시는 클라이언트와 타깃 사이에 투명하게 존재하면서 부가기능을 제공하는 오브젝트다. DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가기능을 부여한다. 스프링은 프록시를 이용해 AOP를 지원한다.

- 어드바이저 : 어드바이저는 포인트컷과 어드바이스를 하나씩 갖고 있는 오브젝트다. 어드바이저는 어떤 부가기능(어드바이스)을 어디에(포인트컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈이다. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보 로 활용한다. 어드바이저는 스프링 AOP에서만 사용되는 특별한 용어이고, 일반적인 AOP에서는 사용되지 않는다.

- 애스펙트 : OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈이다. 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재한다. 따라서 클래스와 같은 모듈 정의와 오브젝트와 같은 실체(인스턴스)의 구분이 특별히 없다. 두 가지 모두 애스펙트라고 불린다. 스프링의 어드바이저는 아주 단순한 애스펙트라고 볼 수도 있다.

## 6.5.7 AOP 네임스페이스

- 스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 애플리케이션의 로직을 담은 UserDao나 UserService 빈과는 성격이 다르다. 비즈니스 로직이나 DAO처럼 애플리케이션의 일부 기능을 담고 있는 것도 아니고, dataSource 빈처럼 DI를 통해 애플리케이션 빈에서 사용되는 것도 아니다.
- 이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다. 스프링의 프록시 방식 AOP를 적용하려면 최소한 네 가지 빈을 등록해야 한다.

- 자동 프록시 생성기 : 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록한다. 다른 빈을 DI 하지도 않고 자신도 DI 되지 않으며 독립적으로 존재한다. 따라서 id도 굳이 필요하지 않다. 애플리케이션 컨텍스트가 빈 오브젝트를 생성하는 과정에 빈 후처리기로 참여한다. 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능을 담당한다.

- 어드바이스 : 부가기능을 구현한 클래스를 빈으로 등록한다. TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용한다.

- 포인트컷 : 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 된다. 코드를 작성할 필요는 없다.

- 어드바이저 : 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용한다. 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능은 없다. 자동 프록시 생성기에 의해 자동 검색돼서 사용된다.

- 이 중에서 부가기능을 담은 코드로 만든 어드바이스를 제외한 나머지 세 가지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것이다. 이 세 가지 클래스를 이용해 선언하는 빈은 AOP를 적용하면 반복적으로 등장하게 된다.


### AOP 네임스페이스

<img width="811" height="398" alt="image" src="https://github.com/user-attachments/assets/1dd0ac4b-8a15-413d-97c3-36c54452e6eb" />

- beans 는 기본 네임스페이스라서 <bean> 태그를 그냥 쓸 수 있다.
- aop 는 따로 등록해야 <aop:...> 태그를 쓸 수 있다. 


<img width="861" height="344" alt="image" src="https://github.com/user-attachments/assets/a0fb838a-42c8-465e-acc3-892540b55f3d" />

- 기존에는 AOP 적용하려면 자동프록시생성기, 포인트컷, 어드바이저 등 빈을 여러 개 직접 등록해야 했는데
  <br> aop 네임스페이스를 쓰면 필요한 것만 태그로 간단히 선언하면 된다. 



### 어드바이저 내장 포인트컷

<img width="689" height="163" alt="image" src="https://github.com/user-attachments/assets/c150d84e-6138-45e4-a6c2-166f18a0a6bd" />

- 기존방식인 그림 6-67에서는 포인트컷을 따로 정의하고, advisor가 그걸 ref로 참조했다면
- 6-68에서는 포인트컷을 따로 만들지 않고 <aop:advisor> 안에 직접 pointcut 표현식을 넣었다.
- 태그가 하나 줄어듦으로써 설정이 더 짧고 간단해졌다.

### 6.6 트랜잭션 속성

<img width="612" height="325" alt="image" src="https://github.com/user-attachments/assets/02638414-a81e-41ba-8dc4-52ec575d1b4e" />

- 트랜잭션 매니저에게 트랜잭션을 가져오거나 생성하도록 요청하고
- 타깃(핵심 기능) 메서드를 실행한다.
- 정상종료되면 트랜잭션 커밋이고
- 예외가 발생하면 트랜잭션 롤백 후 예외 다시 던져진다.
- 트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전달하는 DefaultTransactionDefinition은 용도가 무엇인지 알아보자.

# 6.6 트랜잭션 정의

- 트랜잭션이라고 모두 같은 방식으로 동작하는 것은 아니다.
- 트랜잭션 경계 안에서 진행된 작업은 commit()을 통해 모두 성공하거나 rollback()을 통해 모두 취소돼야 한다.
- 그런데 이 밖에도 트랜잭션의 동작방식을 제어할 수 있는 몇가지 조건이 있다.
- DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의하고 있다. 

### 트랜잭션 전파

- 트랜잭션 전파 : 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을때, 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식.

<img width="397" height="202" alt="image" src="https://github.com/user-attachments/assets/fac8f847-58b5-485c-b95b-bcad053f2898" />

- 6-22 그림을 설명하자면 A는 자기 트랜잭션을 시작하고 있는데 A가 처리 중간에 B.method()를 호출한다. 이때 B도 트랜잭션이 필요한 코드라고 가정해보면
- 가능한 선택지 2개가 있다.
  - 1. B가 A 트랜잭션에 참여한다. B는 새 트랜잭션을 만들지 않고 A 트랜잭션 안에 들어가서 같이 실행된다. 그러면 A나 B에서 예외 발생해서 둘 다 롤백된다. A와 B가 하나의 트랜잭션으로 묶인다.
  - 2. B가 독립적인 새 트랜잭션을 만든다. B는 A와 관계없이 자기 트랜잭션을 새로 시작한다. 그러면 B 트랜잭션이 끝나면 B의 트랜잭션은 독자적으로 커밋되거나 롤백된다. 이후에 A에서 예외가 발생해 A가 롤백되더라도 B에서 이미 종료된 트랜잭션의 결과에는 영향을 주지 않는다. 

- 즉 이미 실행 중인 트랜잭션이 있을 때, 그 안에서 또 다른 트랜잭션이 필요한 코드(B)가 호출되면 B를 어떤 트랜잭션 안에서 실행할지 결정하는 규칙이 트랜잭션 전파이다.

- 다음 3가지의 트랜잭션 전파속성이다.

- PROPAGATION_REQUIRED
  - 가장 많이 쓰는 기본 전파 옵션이며
  <br> 진행 중인 트랜잭션이 없으면 새로 시작한다.
  <br> 이미 진행 중인 트랜잭션이 있으면 그 트랜잭션에 참여한다.
  - A, B 둘 다 REQUIRED면 A만 단독 트랜잭션, B만 단독 트랜잭션, A 안에서 B 호출, B 안에서 A 호출 네 가지 다 가능하고 한 트랜잭션으로 묶여 동작하기 쉽다.
 
- PROPAGATION_REQUIRES_NEW
  - 항상 독립적인 트랜잭션을 새로 만든다. 기존 트랜잭션이 있든 없든 무조건 새 트랜잭션 시작한다.
 
- PROPAGATION_NOT_SUPPORTED
  - 현재 트랜잭션이 있어도 무시하고 트랜잭션 없이 실행한다.
  - 그럼 왜 쓸까? -> 보통 트랜잭션 AOP는 여러 메서드에 넓게 적용되는데 특정 메서드만 트랜잭션 적용 제외하고 싶을 수 있다. 포인트컷으로 빼는 건 복잡해질 수 있으니까,그 메서드 전파 속성을 NOT_SUPPORTED로 줘서 트랜잭션 없이 실행하게 만드는 편이 낫다.

- 스프링의 getTransaction()은 무조건 새 트랜잭션을 시작하는 게 아니라, 전파 속성과 현재 트랜잭션 존재 여부에 따라 새로 만들기도 하고 기존 트랜잭션에 참여하기도 한다. 그리고 기존 트랜잭션에 참여한 경우엔, 참여한 쪽은 끝에서 커밋을 못하고 최초 트랜잭션 경계가 정상 종료돼야 커밋될 수 있다.


### 격리수준

- 모든 DB 트랜잭션은 격리수준(isolation level)을 갖고 있어야 한다. 서버환경에서는 여러 개의 트랜잭션이 동시에 진행될 수 있다. 가능하다면 모든 트랜잭션이 순차적으로 진행돼서 다른 트랜잭션의 작업에 독립적인 것이 좋겠지만, 그러자면 성능이 크게 떨어질 수밖에 없다. 따라서 적절하게 격리수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요하다.
- 격리수준은 기본적으로 DB에 설정돼 있지만 JDBC 드라이버나 DataSource 등에서 재설정할 수 있고, 필요하다면 트랜잭션 단위로 격리수준을 조정할 수 있다. DefaultTransactionDefinition에 설정된 격리수준은 ISOLATION_DEFAULT다. 이는 DataSource에 설정되어 있는 디폴트 격리수준을 그대로 따른다는 뜻이다.
- 기본적으로는 DB나 DataSource에 설정된 디폴트 격리수준을 따르는 편이 좋지만, 특별한 작업을 수행하는 메소드의 경우는 독자적인 격리수준을 지정할 필요가 있다.

### 제한시간

- 트랜잭션을 수행하는 제한시간(timeout)을 설정할 수 있다. DefaultTransactionDefinition의 기본 설정은 제한시간이 없는 것이다.
- 제한시간은 트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미가 있다.

### 읽기전용

- 읽기전용(read only)으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있다. 또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있다.
- TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션의 동작방식을 제어할 수 있다.
 트랜잭션 정의를 수정하려면 어떻게 해야 할까? TransactionDefinition 오브젝트를 생성하고 사용하는 코드는 트랜잭션 경계설정 기능을 가진 TransactionAdvice다. 트랜잭션 정의를 바꾸고 싶다면 디폴트 속성을 갖고 있는 DefaultTransactionDefinition을 사용하는 대신 외부에서 정의된 TransactionDefinition 오브젝트를 DI 받아서 사용하도록 만들면 된다. TransactionDefinition 타입의 빈을 정의해두면 프로퍼티를 통해 원하는 속성을 지정해줄 수 있다.
- 하지만 이 방법으로 트랜잭션 속성을 변경하면 TransactionAdvice를 사용하는 모든 트랜잭션의 속성이 한꺼번에 바뀐다는 문제가 있다. 그렇다면 원하는 메소드만 선택해서 독자적인 트랜잭션 정의를 적용할 수 있는 방법은 없을까?

## 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

- 메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야한다. 마치 초기에 TransactionHandler에서 메소드 이름을 이용해 트랜잭션 적용 여부를 판단했던 것과 비슷한 방식을 사용하면 된다. 메소드 이름 패턴에 따라 다른 트랜잭션 정의가 적용되도록 만드는 것이다.

### TransactionInterceptor

- 스프링에는 이미 트랜잭션 경계설정용 어드바이스가 있다. 그게 바로 'TransactionInterceptor'이다. 
- TransactionInterceptor는 크게 두 프로퍼티를 가진다.
  <br> 첫번째는 PlatformTransactionManager, 두번째는 Properties transactionAttributes 이다.
- transactionAttributes 안에 들어가는 트랜잭션 속성은 TransactionDefinition보다 확장된 개념인 TransactionAttribute로 정의된다.
  <br> TransactionDefinition의 4가지 속성인 전파, 격리, timeout, readOnly 이외에도 rollbackOn()이라는 메서드를 추가로 가진다.

- 스프링 TransactionInterceptor 기본 정책에는 두 가지 예외처리 방식이 있다. 
  첫번째는 런타임 예외가 발생하면 트랜잭션은 롤백된다는 것이고 두번째는 체크 예외가 생기면 비즈니스 의미가 있을 수 있으니 기본적으로 트랜잭션을 커밋한다는 것이다.
- 그런데 TransactionInterceptor가 예외처리 기본 원칙을 따르지 않는 경우가 있을 수 있다.
- 그래서 rollbackOn()을 통해 기본원칙과 다른 예외처리가 다른 예외처리가 가능하게 한다.

  
### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정

<img width="658" height="169" alt="image" src="https://github.com/user-attachments/assets/16c5565e-b1b9-43c5-bc63-01bfcda0aeea" />

- 트랜잭션 속성은 위와 같은 문자열로 정리할 수 있다.
- 이 중에서 트랜잭션 전파 항목만 필수이고 나머지는 다 생략 가능하다.
- Properties 타입의 transactionAttributes 프로퍼티는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션이다. 

- TransactionInterceptor의 transactionAttributes를 이용하면, 메서드 이름 패턴만으로도 메서드별 트랜잭션 속성을 간단하게 다양하게 설정할 수 있다.

<img width="656" height="352" alt="image" src="https://github.com/user-attachments/assets/2d620e75-0844-4f62-b8d8-b5bbfb30d151" />

- 위의 그림에서 하나를 예시로 들아보자. 
<br> 이름이 get 으로 시작하는 모든 메서드들은 트랜잭션이 이미 있으면 거기 참여하고 없으면 새로 만들되, 읽기 전용(readOnly) 으로 만들고, 30초 안에 끝내라(timeout 30)라는 말이다.

- 하나의 메서드가 여러 패턴에 매칭될 수 있는데 그땐 가장 정확히 일치하는 패턴이 우선 적용된다.


### tx 네임스페이스를 이용한 설정 방법

- TransactionInterceptor 설정을 tx 태그로 더 간단하게 할 수 있다
- 원래는 TransactionInterceptor 빈을 직접 만들고 transactionAttributes 프로퍼티에 문자열로 속성을 넣었는데, 스프링은 이걸 더 편하게 하라고 tx 스키마 전용 태그를 제공한다.

- 트랜잭션 속성이 속성(attribute) 형태라서 읽기 쉽고 실수 적다. XML 자동완성 가능을 통해 편하게 작성할 수 있고 값들이 스키마에 정의되어 있어 오타도 검증 가능하다. 
- 그래서 <bean> 등록보다 tx 태그 사용이 권장된다.

## 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

- 트랜잭션 적용 대상 메서드(후보)를 고르는 건 포인트컷이 한다.
- 그리고 선택된 메서드들에 대해 트랜잭션이 어떤 방식으로 동작할지(전파, 격리, timeout, readOnly 등) 는 트랜잭션 속성으로 결정됨.
- 어드바이저/어드바이스/포인트컷 설정 방식 자체는 그대로고,결국 설정해야 할 핵심은 두 가지다.
- expression에 넣을 포인트컷 표현식과 <tx:attributes>에 넣을 트랜잭션 속성이다.
- 다음은 포인트컷 표현식과 트랜잭션 속성을 정의할 때 따르면 좋은 몇가지 전략이다.


### 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
- 트랜잭션은 “특정 메서드 하나”만 걸지 말고, 보통 서비스 계층 전체에 거는 게 좋다
- 지금까지는 포인트컷 설명 때문에 upgradeLevels() 같은 한 메서드만 트랜잭션을 걸었지만, 실제로는 비즈니스 로직을 담은 클래스(UserService 등) 의 메서드들은 대부분 트랜잭션 대상이 되는 게 바람직하다.

- add() 같은 메서드도 트랜잭션 적용대서이어야 한다. 다른 DB 작업이 추가될 가능성도 높고, 상위 트랜잭션에 참여해야 할 가능성도 높기 때문이다.

- 조회 메서드도 트랜잭션 걸면 좋다 (readOnly로)

- 포인트컷은 메서드 단위로 너무 세밀하게 잡지 말고 “타입/빈 기준”으로 크게 잡는것이 좋다.
  <br> 가능하면 클래스보다는 인터페이스 타입 기준으로 타입 패턴을 적용하자. 인터페이스는 클래스에 비해 변경 빈도가 적고 일정한 패턴을 유지하기 쉽기 때문이다.

- bean() 표현식으로 “빈 이름”으로 트랜잭션 대상 선택도 가능하다. 클래스/인터페이스 이름 규칙 잡기 어려울 때 유용하다. 하지만이름이 비슷한 빈이 있으면 주의하도록 하자.

### 공통된 메소드 이름 규칙을 토앻 최소한의 트랜잭션 어드바이스와 속성을 정의한다.

- 트랜잭션 속성은 그렇게 종류가 많지 않다
- 그래서 몇 가지 대표 속성만 정해놓고 그에 맞는 메서드 이름 규칙을 만들면 어드바이스 하나만으로 서비스 전부에 트랜잭션 적용 가능하다.
- 가장 단순하게는 모든 메서드에 기본 트랜잭션을 적용하면 된다
- 그 다음 단계: 조회 메서드에 readOnly 를 적용한다.

- 예외적인 트랜잭션 패턴은 따로 빼는 게 좋다.
- 일반 서비스 로직은 위 규칙으로 처리하고, 배치 작업처럼 성격이 다른 클래스는 별도의 advice와 pointcut으로 분리해서 적용해야 관리가 쉽기 때문이다. 

### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않는다.

- 프록시 기반 AOP는 프록시를 통해 호출될 때만 적용된다. 그래서 같은 클래스 안에서 자기 메서드를 내부 호출하면 트랜잭션이 적용 안된다.
- 스프링 AOP 구조를 보면 첫번째로 클라이언트가 호출할 때는 프록시 객체를 먼저 거친다. 이히ㅜ에 프록시가 부가기능(트랜잭션 시작/종료)을 적용한 뒤 진짜 타깃 메서드를 호출한다.
- 근데 타깃 객체가 자기 내부에서 자기 메서드를 부르면 호출이 프록시를 거치지 않고 그냥 this.update() 처럼 내부 호출이 된다. 그래서 트랜잭션 부가기능이 실행되지 않는다
- 예를 들어 update()에 REQUIRES_NEW 이라는 속성을 줘도, delete() 안에서 update()를 부르면 update()는 새 트랜잭션을 못 만들고 그냥 delete() 트랜잭션에 묶여버린다. 
- 즉,내가 의도한 트랜잭션 전파 전략이 무시될 수 있다.
- 해결 방법에는 두가지가 있다.
  <br> 첫번재는 프록시를 다시 가져와서 호출하는 것이다. 스프링 API로 내 프록시를 다시 가져와서
프록시를 통해 update()를 호출하게 만드는 방식이다. 
  <br> 하지만 코드가 더러워지고 비즈니스 로직이 스프링/프록시에 의존하게 된다는 단점이 있다. 
  <br> 두번째는 AspectJ 방식이다.
  <br> AspectJ는 프록시가 아니라 클래스 로딩 시점/컴파일 시점에 바이트코드를 직접 바꿔서 내부 호출도 AOP 적용 가능하게 한다. 그래서 self-invocation 문제가 사라짐.
  <br> 하지만 설정/환경이 더 복잡해진다는 단점이 있다. 

# 6.6.4 트랜잭션 속성 적용

### 트랜잭션 경계설정의 일원화

- 트랜잭션 경계는 “서비스 계층”에 두는 게 원칙이다. 트랜잭션은 여러 DAO 작업을 하나로 묶어서 처리하는 게 목적이라서,비즈니스 로직이 있는 Service 계층의 메서드가 트랜잭션 경계로 가장 적절하다.
- DAO를 직접 호출하면 트랜잭션 통제가 깨질 수 있다. 그래서 서비스 계층을 트랜잭션 경계로 정했다면, 다른 계층/모듈에서 DAO를 직접 호출하지 말고 반드시 Service를 거쳐서 호출해야 한다. 왜냐하면 Service를 거쳐야 트랜잭션이 적용되고 부가기능(AOP)이 적용되기 때문이다.
- 구조를 단순하게 하면 Service 없이 DAO가 경계가 될 수도 있다
- UserDao 메서드들을 UserService로 끌어올린다. 이게 일원화인데
  <br> UserService 인터페이스에 4개 메서드를 추가하고 UserServiceImpl에서 그냥 userDao로 위임하게 만든다.

### 서비스 빈에 적용되는 포인트컷 표현식 등록

- 원래는 upgradeLevels() 메서드에만 트랜잭션을 적용했는데, 이제는 모든 비즈니스 로직 Service 빈 전체에 트랜잭션이 적용되도록 포인트컷을 수정한다.

### 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록

- 기존에 직접 만든 TransactionAdvice 클래스 대신, 스프링이 기본으로 제공하는 TransactionInterceptor를 쓰는 방식으로 바꾼다.
- 트랜잭션 속성(전파, readOnly 등)은 메서드 이름 패턴으로 지정하는 게 일반적이고 편하다.

- 이미 aop 스키마를 쓰는 상황이면, 트랜잭션도 <bean>으로 복잡하게 쓰지 말고
  <br> tx 네임스페이스(스키마)를 추가해서 <tx:advice> 태그로 작성하는 게 더 깔끔하다.
  <br> <bean> 설정보다 훨씬 읽기 쉽고 간단하며 transactionManager, propagation 같은 값도 태그로 명확하게 보인다. 또한 propagation="REQUIRED" 같은 값은 스키마에 enum으로 정의돼서 오타 검증도 가능하다. 

### 트랜잭션 속성 테스트

- get* 메서드에 readOnly=true 트랜잭션을 걸어두면 그 안에서 update 같은 쓰기 작업을 하면 예외가 터진다.-를 보여주기 위한 테스트이다.
- 테스트를 통해 전용 스키마의 태그를 사용해서 정의한 트랜잭션 AOP가 바르게 동작하고, 메소드에 따라 적절한 트랜잭션 속성이 부여도고 있음을 확인할 수 있다. 

<img width="440" height="197" alt="image" src="https://github.com/user-attachments/assets/927bc6bc-df9b-4623-a1ed-f85cbcf05326" />

<img width="426" height="129" alt="image" src="https://github.com/user-attachments/assets/40e3e9c2-ba8f-4e6d-bf64-8b2c18781335" />


- 테스트를 하는 이유는 <tx:attributes>에서 get* 을 적용해 읽기 전용 트랜잭션 적용으로 했기 때문에 getAll() 같은 조회 메서드 안에서는 쓰기 작업이 막혀야 한다- 라는걸 보여주기 위함이다.






