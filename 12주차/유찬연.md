# AOP란 무엇인가?

지금까지 비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리.

### 트랜잭션 서비스 추상화

트랜잭션 경계 설정 코드를 비즈니스 로직을 담은 코드에 넣으면서 특정 트랜잭션 기술에 종속되는 코드가 됨.

이를 해결하기 위한 방법이 트랜잭션 추상화.

트랜잭션 추상화란 인터페이스와 DI를 통해 무엇을 하는 지는 남기고, 그것을 어떻게 하는 지를 분리한 것.

덕분에 더 이상 비즈니스 로직 코드에는 영향을 주지 않고 독립적으로 변경 가능하게 됨.

### 프록시와 데코레이터 패턴

트랜잭션을 어떻게 다룰 것인가는 추상화를 통해 코드에서 제거했지만, 여전히 비즈니스 로직 코드에는 트랜잭션을 적용하고 있음.

이를 해결하기 위해 도입한 것은 DI를 이용한 데코레이터 패턴 적용.

트랜잭션을 처리하는 일종의 데코레이터에 담겨서, 클라이언트와 비즈니스 로직을 담은 타깃 클래스 사이에 존재하도록 만듦.

그래서 클라이언트가 일종의 대리자인 프록시 역할을 하는 트랜잭션 데코레이터를 거쳐서 타깃에 접근 가능하게 됨.

결국 비즈니스 로직 코드는 트랜잭션과 같은 성격이 다른 코드로부터 자유로워졌고, 독립적으로 로직을 검증하는 고립된 단위 테스트 작성도 가능하게 됨.

### 다이내믹 프록시와 프록시 팩토리 빈

프록시를 이용하여 비즈니스 로직 코드에서 트랜잭션 코드는 모두 제거 가능했지만, 비즈니스 로직 인터페이스의 모든 메소드마다 트랜잭션 기능을 부여하는 코드를 넣어 프록시 클래스를 만드는 작업이 오히려 문제가 됨.

이를 해결하기 위해 JDK 다이내믹 프록시 기술을 적용.

덕분에 프록시 클래스 코드 작성의 부담도 덜고, 부가 기능 부여 코드가 중복되는 문제도 일부 해결했지만, 동일한 기능의 프록시를 여러 오브젝트에 적용할 경우 오브젝트 단위로 중복이 일어나는 문제는 해결 x.

스프링의 프록시 팩토리 빈을 이용해서 다이내믹 프록시 생성 방법에 DI를 도입.

내부적으로 템플릿/콜백 패턴을 활용하는 스프링의 프록시 팩토리 빈 덕분에 부가 기능을 담은 어드바이스와 부가 기능 선정 알고리즘을 담은 포인트 컷은 프록시에서 분리될 수 있었고 여러 프록시에서 공유해서 사용 가능하게 됨.

### 자동 프록시 생성 방법과 포인트컷

여전히 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 한다는 부담이 남아있음.

이를 해결하기 위해서 스프링의 컨테이너의 빈 생성 후처리 기법을 활용해 컨테이너 초기화 시점에서 자동을 프록시를 만들어주는 방법을 도입.

프록시를 적용할 대상을 일일이 지정하지 않고 패턴을 이용해 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용.

처음에는 클래스와 메소드 선정 로직을 담은 코드를 직접 만들어서 포인트컷으로 사용했지만, 최종적으로는 포인트컷 표현식이라는 좀 더 편리하고 깔끔한 방법을 활용해서 간단한 설정만으로 적용 대상을 손쉽게 선택 가능하게 됨.

### 부가 기능의 모듈화

관심사가 같은 코드를 분리해 한 곳에 모으는 것은 소프트웨어 개발의 가장 기본이 되는 원칙.

관심사가 같은 코드를 객체 지향 설계 원칙에 따라 분리하고, 서로 낮은 결합도를 가진 채로 독립적이고 유연하게 확장할 수 있는 모듈로 만드는 것이 지금까지의 작업.

지금까지 대부분의 문제들은 코드를 분리하고, 한 곳에 모으고, 인터페이스를 도입하고, DI를 통해 런타임 시 의존 관계를 만들어줌으로써 대부분의 문제를 해결 가능했지만, 트랜잭션 적용 코드에서는 적용이 불가능했음.

트랜잭션 경계 설정 기능은 다른 모듈의 코드에 부가적으로 부여되는 기능이기 때문.

트랜잭션 경계 설정 기능을 한 곳에 모으기 위해서는 특별한 기법이 필요했고 지금까지 살펴보았던 DI, 데코레이터 패턴, 다이내믹 프록시, 오브젝트 생성 후처리, 자동 프록시 생성, 포인트컷과 같은 기법이 대표적인 방법들.

덕분에 부가 기능인 트랜잭션 경계 설정 기능은 TransactionAdvice라는 이름으로 모듈화됨.

독립적으로 모듈화되어 있기 때문에 이 코드는 중복되지 않으며, 변경이 필요하면 한 곳만 수정하면 됨.

또한 포인트 컷이라는 방법을 통해 부가 기능을 부여할 대상을 선정 가능.

결국 지금까지 해온 모든 작업은 핵심 기능에 부여되는 부가 기능을 효과적으로 모듈화하는 방법을 찾는 것이었고, 어드바이스와 포인트 컷을 결합한 어드바이저가 단순하지만 이런 특성을 가진 모듈의 원시적인 형태로 만들어짐.

## AOP: 애스펙트 지향 프로그래밍

부가 기능 모듈화 작업은 기존의 객체 지향 설계 패러다임과는 구분되는 새로운 특성이 존재.

그래서 이런 부가 기능 모듈을 객체 지향 기술에서 주로 사용되는 오브젝트와는 다르게 애스펙트(Aspect)라고 함.

애스펙트란 그 자체로 애플리케이션의 핵심 기능을 담고 잇지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심 기능에 부가되어 의미를 갖는 특별한 모듈.

애스펙트는 부가될 기능을 정의한 코드인 어드바이스와 어드바이스를 어디에 적용할 지를 결정하는 포인트컷을 함께 가짐.

애스펙트는 그 단어의 의미대로 애플리케이션을 구성하는 한 가지 측면이라고 생각할 수 있음.

<img width="636" height="292" alt="image" src="https://github.com/user-attachments/assets/64ee6e70-3684-4b44-b869-efb4d4f6e4a0" />

위의 그림에서 왼쪽은 애스펙트로 부가 기능을 분리하기 전의 상태.

핵심 기능은 깔끔한 설계를 통해 모듈화되어 있지만, 부가 기능이 핵심 기능의 모듈에 침투해 들어가면서 설계와 코드가 모두 지저분해짐.

오른쪽 그림은 이렇게 핵심 기능 코드 사이에 침투한 부가 기능을 독립적인 모듈인 애스펙트로 구분해낸 것.

2차원 평면 구조에서는 해결할 수 없었지만, 3차원의 다면체 구조에서는 각각 성격이 다른 부가 기능을 다른 면에 존재하도록 함.

이렇게 독립된 측면에 존재하는 애스펙트로 분리한 덕에 핵심 기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 됨.

물론 런타임 시에는 왼쪽의 그림처럼 각 부가 기능 애스펙트는 자기가 필요한 위치에 동적으로 참여하게 될 것.

이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 AOP라고 함.

AOP는 OOP를 돕는 보조적인 기술이지 OOP를 대체하는 새로운 개념이 아님.

AOP는 결국 애플리케이션을 다양한 측면에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 만들어 주는 것.

애플리케이션을 사용자 관리라는 핵심 로직 대신 트랜잭션 경계 설정이라는 관점에서 바라보고 그 부분에 집중해서 설계하고 개발 할 수 있게 됨.

트랜객션 기술의 적용에만 주목하고 싶다면 TransactionAdvice, 그 대상을 결정해주는 transactionPointct 빈의 설정만 신경쓰면 됨.

# AOP 적용 기술

## 프록시를 이용한 AOP

스프링은 IoC/DI 컨테이너와 다이내믹 프록시, 데코레이터 패턴, 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트의 후처리 조작 기법 등의 다양한 기술을 조합해 AOP를 지원.

그 중 가장 핵심은 프록시를 이용했다는 것.

프록시로 만들어서 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해서 부가 기능을 제공해주도록 만듬.

따라서 스프링 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구하지 않음.

서버 환경이라면 가장 기초적인 서블릿 컨테이너만으로도 충분하며, 원한다면 독립형 애플리케이션에서도 사용 가능.

스프링의 AOP의 부가 기능을 담은 어드바이스가 적용되는 대상은 오브젝트의 메소드.

프록시 방식을 사용했기 때문에 메소드 호출 과정에 참여해서 부가 기능을 제공.

타깃의 메소드를 호출하는 전후에 다양한 부가 기능을 제공 가능.

독립적으로 개발한 부가 기능 모듈을 다양한 타깃 오브젝트의 메소드에 동적으로 적용해주기 위해 가장 중요한 역할을 맡고 있는 게 프록시.

그래서 스프링 AOP는 프록시 방식의 AOP라고 함.

## 바이트 코드 생성과 조작을 통한 AOP

반면 프록시 방식이 아닌 AOP도 존재 → AspectJ.

스프링도 AspectJ의 뛰어난 포인트컷 표현식을 차용해서 사용할 만큼 매우 성숙하고 발전한 AOP 기술.

AspectJ는 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트에 부가 기능을 직접 넣어주는 직접적인 방법을 사용.

부가 기능을 넣는다고 타깃 오브젝트의 소스 코드를 수정할 수는 없으니, 컴파일된 타깃의 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트 코드를 조작하는 복잡한 방법을 사용.

트랜잭션 코드가 UserService 클래스에 비즈니스 로직과 함께 있었을 때처럼 만들어버리는 것.

왜 Aspectj는 프록시 같은 방법이 아닌 컴파일된 클래스 파일 수정이나 바이트 코드 조작과 같은 복잡한 방법을 사용할까?

- 바이트 코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아 잗동 프록시 생성 방식을 사용하지 않아도 AOP를 적용할 수 있기 때문.
- 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문.

프록시를 AOP의 핵심 메커니즘으로 사용하면 부가 기능을 부옇라 대상은 클라이언트가 호출할 때 사용하는 메소드로 제한되지만, 바이트 코드를 직접 조작하여 AOP를 적용하면 오브젝트의 생성, 필드 값의 조회와 조작, 스태틱 초기화 등의 다양한 작업에 부가 기능 부여 가능.

타깃 오브젝트가 생성되는 순간 부가 기능 부여도 가능.

물론 대부분의 부가 기능은 프록시 방식을 사용해 메소드의 호출 시점에 부여하는 것으로도 충분.

심지어 AspectJ 같은 고급 AOP 기술은  바이트 코드 조작을 위해 JVM의 실행 옵션을 변경하거나, 별도의 바이트 코드 컴파일러를 사용하거나, 특별한 클래스 로더를 사용하게 하는 등의 번거로운 작업이 필요.

일반적인 AOP를 적용하는 경우 → 프록시 방식의 스프링 AOP.

특별한 AOP 요구사항 발생시 적용하는 경우 → AspectJ.

스프링의 AOP를 기본적으로 사용하면서 동시에 AspectJ도 이용 가능.

# AOP의 용어

- 타깃 - 부가 기능을 부여할 대상
- 어드바이스 -타깃에게 제공할 부가 기능을 담은 모듈. 어드바이스는 여러 가지 종류가 있음. 메소드 호출 과정에 전반적으로 참여하는 것도 있고, 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 존재.
- 조인 포인트 - 어드바이스가 적용될 수 있는 위치. 스프링의 프록시 AOP의 경우 조인 포인트는 메소드의 실행 단계뿐. 타깃 오브젝트가 구현한 인터페이스의 모든 메소드는 조인 포인트가 됨.
- 포인트 컷 - 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈. 스프링 AOP의 조인 포인트는 메소드의 실행이므로 포인트 컷은 메소드를 선정하는 기능을 가짐. 그래서 포인트컷 표현식은 메소드의 실행이란 의미인 exection으로 시작하고, 메소드의 시그니처를 비교하는 방법을 주로 이용.
- 프록시 - 클라이언트와 타깃 사이에 투명하게 존재하면서 부가 기능을 제공하는 오브젝트. DI를 통해 타깃 대신 클라이언트에게 주입되며, 클라이언트의 메소드 호출을 대신 받아서 타깃에 위임해주면서, 그 과정에서 부가 기능을 부여. 스프링은 프록시를 이용해 AOP를 지원.
- 어드바이저 - 포인트 컷과 어드바이스를 하나씩 갖고 있는 오브젝트. 어떤 부가 기능을 어디에 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈. 스프링은 자동 프록시 생성기가 어드바이저를 AOP 작업의 정보로 활용.
- 애스펙트 - OOP의 클래스와 마찬가지로 애스펙트는 AOP의 기본 모듈. 한 개 또는 그 이상의 포인트 컷과 어드바이스의 조합으로 만들어지며 보통 싱글 톤 형태의 오브젝트로 존재. 따라서 클래스와 같은 모듈 정의와 오브젝트와 같은 실체의 구분이 특별히 없음.

# AOP 네임 스페이스

스프링 AOP를 적용하기 위해 추가했던 어드바이저, 포인트컷, 자동 프록시 생성기 같은 빈들은 비즈니스 로직이나 DAO처럼 애플리케이션의 일부 기능을 담고 있는 것도 아니고, datasource 빈처럼 DI를 통해 애플리케이션 빈에서 사용되는 것도 아님.

이런 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용됨.

스프링의 프록시 방식 AOP를 적용하려면 최소 4가지 빈 등록 필요.

- 자동 프록시 생성기 : 스프링의 DefaultAdvisorAutoProxyCreator 클래스를 빈으로 등록. 다른 빈을 DI하지도 않고 자신도 DI 되지 않으며 독립적으로 존재. 빈으로 등록된 어드바이저를 이용해 프록시를 자동으로 생성하는 기능을 담당.
- 어드바이스 : 부가 기능을 구현한 클래스를 빈으로 등록. TransactionAdvice는 AOP 관련 빈 중 유일하게 직접 구현한 클래스를 사용.
- 포인트 컷 : 스프링의 AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트 컷 표현식을 넣어주면 됨. 코드 작성 필요 x.
- 어드바이저 : 스프링의 DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용. 어드바이스와 포인트 컷을 프로퍼티로 참조하는 것 외에는 기능이 없음.

이 중 부가 기능을 담은 코드로 만든 어드바이스를 제외헌 세 가지는 모두 스프링이 직접 제공하는 클래스를 빈으로 등록하고 프로퍼티 설정만 해준 것.

## AOP 네임 스페이스

스프링은 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공. 

aop 스키마에 정의된 태그는 별도의 네임 스페이스를 지정해서 디폴트 네임 스페이스의 <bean> 태그와 구분해서 사용 가능.

aop 스키마에 정의된 태그를 사용하려면 설정 파일에 아래 이미지와 같은 네임 스페이스 선언을 추가해야 함.

<img width="622" height="305" alt="image" src="https://github.com/user-attachments/assets/fbc2fc19-8300-4ca7-9714-ffcd3d57909a" />

다음은 aop 네임 스페이스를 이용해 기존의 AOP 관련 빈 설정을 변경.

<img width="611" height="227" alt="image" src="https://github.com/user-attachments/assets/9540683a-31f1-4068-abaf-284727aa56fd" />

<aop:config, <aop pointcut>, <aop: advisor> 세 가지 태그를 정의해두면 그에 따라 세 개의 빈이 자동으로 등록.됨.

포인트 컷이나 어드바이저, 자동 포인트 컷 생성기 같은 특별한 기능을 가진 빈들은 별도의 스키마에 정의된 전용 태그를 사용해 사용해 정의해주면 편리.

애플리케이션을 구성하는 컴포넌트 빈과 컨테이너에 의해 사용되는 기반 기능을 지원하는 빈은 구분이 되는 것이 좋음.

직접 구현한 클래스로 등록한 빈인 transactionAdvice를 제외한 AOP 관련 빈들은 의미를 잘 드러내는 독립된 전용 태그를 사용하도록 권장.

<bean> 태그를 사용했을 때와 비교해보면 이해하기도 쉬울 뿐더러 코드의 양도 대폭 줄었음을 알 수 있음.

## 어드바이저 내장 포인트 컷

AspectJ 포인트 컷 표현식을 활용하는 포인트 컷은 스트링으로 된 표현식을 담은 expression 프로퍼티 하나만 설정해주면 사용 가능.

또, 포인트 컷은 어드바이저에 참조되어야만 사용됨.

그래서 aop 스키마의 전용 태그를 사용하는 경우에는 굳이 포인트 컷을 독립적인 태그로 두고 어드바이저 태그에서 참조하는 대신 어드바이저 태그와 결합하는 방법도 가능.

<img width="603" height="169" alt="image" src="https://github.com/user-attachments/assets/89de3f11-a738-49f6-8949-f66c745e7aa0" />

위와 같이 포인트 컷 표현식을 직접 <aop:advisor> 태그에 담아서 만들 수도 있음.

태그가 하나 줄었으니 포인트 컷을 독립적으로 정의하는 것보다 간결해서 보기 좋지만 하나의 포인트 컷을 여러 개의 어드바이저에서 공유하려고 하는 경우에는 포인트 컷을 독립적인 <aop:pointcut> 태그로 등록해야 함.

포인트 컷을 내장하는 경우 <aop:advisor> 태그 하나로 두 개의 빈이 등록됨.

전용 스키마를 가지는 태그는 한 번에 하나 이상의 빈을 등록 가능.

<aop:advisor>처럼 애트리뷰트 설정에 따라 등록되는 빈의 개수와 종류가 달라질 수도 있음.

또한, 서버 환경이나 클래스 패스에 존재하는 라이브러리에 따라서 등록되는 빈이 달라지는 경우도 존재.

# 트랜잭션 속성

<img width="632" height="342" alt="image" src="https://github.com/user-attachments/assets/05176dd7-485a-421d-acbc-51d790c95cfa" />

트랜잭션의 경계는 트랜잭션 매니저에게 트랜잭션을 가져오는 것과 commit(), rollback() 중의 하나를 호출하는 것으로 설정되고 있음.

트랜잭션을 가져올 때 파라미터로 트랜잭션 매니저에게 전달하는 DefaultTransactionDefinition의 용도가 무엇일까.

## 트랜잭션 정의

### 트랜잭션 전파

트랜잭션 전파 : 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식.

<img width="395" height="200" alt="image" src="https://github.com/user-attachments/assets/9aa22d94-2e6e-4d4a-b2e9-aabb5ee4acb2" />

위의 이미지에서 처럼 트랜잭션 전파와 같이 각각 독립적인 트랜잭션 경계를 가진 두 개의 코드가 있다고 가정할 때, A의 트랜잭션이 시작하고 종료 이전에 B를 호출했다면 B의 코드는 어떤 트랜잭션 안에서 동작할까?

여러 가지 시나리오가 존재.

우선, A에서 트랜잭션이 시작되어 진행 중이라면 B가 새로운 트랜잭션을 만들지 않고 A에서 이미 시작한 트랜잭션에 참여 가능.

이 경우 B를 호출한 작업까지 마치고 A의 남은 코드를 진행하던 중 예외가 발생하면 A와 B의 코드가 모두 취소됨.

다음으로 B의 트랜잭션이  독립적으로 만들어지는 경우 B의 트랜잭션 경계를 빠져나오는 순간 B의 트랜잭션은 독자적으로 커밋 또는 롤백될 것이고, A 트랜잭션은 그에 영향을 받지 않고 진행될 것.

만약 이후 A의 남은 코드에서 예외가 발생한다면 A는 롤백되어도 B는 이미 종료되어 영향을 받지 않을 것.

B와 같이 독자적인 트랜잭션 경계를 가진 코드에 대해 이미 진행 중인 트랜잭션이 어떻게 영향을 미칠 수 있는가를 정의하는 것이 바로 트랜잭션 전파 속성.

- PROPAGATION_REQUIRED : 가장 많이 사용되는 트랜잭션 전파 속성으로 진행 중인 트랜잭션이 없으면 새로 시작하고, 이미 시작된 트랜잭션이 있으면 이에 참여. PROPAGATION_REQUIRED 트랜잭션 전파 속성을 가지는 코드는 다양한 방식으로 결합해서 하나의 트랜잭션으로 구성하기 쉬움. A와 B가 모두 PROPAGATION_REQUIRED로 선언되어 있다면, A, B, A B,B-A와 같은 네 가지의 조합된 트랜잭션이 모두 가능. DefaultTransactionDefinition의 트랜잭션 전파 속성은 바로 이 PROPAGATION_REQUIRED .
- PROPAGATION_REQUIRES_NEW : 항상 새로운 트랜잭션 시작. 즉, 앞에 시작된 트랜잭션이 있든 없든 상관없이 새로운 트랜잭션을 만들어서 독자적으로 동작하게 함. 독립적인 트랜잭션이 보장돼야 하는 코드에 적용 가능.
- PROPAGATION_NOT_SUPPORTED : 트랜잭션 없이 동작하도록 만들 수도 있는 속성. 진행 중인 트랜잭션이 있어도 무시. 트랜잭션을 무시하는 속성을 두는 이유는 트랜잭션 경계 설정은 보통 AOP를 이용해 한 번에 많은 메소드에 동시에 적용하는 방법을 사용하는데 그 중 특별한 메소드만 트랜잭션 적용에서 제외하기 위해서.

이 외에도 다양한 트랜잭션 전파 속성 사용 가능.

트랜잭션 매니저를 통해 트랜잭션을 시작하려고 할 때 getTransaction()이란 메소드를 사용하는 이유도 바로 이 트랜잭션 전파 속성 때문.

### 격리 수준

모든 DB 트랜잭션은 격리 수준을 가지고 있어야 함.

서버 환경에서는 여러 개의 트랜잭션이 동시에 진행 가능.

가능하다면 모든 트랜잭션이 순차적으로 진행되어 다른 트랜잭션의 작업에서 독립적인 것이 좋지만 성능이 크게 떨어질 수 밖에 없음.

따라서 적절하게 격리 수준을 조정해서 가능한 한 많은 트랜잭션을 동시에 진행시키면서도 문제가 발생하지 않게 하는 제어가 필요.

격리 수준은 기본적으로 DB에 설정되어 있지만 JDBC 드라이버나 Datasource 등에서 재설정 가능하고 필요하다면 트랜잭션 단위로 격리 수준을 조정 가능.

DefaultTransactionDefinition에 설정된 격리 수준은 ISOLATION_DEFAULT.

기본적으로는 이를 따르는 편이 좋지만 특별한 작업을 수행하는 메소드의 경우는 독자적인 격리 수준을 지정할 필요가 있음.

### 제한 시간

트랜잭션을 수행하는 제한시간을 설정 가능.

DefaultTransactionDefinition의 기본 설정은 제한 시간이 없음.

제한시간은 트랜잭션을 직접 시작할 수 있는 PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW와 함께 사용해야만 의미가 생김.

### 읽기 전용

읽기 전용으로 설정해두면 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음.

또한 데이터 액세스 기술에 따라서 성능이 향상될 수도 있음.

TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션의 동작 방식을 제어 가능.

트랜잭션 정의를 수정하려면 디폴트 속성을 갖고 있는 DefaultTransactionDefinition을 사용하는 대신 외부에서 정의된 TransactionDefinition 오브젝트를 DI 받아서 사용하도록 만들면 됨.

하지만 이 방법으로 트랜잭션 속성을 변경하면 TransactionAdvice를 사용하는 모든 트랜잭션의 속성이 한꺼번에 바뀐다는 문제가 존재.

원하는 메소드만 선택해서 독자적인 트랜잭션 정의를 적용할 수 있는 방법은 없을까?

## 트랜잭션 인터셉터와 트랜잭션 속성

메소드 별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능을 확장해야 함.

메소드 이름 패턴에 따라 다른 트랜잭션 정의가 되도록 만드는 것.

### TransactionInterceptor

기존에 만들었던 TransactionAdvice를 다시 설계할 필요 없이 스프링에서 제공하는 TransactionInterceptor를 사용하면 됨.

TransactionInterceptor 어드바이스의 동작 방식은 기존의 TransactionAdvice와 다르지 않고 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐.

TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있음.

Properites 타입인 두 번째 프로퍼티 이름은 transactionAttributes로 트랜잭션 속성을 정의한 프로퍼티.

트랜잭션 속성은 TransactionDefinition의 네 가지 기본 항목에 rollbackOn()이라는 메소드를 하나 더 갖고 있는 TransactionDefinition 인터페이스로 정의됨.

rollbackOn() 메소드는 어떤 예외가 발생하면 롤백할 것인가를 결정하는 메소드.

transactionAttributes를 이용하면 트랜잭션 부가 기능의 동작 방식을 모두 제어 가능.

<img width="620" height="380" alt="image" src="https://github.com/user-attachments/assets/15ae16bc-66e2-4b54-9224-52143533aa14" />

위 이미지를 살펴보면 트랜잭션 부가 기능의 동작 방식을 변경할 수 있는 곳이 두 군데 있다는 사실을 알 수 있음.

TransactionAdvice는 RuntimeException이 발생하는 경우에만 트랜잭션을 롤백시킴.

하지만 런타임 예외가 아닌 경우에는 트랜잭션이 제대로 처리되지 않고 메소드를 빠져나가게 되어 있음.

UserService는 런타임 예외만 던진다는 사실을 알기 때문에 상관 없지만, 체크 예외를 던지는 타깃에 사용한다면 문제 발생 가능.

스프링이 제공하는 TransactionInterceptor에는 기본적으로 두 가지 종류의 예외 처리 방식이 존재.

런타임 예외가 발생하면 트랜잭션은 롤백.

반면 타깃 메소드가 체크 예외를 던지는 경우 이것을 예외가 아닌 의미 있는 리턴 방식의 한 가지로 인식해서 트랜잭션을 커밋함.

그런데 TransactionInterceptor의 이러한 예외 처리 기본 원칙을 따르지 않는 경우에 TransactionAttribute는 rollbackOn() 이라는 속성을 둬서 기본 원칙과 다른 예외처리가 가능하게 해줌.

이를 활용해 특정 체크 예외의 경우 트랜잭션을 롤백시키고, 특정 런타임 예외에 대해서는 트랜잭션을 커밋시킬 수도 있음.

TransactionInterceptor는 이런 TransactionAttribute를 Properties라는 일종의 맵 타입 오브젝트로 전달받음.

컬렉션을 사용하는 이유는 메소드 패턴에 따라 각기 다른 트랜잭션 속성을 부여할 수 있게 하기 위해서.

### 메소드 이름 패턴을 이용한 트랜잭션 속성 지정

Properties 타입의 transactionAttributes 프로퍼티는 메소드 패턴과 트랜잭션 속성을 키와값으로 갖는 컬렉션.

트랜잭션 속성은 다음과 같은 문자열로 정의 가능.

<img width="645" height="184" alt="image" src="https://github.com/user-attachments/assets/e2d5d105-8666-4368-bea1-1f843a91df99" />

이 중 트랜잭션 전파 항목만 필수이고 나머지는 생략 가능.

생략하면 DefaultTransactionDefinition에 설정된 디폴트 속성이 부여됨.

이 중 + 또는 -로 시작하는 건 기본 원칙을 따르지 않는 예외를 정의해주는 것.

모든 런타임 예외는 롤백돼야 하지만 +XXXRuntimeException이라고 해주면 런타임 예외라도 커밋하게 만들 수 있음.

반대로 - 경우는 롤백 대상이 됨.

이렇게 속성을 하나의 문자열로 표현하게 만든 이유는 트랜잭션 속성을 메소드 패턴에 따라 여러 개를 지정해주어야 하는데, 일일이 중첩된 태그와 프롶퍼티로 설정하게 만들면 번거롭기 때문.

<img width="637" height="361" alt="image" src="https://github.com/user-attachments/assets/98b74c39-f22d-4636-bd94-99c3021151bc" />

메소드 이름 패턴과 문자열로 된 트랜잭션 속성을 이용해서 정의한 TransactionInterceptor 타입 빈의 예.

세 가지 메소드 일므 패턴에 대한 트랜잭션 속성이 정의되어 있음.

- 이름이 get으로 시작하는 모든 메소드에 대한 속성 - PROPAGATION_REQUIRE이면서 읽기 전용이고 시간 제하는 30초. 보통 읽기 전용 메소드는 get 또는 find와 같은 이름으로 시작하는데 읽기 전용이 아닌 트랜잭션 속성을 가진 메소드에서 get으로 시작하는 메소드를 호출한다면? → get 메소드는 PROPAGATION_REQUIRED이기 때문에 다른 트랜잭션이 시작되어 있으면 그 트랜잭션에 참여. 그렇다면 이미 DB에 쓰기 작업이 진행된 채로 읽기 전용 트랜잭션 속성을 가진 작업이 뒤따르게 돼서 충돌이 일어난다면? 다행히 트랜잭션 속성 중 readOnly나 timeout 등은 트랜잭션이 처음 시작될 때가 아니라면 적용되지 않음.
- upgrade 로 시작하는 메소드는 항상 독립적인 트랜잭션으로 동작하도록 트랜잭션 전파 항목을 PROPAGATION_REQUIRES_NEW로 설정. 또, 다른 동시 작업에 영향을 받지 않도록 완벽하게 고립된 상태에서 트랜잭션이 동작하도록 격리 수준을 최고 수준인 ISOLATION_SERIALIZABLE로 설정.
- *만 사용해서 위 두 가지 조건에 해당하지 않는 나머지 모든 메소드에 사용될 속성을 지정.  필 항목인 PROPAGATION_REQUIRED만 지정하고 나머지는 디폴트
설정을 따르게 함.

때로는 메소드 이름이 하나 이상의 패턴과 일치하는 경우가 존재.

이때는 메소드 이름 패턴 중 가장 일치하는 것이 적용됨.

이렇게 메소드 이름 패턴을 사용하는 트랜잭션 속성을 활용하면 하나의 트랜잭션 어드바이스를 정의하는 것만으르도 다양한 트랜잭션 설정이 가능.

### tx 네임 스페이스를 이용한 설정 방법

Transaction Interceptor 타입의 어드바이스 빈과 TransactionAttribute 타입의 속성 정보도 tx 스키마의 전용 태그를 이용해 정의 가능.

트랜잭션 어드바이스도 포인트 컷이나 어드바이저만큼 자주 사용되고, 애플리케이션의 컴포넌트가 아닌 컨테이너가 사용하는 기반 기술 설정의 한 가지이기 때문.

<img width="632" height="607" alt="image" src="https://github.com/user-attachments/assets/8b9be024-f196-486c-95c8-cd0a5667923d" />

TransactionInterceptor 빈으로 정의한 트랜잭션 어드바이스와 메소드 패턴에 따른 트랜잭션 속성 지정은 tx 스키마의 태그를 이용해 위와 같이 간단히 정의 가능.

트랜잭션 속성이 개별 애트리뷰트를 통해 지정될 수 있으므로 설정 내용을 읽기가 용이하고 XML 에디터의 자동 완성 기능을 통해 편하게 작성 가능.

문자열 입력시의 오타 문제도 XML 스키마에 미리 등록해둔 값을 통해 검증 가능해 편리.

<bean> 태그로 등록하는 경우에 비해 장점이 많아 tx 스키마 태그를 사용해 어드바이스를 등록하도록 권장.

## 포인트 컷과 트랜잭션 속성의 적용 전략

트랜잭션 부가 기능을 적용할 후보 메소드르 선정하는 작업은 포인트 컷에 의해 진행됨.

어드바이스의 트랜잭션 전파 속성에 따라 메소드 별로 트랜잭션의 적용 방식이 적용됨.

aop와 tx 스키마의 전용 태그를 사용한다면 애플리케이션의 어드바이저, 어드바이스, 포인트 컷 기본 설정 방법은 바뀌지 않을 것.

expression 애트리뷰트에 넣는 포인트 컷 표현식과 <tx:attribute>로 정의하는 트랜잭셔 ㅇ속성만 결정하면 됨.

### 트랜잭션 포인트 컷 표현식은 타입 패턴이나 빈 이름을 이용

일반적으로 트랜잭션을 적용할 타깃 클래스의 메소드는 모두 트랜잭션 적용 후보가 되는 것이 바람직함.

하지만 이렇게 비즈니스 로직을 담고 잇는 클래스라면 메소드 단위까지 세밀하게 포인트 컷을 정의해줄 필요가 없음.

UserService의 add() 메소드도 트랜잭션 적용 대상이어야 함.

트랜잭션 전파 방식을 생각해본다면 UserDao.add() 를 호출해서 사용자 정보를 DB에 추가하는 것 외에도 DB의 정보를 다루는 작업이 추가될 가능성이 높음.

쓰기 작업이 없는 단순한 조회 작업만 하는 메소드에도 모두 트랜잭션을 적용하는 게 좋음.

조희의 경우에는 읽기 전용으로 트랜잭션 속성을 설정해두면 그만큼 성능의 향상을 가져올 수 있음.

또, 복잡한 조회의 경우 제한 시간을 지정할 수도 있고, 격리 수준에 따라 조회도 반드시 트랜잭션 안에서 진행해야 할 필요가 발생하기도 함.

따라서 트랜잭션 용 포인트 컷 표현식에는 메소드나 파라미터, 예외에 대한 패턴을 정의하지 않는 것이 바람직함.

트랜잭션의 경계로 삼을 클래스들이 선정됐다면, 그 클래스들이 모여 있는 패키지를 통째로 선택하거나 클래스 이름에서 일정한 패턴을 찾아 표현식으로 작성.

가능하면 클래스보다는 인터페이스 타입을 기준으로 타입 패턴을 적용하는 것이 좋음.

why? → 클래스에 비해 변경 빈도가 적고 일정한 패턴 유지가 용이하기 때문.

메소드의 시그니처를 이용한 execution() 방식의 포인트 컷 표현식 대신 스프링의 빈 이름을 이용하는 bean() 표현식을 사용하는 방법도 고려해볼만 함.

bean() 표현식은 빈 이름을 기준으로 선정하기 때문에 클래스나 인터페이스 이름에 일정한 규칙을 만들기 어려운 경우에 유용.

포인트 컷 표현식 자체가 간단해 읽기 편하다는 것도 장점.

### 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의

실제로 하나의 애플리케이션에서 사용할 트랜잭션 속성의 종류는 그리 다양하지 않음.

너무 다양한 경우 관리만 힘들어짐.

따라서 기준이 되는 몇 가지 트랜잭션 속성을 정의하고 그에 따라 적절한 메소드 명명 규칙을 만들어두면 하나의 어드바이스만으로 애플리케이션의 모든 서비스 빈에 트랜잭션 속성 지정 가능.

그런데 가끔 트랜잭션 속성의 적용 패턴이 일반적인 경우와 크게 다른 오브젝트가 존재하기도 함.

이런 예외적인 경우 트랜잭션 어드바이스와 포인트 컷을 새롭게 추가해줄 필요가 있음.

가장 간단한 트랜잭션 속성 부여 방법은 다음과 같이 모든 메소드에 대해 디폴트 속성을 지정하는 것.

일단 트랜잭션 속성의 종류와 메시지 패턴이 결정되지 않았으면 가장 단순한 디폴트 속성으로부터 출발하면 됨.

개발이 진행됨에 따라 단계적으로 속성 추가.

<img width="643" height="193" alt="image" src="https://github.com/user-attachments/assets/c32fe1e0-cbf9-4628-80de-8d4cc3f20169" />

디폴트 속성을 일괄적으로 부여한 것에서 한 단계 더 나아간다면 아래와 같이 간단한 메소드 이름의 패턴 적용 가능.

<img width="641" height="216" alt="image" src="https://github.com/user-attachments/assets/1c96fcde-0f71-4fa5-87b3-50148540c7d3" />

트랜잭션 적용 대상 클래스의 메소드는 일정한 명명 규칙을 따르게 해야 함.

일반화하기에는 적당하지 않은 특별한 트랜잭션 속성이 필요한 타깃 오브젝트에 대해서는 별도의 어드바이스와 포인트 컷 표현식을 사용하는 편이 좋음.

아래 이미지는 두 개의 포인트 컷과 어드바이스를 적용한 예로 비즈니스 로직을 정의한 서비스 빈에는 기본적인 메소드 이름 패턴을 따르는 트랜잭션 속성을 지정하는 반면 트랜잭션의 성격이 많이 다른 배치 작업용 클래스를 위해서는 트랜잭션 어드바이스를 별도로 정의해서 독자적인 트랜잭션 속성을 지정.

<img width="641" height="337" alt="image" src="https://github.com/user-attachments/assets/7014b958-8a2f-422c-b5f5-d6246a5020fd" />

### 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 않음

이것은 전략보다는 주의 사항.

프록시 방식의 AOP에서 프록시를 통한 부가 기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능.

여기서 클라이언트란 인터페이스를 통해 타깃 오브젝트를 사용하는 다른 모든 오브젝트.

반대로 타깃 오브젝트가 자기 자신의 메소드를 호출할 때는 프록시를 통한 부가 기능의 적용이 일어나지 않음.

<img width="571" height="149" alt="image" src="https://github.com/user-attachments/assets/177c0cee-4cd8-443b-a7a7-8c3c9db46819" />

위 이미지는 트랜잭션 프록시가 타깃에 적용되어 있는 경우의 메소드 호출 과정을 보여줌. 

delete()와 update() 모두 트랜잭션 적용 대상인 메소드.

따라서 [1], [3]처럼 클라이언트로부터 메소드가 호출되면 트랜잭션 프록시를 통해 타깃 메소드로 호출이 전달되므로 트랜잭션 경계 설정 부가 기능이 부여될 것.

하지만 [2]의 경우 타깃 오브젝트 내로 들어와서 타깃 오브젝트의 다른 메소드를 호출하는 경우 프록시를 거치지 않고 직접 타깃의 메소드가 호출됨.

그로 인해 [2]를 통해 update() 메소드가 호출될 때는 update() 메소드에 지정된 트랜잭션 속성이 전혀 반영되지 않음.

만일 update() 메소드에 대해 트랜잭션 전파 속성을 REQUIRES_NEW라고 해놨더라도 같은 타깃 오브젝트에 있는 delete() 메소드를 통해 update()가 호출되면 트랜잭션 전파 속성이 적요오디지 않으므로 REQUIRES_NEW는 무시되고 프록시의 delete() 메소드에서 시작한 트랜잭션에 단순하게 참여하게 될 뿐.

이렇게 같은 타깃 오브젝트 안에서 메소드 호출이 일어나는 경우 프록시 AOP를 통해 부여해준 부가 기능이 적용되지 않는다는 점을 주의해야 함.

따라서 같은 오브젝트 안에서의 호출은 새로운 트랜잭션 속성을 부여하지 못한다는 사실을 의식하고 개발할 필요가 있음.

타깃 안에서의 호출에 프록시가 적용되지 않는 문제를 해결할 수 있는 방법은 두 가지가 존재.

1. 스프링 API를 이용해 프록시 오브젝트에 대한 레퍼런스를 가져온 뒤에 같은 오브젝트의 메소드 호출도 프록시를 이용하도록 강제하는 방법. 하지만 복잡한 과정을 거쳐 순수한 비즈니스 로직만을 남겨두려고 했던 노력이 물거품이 되므로 PASS.
2. AspectJ와 같은 타깃의 바이트 코드를 직접 조작하는 방식의 AOP 기술을 적용하는 것. 스프링은 프록시 기반의 AOP를 기본적으로 사용하고 있지만 필요하면 언제든지 AspectJ 방식으로 변경 가능. 지금까지의 설정 대부분을 그대로 둔 채 간단한 옵션을 바꿈으로써 AspectJ 방식으로 트랜잭션 AOP가 적용되게 할 수 있음. 하지만 그에 따른 불편도 크기에 꼭 필요한 경우에만 사용.

## 트랜잭션 속성 적용

### 트랜잭션 경계 설정의 일원화

트랜잭션 경계 설정의 부가 기능을 여러 계층에서 중구난방으로 적용하는 건 좋지 않음.

일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직.

서비스 계층을 트랜잭션이 시작되고 종료되는 경계로 정했다면, 테스트와 같은 특별한 이유가 아니고는 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야 함.

트랜잭션은 보통 서비스 계층의 메소드 조합을 통해 만들어지기 때문에 DAO가 제공하는 주요 기능은 서비스 계층에 위임 메소드를 만들어둘 필요가 있음.

순수 조회나 간단한 수정이라면 서비스 계층 오브젝트에서 DAO를 직접 사용해도 상관 없지만, 등록이나 수정, 삭제가 포함된 작업이라면 다른 모듈의 DAO를 직접 이용할 때 신중을 기해야 함.

아키텍처를 단순하게 가져가면 서비스 계층과 DAO가 통합될 수도 있음.

비즈니스 로직이 거의 없고 단순 DB 입출력과 검색 수준의 조회가 전부라면 서비스 계층을 없애고 DAO를 트랜잭션 경계로 만드는 것.

UserDao 인터페이스에 정의된 6개의 메소드 중 이미 서비스 계층에 부가적인 로직을 담아서 추가한 add() 를 제외한 나머지 5개가 UserService에 새로 추가할 후보 메소드.

이 중 단순히 레코드 개수를 리턴하는 getCount()를 제외하면 나머지는 독자적인 트랜잭션을 가지고 사용될 가능성이 높음.

<img width="634" height="279" alt="image" src="https://github.com/user-attachments/assets/7739126a-066c-4cc0-8e7a-851a0cb0e508" />

다음은 UserServiceImpl 클래스에 추가된 메소드 구현 코드를 넣어줌.

<img width="648" height="277" alt="image" src="https://github.com/user-attachments/assets/8630d8ec-4e5b-4b6c-8722-efe9628b521b" />

이제 모든 User 관련 데이터 조작은 UserService라는 트랜잭션 경계를 통해 진행할 경우 모두 트랜잭션 적용 가능.

### 서비스 빈에 적용되는 포인트 컷 표현식 등록

<img width="643" height="142" alt="image" src="https://github.com/user-attachments/assets/67d02f8a-fb6a-48fe-8962-e060c53f7309" />

upgradeLevels()에만 트랜잭션이 적용되게 했던 기존 포인트 컷 표현식을 모든 비즈니스 로직의 서비스 빈에 적용되도록 수정.

이제 아이디가 Service로 끝나는 모든 빈에 transactionAdvice 빈의 부가 기능이 적용될 것.

### 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록

TransactionAdvice 클래스로 정의했던 어드바이스 빈을 스프링의 TransactionInterceptor를 이용하도록 변경

메소드 패턴과 트랜잭션 속성은 가장 보편적인 방법인 get으로 시작하는 메소드는 읽기 전용으로 두고 나머지를 디폴트 트랜잭션 속성을 따르는 것으로 설정.

<img width="711" height="332" alt="image" src="https://github.com/user-attachments/assets/336cc4a6-c76b-420c-b503-ae7f19052b73" />

이미 aop 스키마의 태그를 적용했으니 어드바이스도 tx 스키마에 정의된 태그를 이용하도록 변경.

<img width="639" height="490" alt="image" src="https://github.com/user-attachments/assets/4e6eb505-e0d6-4301-bd82-bd053f08fb58" />

용도를 명확히 드러내주는 태그를 사용한 덕분에, 트랜잭션 어드바이스와 속성 정의가 훨씬 이해하기 쉽고 간결해짐.

### 트랜잭션 속성 테스트

<tx:attributes>로 지정한 트랜잭션 속성을 보면 get으로 시작하는 메소드에는 읽기 전용 속성이 true로 되어 있음.

이 메소들르 경계로 시작되는 트랜잭션에는 쓰기 작업이 허용되지 않는 것을 확인.

<img width="635" height="313" alt="image" src="https://github.com/user-attachments/assets/d2bd8b44-b5a4-4cdf-b78e-97bb37e42f71" />

getAll() 메소드는 get으로 시작되는 메소드이므로 읽기 전용 트랜잭션 속성이 적용된 채로 동작해야 함.

트랜잭션 내부에서 쓰기 시도를 하면 예외가 발생할 것.

<img width="640" height="195" alt="image" src="https://github.com/user-attachments/assets/4f99a34f-1345-420b-b78f-abebf7babaa3" />

UserServiceTest에 조작된 getAll() 을 호출하는 테스트 작성.

TestUserService를 testUserService 빈으로 등록해뒀으니 위 이미지와 같이 DI받은 testUserService 변수를 사용하여 getAll() 메소드 호출.

테스트 실행 시 예외가 발생하여 실패임을 알 수 있음.

<img width="593" height="168" alt="image" src="https://github.com/user-attachments/assets/c49c4606-c768-4e0e-b33e-07b3a5f74a68" />

원하는 것은 예외가 발생하는 것이었기에 예외 타입을 확인하여 테스트를 성공하도록 수정.

<img width="643" height="153" alt="image" src="https://github.com/user-attachments/assets/280b436c-1788-40a3-84ab-3a1b23cfd462" />

테스트를 돌려보면 성공할 것임.

테스트 결과를 통해 전용 스키마의 태그를 사용해서 정의한 트랜잭션 AOP가 바르게 동작하고, 메소드에 따라 적절한 트랜잭션 속성이 부여되고 있음을 확인할 수 있음
