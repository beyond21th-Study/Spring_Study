[ week12, Spring Study 6.5.4 ~6.6.4] 531까지.

[ AOP란 무엇인가 ? ]

* 일단 비즈니스 로직을 담은 UserService에 트랜잭션을 적용해온 과정을 정리해보자.


{ 트랜잭션 서비스 추상화 }

* 기존방식의 한계
    * 각 방식마다 중복된 코드 작성 필요.
    * 비즈니스 로직에 트랜잭션 처리 코드 섞임 -> 복잡도 증가.

* 해결책 : 추상화 + DI
    * 비즈니스 로직은 트랜잭션 기술 변경에 영향없음.
    * 구체적 구현만 독립적으로 교체 가능
    * 설정만으로 동작 방식 변경
    * 관심사의 분리.


{ 프록시와 데코레이터 패턴 }

* 트랜잭션을 어떻게 다룰 것인가? -> 추상화만으로는 부족.

* 비즈니스 로직 코드에 직접 트랜잭션 코드가 섞여있는것이 문제. -> 트랜잭션은 부가기능인데 비즈니스 로직과 같이씀.

* 해결책 : 프록시를 사용해서 기술적 관심사를 분리해야 함.

* 장점 :
    * 관심사 분리
    * 코드 단순화
    * 유연성(DI로 프록시 적용/제거 가능)
    * 중복 제거
    * 테스트 용이



{ 다이내믹 프록시와 프록시 팩토리 빈 }

* 기존 프록시의 한계
* 코드 중복
* 프록시 클래스 작성의 번거로움.

* 예시 1) JDK 다이내믹 프록시 : 프록시 클래스를 직접 정의하지 않고, 런타임 시에 프록시 오브젝트를 동적으로 생성하는 기술.
    * 장점 :
        * 프록시 클래스를 일일이 만들 필요가 없어짐.
        * 부가기능 코드 중복 문제 일부 해결
        * 메서드 선정 패턴을 이용해 메소드에만 부가기능 적용 가능.
    * 한계 : 
        * 동일한 기능을 여러 옵젝에 적용할 때, 오브젝트 단위로 프록시 생성 코드가 중복되는 문제는 해결 X.

* 예시 2) 스프링 프록시 팩토리 빈
    * 특징 :
        * 내부적으로 템플릿/콜백 패턴을 활용
        * 어드바이스(Advice) : 부가기능을 담은 코드. 프록시에서 분리됨.
        * 포인트 컷(Pointcut) : 부가기능 적용 대상(메소드 등) 선정 알고리즘

    * 어드바이스와 포인트컷을 분리하여 여러 프록시에서 공유해서 사용 가능하게 됨.

    * BUT 트랜잭션 적용 대상이 되는 빈마다 일일이 프록시 팩토리 빈을 설정해줘야 함.

    * 해결책 : 자동 프록시 생성기 & 확장된 포인트 컷



{ 부가기능의 모듈화 }

* 부가기능 모듈을 객체지향 기술에서 주로 사용하는 옵젝과는 다르게 특별한 이름으로 부르는데 애스팩트(aspec)라고 부른다.

* 애스펙트란 그 자체로 애플리케이션의 핵심기능을 담고 있지는 않지만, 애플리케이션을 구성하는 중요한 한 가지 요소이고, 핵심 기능에 부가되어 의미를 갖는 특별한 모듈을 가리킨다.

* 기존 방식의 한계, 부가 기능의 특징으로 스스로 독립적으로 존재할 수 없으며, 핵심기능(타깃) 코드 안에 침투하거나 긴밀하게 연결되어야 함.
* 그래서 애플리케이션 전반에 코드가 흩어지게 됨.

* 트랜잭션 추상화까지는 적용했지만 기존의 객체지향 설계 기법으로 해결할 방법은 없었음
￼
* 위의 그림은 핵심기능 코드 사이에 침투한 부가기능을 독립적인 모듈인 애스팩트로 구분해 낸 것이다.

* 2차원적인 평면 구조에선 안되는걸 3차원 다면체 구조로 가져가면서 각각 성격이 다른 부가기능은 다른 면에 존재하도록 만듦.

* 독립된 측면에 존재하는 애스펙트로 분리한 덕에 핵심기능은 순수하게 그 기능을 담은 코드로만 존재하고 독립적으로 살펴볼 수 있도록 구분된 면에 존재하게 된 것이다.

* 이렇게 애플리케이션의 핵심적인 기능에서 부가적인 기능을 분리해서 애스펙트라는 독특한 모듈로 만들어서 설계하고 개발하는 방법을 애스팩트 지향 프로그래밍(Aspect Oriented Programming) 또는 AOP라고 부른다.

* AOP는 애스팩트를 분리함으로써 핵심기능을 설계하고 구현할 때 객체지향적인 가치를 지킬 수 있또록 도와주는 것으로 이해하면된다.

* 만약 트랜잭션 기술에 주목하고 싶으면 TransactionAdvice에만, 대상 결정을 해주는 transactionPointcut 빈의 설정만 신경 써주면 된다는 의미.



- AOP 적용 기술

{ 프록시를 이용한 AOP }

* 다양한 기술들이 AOP를 지원하지만 그중 핵심은 프록시.

* 프록시로 만들어 DI로 연결된 빈 사이에 적용해 타깃의 메소드 호출 과정에 참여해 부가기능을 제공해주도록 만듦.

* 그래서 AOP는 자바의 기본 JDK와 스프링 컨테이너 외에는 특별한 기술이나 환경을 요구 X.

* 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있음.


{ 바이트코드 생성과 조작을 통한 AOP }

* 프록시가 아닌 AOP중 가장 유명한건 AspectJ이다.

* AspectJ는 스프링처럼 다이내믹 프록시 방식을 사용 X.

* 프록시처럼 간접적인 방법이 아니라, 타깃 오브젝트를 뜯어고쳐서 부가기능을 직접 넣어주는 직접적인 방법을 사용.


* AspectJ는 프록시 같은 방법이 있는데 왜 컴파일된 클래스 파일 수정이나 바이트 코드 조작과 같은 복잡한 방법을 사용할까?
    * 1) 바이트 코드를 조작해서 타깃 오브젝트를 직접 수정해버리면 스프링과 같은 DI 컨테이너의 도움을 받아서 자동 프록시 생성 방식을 사용하지 않아도 AOP 적용 가능. 스프링 컨테이너가 사용되지 않는 환경에서도 손쉽게 AOP 적용 가능!

    * 2) 프록시 방식보다 훨씬 강력하고 유연한 AOP가 가능하기 때문.
        * 프록시 AOP는 부가기능을 부여할 때 대상은 클라이언트가 호출할 때 사용하는 메소드 제한됨.
        * 하지만 바이트코드를 직접 조작해서 AOP 적용하면 옵젝 생성, 필드 값의 조회화 조작, 스태틱 초기화 등 다양한 작업에 부기기능을 부여할 수 있음.
        * 타깃 옵젝이 생성되는 순간 부가기능을 부여해주고 싶을 수 도 있다.

* 대부분의 부가기능은 프록시 방식을 사용해 메소드 호출 시점에 부여하는 것으로 충분.

* 간혹, 특별한 요구사항이 생겨 스프링 프록시 AOP 수준을 넘어서는 기능이 필요하면 AspectJ를 사용하면 됨.



{ AOP의 용어 }

* 타깃 :
    *  부가기능을 부여할 대상. 핵심기능을 담은 클래스일 수도 있지만 경우에 따라 다른 부가기능을 제공하는 프록시 옵젝일 수도 있음.

* 어드바이스 :
    * 타깃에게 제공할 부가기능을 담은 모듈. 오브젝트로 정의하기도 하지만 메소드 레벨에서 정의할 수 있음.
    * 여러 종류가 있는데 MethodInterceptor처럼 메소드 호출 과정에 전반적으로 참여하는 것도 있지만, 예외 발생 시 동작하는 어드바이스처럼 메소드 호출 과정의 일부에서만 동작하는 어드바이스도 있다.

* 조인 포인트 :
    * 어드바이스가 적용될 수 있는 위치.
    * 메소드의 실행 단계일 뿐. 타깃 옵젝이 구현한 인터페이스의 모든 메소드는 조인 포인트가 됨.

* 포인트 컷 :
    * 어드바이스를 적용할 조인 포인트를 선별하는 작업 또는 그 기능을 정의한 모듈.
    * execution으로 시작. 메소드의 시그니처를 비교하는 방법을 주로 이용.

* 프록시 :
    * 클라이언트와 타깃 사이에 투명하게 존재. 부가기능을 제공하는 옵젝. DI를 통해 타깃 대신 클라이언트에게 주입. 
    * 클라이언트의 메소드 호출을 대신 받아 타깃에 위임해주면서 그 과정에서 부가기능 부여.

* 어드바이저 : 
    * 포인트컷과 어드바이스를 하나씩 갖고 있는 옵젝.
    * 어떤 부가기능(어드바이스)을 어디에(포인트 컷) 전달할 것인가를 알고 있는 AOP의 가장 기본이 되는 모듈

* 애스펙트 :
    * AOP의 기본 모듈.
    * 한 개 또는 그 이상의 포인트컷과 어드바이스의 조합으로 만들어지며 보통 싱글톤 형태의 오브젝트로 존재.



{ AOP 네임스페이스 }

* AOP 적용을 위해 최소 네 가지 빈을 등록해야 함.

* 자동 프록시 생성기 :
    * 스프링의 DefaultAAdvisorAutoProxyCreator 클래스를 빈으로 등록. 
    * 다른 빈을 DI 하지도 않고 자신도 DI 되지 않으며 독립적으로 존재. -> id도 굳이 필요 X
    * 빈 옵젝 생성하는 과정에 빈 후처리기로 참여.
    * 빈으로 등록된 어드바이저를 이용해서 프록시를 자동으로 생성하는 기능 담당.

* 어드바이스 :
    * 부가기능을 구현한 클래스를 빈으로 등록.
    * TransactionAdvice는 AOP 관련 빈 중에서 유일하게 직접 구현한 클래스를 사용.

* 포인트 컷 :
    * AspectJExpressionPointcut을 빈으로 등록하고 expression 프로퍼티에 포인트컷 표현식을 넣어주면 됨. 코드 작성 X.

* 어드바이저 : 
    * DefaultPointcutAdvisor 클래스를 빈으로 등록해서 사용.
    * 어드바이스와 포인트컷을 프로퍼티로 참조하는 것 외에는 기능 X. 자동 프록시 생성기에 의해 자동 검색 됨.



{ AOP 네임 스페이스 }
* Aop 네임 스페이스 선언을 설정파일에 추가해야함.
￼

* 필요한 핵심 정보만 가지고 아래 그림처럼 간단히 바꿀 수 있음.
￼

* <aop:config>, <aop:pointcut>, <aop:advisor> 세 가지 태그를 정의해두면 그에 따라 세 개의 빈이 자동으로 등록됨.


{ 어드바이저 내장 포인트 컷 }
* AspectJ 포인트컷 표현식을 활용하는 포인트컷은 스트링으로 된 표현식을 담은 expression 프로퍼티 하나만 설정해주면 사용 가능.
* 포인트컷은 어드바이저에 참조되야만 사용!
￼
* 위의 그림처럼 독립 태그보다 어드바이저 태그와 결합해서 간결하고 보기 좋음.




- 트랜잭션 속성

* 트랜잭션 매니저에서 트랜잭션을 가져올 때 사용한 DefaultTransactionDefinition 옵젝.

* 아래 그림은 TransactionAdvice의 트랝낵션 경계설정 코드이다.
￼
* 트랜잭션의 경계는 트랜잭션 매너저에게 트랜잭션을 가져오는 것과 commit(), rollback() 중의 하나를 호출하는 것으로 설정됨.




{ 트랜잭션의 정의 }

* 더 이상 쪼갤 수 없는 최소 단위의 작업.

* 트랜잭션 경계 안에서 진행된 작업은 commit()을 통해 모두 성공하든지 아니면 rollback()을 통해 모두 취소 되어야 함. 

* BUT 트랜잭션의 동작방식을 제어할 수 있는 몇가지 조건이 있음.

* DefaultTransactionDefinition이 구현하고 있는 TransactionDefinition 인터페이스는 트랜잭션의 동작방식에 영향을 줄 수 있는 네 가지 속성을 정의함.


{ 트랜잭션 전파 }

* 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식을 말함.
￼

* 예시 ) A가 진행중일때 B를 호출하는 경우
    * 참여하는 경우 :
        * B가 새로운 트랜잭션을 만들지 않고 A의 트랜잭션에 참여. B 작업후 예외가 발생하면 A와 B작업이 모두 취소. 

    * 독립적인 경우 :
        * B가 A와 무관하게 독립적인 트랜잭션으로 동작함. B가 끝나면 독자적으로 commit/rollback 되며, 이후 A가 롤백 되어도 이미 종료된 B 결과에는 영향 



* PROPAGATION_REQUIRED :
    *  가장 많이 사용되는 트랜잭션 전파 속성.
    * 진행 중인 트랜잭션이 없으면 새로 시작, 이미 시작된 트랜잭션이 있으면 참여.

* PROPAGATION_REQUIRES_NEW : 
    * 항상 새로운 트랜잭션 시작.
    * 독자적으로 트랜잭션 보장해야하는 코드에 적용가능.

* PROPAGATION_NOT_SUPPORTED : 
    * 트랜잭션 없이 동작. 진행중인 트랜잭션 있으면 무시.
    * 트랜잭션을 무시하는 속성을 두는 이유는?
        * 특별한 메소드만 트랜잭션 적용에서 제거하기위해
            * 모든 메소드에 트랜잭션 AOP가 적용되게함.
            * 그리고 특정 메소드의 트랜잭션 전파 속성만  PROPAGATION_NOT_SUPPORTED로 설정해서 트랜잭션 없이 동작하게 만드는 것이 나음



* 제한 시간 :
    * 트랜잭션을 수행하는 제한시간을 설정 가능.
    * 기본 설정은 제한시간이 없다. 그래서 트랜잭션을 직접 시작할 수 있는 것과 함께 사용해야 의미 있음.

* 읽기 전용 :
    * 트랜잭션 내에서 데이터를 조작하는 시도를 막아줄 수 있음. 또한 데이터 액세스 기술에 따라 성능 향상 가능.


* TransactionDefinition 타입 오브젝트를 사용하면 네 가지 속성을 이용해 트랜잭션의 동작방식 제어 가능.



{ 트랜잭션 인터셉터와 트랜잭션 속성 }

* 메소드별로 다른 트랜잭션 정의를 적용하려면 어드바이스의 기능으 확장해야 함.


- TransactionInterceptor

* TransactionInterceptor 어드바이스 동작 방식은 기존에 만들었떤 TransactionAdvice와 다르지 않음.

* 다만, 트랜잭션 정의를 메소드 이름 패턴을 이용해서 다르게 지정할 수 있는 방법을 추가로 제공해줄 뿐.

* TransactionInterceptor는 PlatformTransactionManager와 Properties 타입의 두 가지 프로퍼티를 갖고 있따.

* Properties 타입인 두 번째 프로퓨ㅓ티 이름은 transactionAttributes로, 트랜잭션 속성을 정의한 프로퓨ㅓ티다.
* 트랜잭션 속성은 TransactionDefinition의 네 가지 기본 항목에 rollbackOn() 메소드는 어떤 예외가 발생하면 롤백을 할 것인가를 결정하는 메소드 이다.
* 이 TransactionAttribute를 이용하면 트랜잭션 부가기능의 동작방식을 모두 제어할 수 있따.
￼

* TransactionAdvice는 RuntimeException이 발생하는 경우에만 트랜잭션을 롤백시킨다. 
* BUT 런타임 예외가 아닌 경우 트랜잭션 실행 X. 메소드를 빠르게 지나침.
* 체크 예외를 던지는 타깃에 사용되면 문제가 될 수 있음.

* 런타임 예외만 아니라 모든 종류의 예외에 대해 트랜잭션을 롤백시키도록 해야할까? -> X.

* 비즈니스 로직상의 예외 경우를 나타내기 위해 타깃 오브젝트가 체크 예외를 던지는 경우에는 DB 트랜잭션은 커밋시켜야 하기 때문.


* TransactionInterceptor에는 두 가지 종류의 예외 처리 방식이 있음.

* 런타임 예외 :  발생하면 트랜잭션은 롤백됨.
* 체크예외 : 예외 상황이 아닌 비즈니스 로직에 따른 의미있는 리턴으로 인식하여 트랜잭션을 커밋함.(스프링은 복구 불가능한 예외는 런타임 예외로 포장한다고 가정하기 때문.)
* 예외 커스터마이징(rollbackOn) : 
    * 기본 원칙과 다른 예외 처리가 필요할 때 사용
    * TransactionAttribute의 rollbackOn() 속성을 통해 특정 체크 예외에서 롤백하거나, 특정 런타임 예외에서 커밋하도록 설정 가능.
￼



* 아래 그림은 메소드 이름 패턴과 문자열로 된 트랜잭션 속성을 이용해 정의한 TransactionInterceptor 타입 빈의 예이다.
￼
* Get(조회)시작 메소드
    * 읽기 전용. 시간 제한 30분, PROPAGATION_REQUID
    * get이나 find로 시작하는 조회 전용 메소드에 읽기 전용 속성을 부여해 성능 향상.


* upgrade 시작 메소드
    * PROPAGATION_REQUID_NEW, 격리수준 SERIALIZSBLE.
    * 항상 독립적인 트랜잭션으로 동작. 다른 작업에 영향 받지 않도록 고립상태 유지해야함.


* 나머지 메소드
    * PROPAGATION_REQUIRED, 나미지 설정은 디폴트 값을 따름

* 패턴 매칭  일치
    * 하나의 메소드 이름이 여러 패턴과 일치하는 경우, 가장 정확히 일치하는 패턴이 적용됨.

￼
￼
* 트랜잭션 속성이 개별 애트리뷰트를 통해 지정될 수 있으므로 설정 내용 읽기 쉽고, XML 에디터의 자동완성 기능으로 편하게 작성 가능.




- 포인트컷과 트랜잭션 속성의 적용 전략.

* 트랜잭션 부가기능 적용할 후보 메소드를 선정하는 작업은 포인트컷에 의해 진행된다.
* Expression 애트리뷰트에 넣는 포인트컷 표현식과 <tx:attributes>로 정의하는 트랜잭션 속성만 결정하면 됨.


{ 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용함 }

* 비즈니스 로직 클래스(Service)는 일반적으로 모두 트랜잭션 적용 후보가 되는것이 적당함.

* 예시) add()메소드
    * 단순 DB추가 작업 외에도 추가적인 작업이 생길 가능성 높음.
    * 다른 트랜잭션에 참여할 가능성이 높은 트랜잭션 안에서 동작하도록 정의해야함.

* 단순조회 메소드
    * readOnly 속성을 적용하면 성능 최적화 가능.
    * 필수조건 : 복잡한 조회 시 제한시간 설정이나 격리 수준 유지 등 트랜잭션 반드시필요할 수 있음.

* 포인트컷 표현식 작성 전략(타입 패턴 vs 빈 이름)
    * 타입 패턴(execution)
        * 트랜잭션 경계가 될 클래스들이 모여있는 패키지를 통째로 선택하거나 클래스 이름 패넡ㄴ을 사용하는 것이 좋음.
        * 권장패ㅓ턴으로는 클래스보다 인터페이스 타입을 기준으로하는것이 좋음.

    * 빈 이름(bean) 
        * 클래스나 인터페이스 이름에 일정한 규칙을 만들기 어려운 경우 유용함
        * 스프링 빈 아이디를 기준으로 선정하므로 표현식이 간단하고 읽기 편함



{ 공통된 메소드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의 한다. }

* 다양한 트랜잭션 속성 부여는 관리 힘듦. -> 기준이 되는 몇가지 트랜잭션 정의 후 적절한 메소드명명 규칙 만들면 편함.

* BUT 트랜잭션 속성의 적용 패턴이 일반적인 경우와 크게 다른 옵젝이 존재함.
    * 이런 경우는 트랜잭션 어드바이스와 포인트컷을 새롭게 추가해야함.

* 가장 간단한건 모든 메소드에 대해 디폴트 속성을 지정하는 것.
￼

￼





* 아래 그림은 두 개의 포인트컷과 어드바이스를 적용한 예다.
* ]비즈니스 로직을 정의한 서비스 빈에는 기본적인 메소드 이름 패턴을 따르는 트랜잭션 속성을 지정한다.
* 반면에 트랜잭션의 성격이 많이 다른 배치 작업용 클래스를 위해서는 트랜잭션 어드바이스를 별도로 정의해서 독자적인 트랜잭션 속성을 지정해줌.
￼



{ 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메소드를 호출할 때는 적용되지 X }

* 전략이라기보단 주의사항임.
* 프록시 방식의 AOP에서는 프록시를 통한 부기기능의 적용은 클라이언트로부터 호출이 일어날 때만 가능하다. 

* 아래 그림의 delete()와 update()는 모두 트랜잭션 적용 대상인 메소드.
* 따라서 [12],[3]처럼 클라이언트로 부터 호출되야 프록시를 통해 부가기능 부여.
￼

* BUT [2]는 다름.
* 타깃 옵젝 내로 들어와서 타깃 옵젝의 다른 메소드를 호출하는 경우에는 프록시를 거치지 않고 직넙 타깃의 메소드가 호출된다.
* 같은 타깃 옵젝 안에서 메소드 호출이 일어나는 경우에는 프록시 AOP를 통해 부여해준 부가기능이 적용되지 않는 다는 점을 주의해야함. ->따라서 의식하고 개발해야함.

* 타깃 안에서 호출에는 프록시가 적용되 지 않는 문제 해결 :
    * 스프링 API 이용
        * 프록시 옵젝에 대한 레퍼런스를 가져와 강제로 프록시를 통해 호출하게 하는 방법
        * 비추천 이유 : 순수한 비즈니스 로직에 스프링 API와 프록시 코드가 섞여 들어가서 코드 지저분해짐.

    * AspectJ사용
        * 프록시 방식이 아니므로 내부 호출 여부와 상관없이 AOP가 항상 적용됨.
        * 설정 변경만으로 적용 가능하지만, 별도의 불편함이 따르므로 꼭 필요한 경우에만 사용하는 것이 좋음.




{ 트랜잭션 경계설정의 일원화 }

* 일반적으로 특정 계층의 경계를 트랜잭션 경계와 일치시키는 것이 바람직함. 
* 비즈니스 로직을 담고 있는 서비스 계층 옵젝의 메소드가 트랜잭션 경계를 부여하기에 가장 적절한 대상임.

* 서비스 계층을  트랜잭션이 시작되고 종료되는 경계로 정했다면, 테스트와 같은 특별한 이유가 아니고는 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단!

* 트랜잭션은 보통 서비스 계층의 메소드 조합을 통해 만들어지기 때문에 DAO가 제공하는 주요 기능은 서비스 계층에 위임 메소드를 만들어둘 필요가 있다.
    * 가능하면 다른 모듈의 DAO에 접근할 때는 서비스 계층을 거치도록 하는 게 바람직함. 
    * 그래야 부가로직 적용 가능, 트랜잭션 속성도 제어할 수 있기 때문.


* 아키텍처를 단순하게 가져가면 서비스 계층과 DAO가 통합될 수 있다.
* BUT 비즈니스 로직을 독자적으로 두고 테스트하려면 서비스 계층을 만들어 사용해야 함.
￼
* 아래 그림처럼 UserServiceImpl 클래스에 추가된 메소드 구현 코드 넣는다.
￼
* 이제 모든 User와 관련 데이터 조작은 UserService라는 트랜잭션 경계를 통해 진행할 경우 모든 트랜잭션을 적용할 수 있게 됐다.



{ 서비스 빈에 적용되는 포인트컷 표현식 등록 }
* aop 스키마 태그를 이용해 포인트컷, 어드바이저 등의 설정을 만들어준다.
￼
* 이제 아이디가 Service로 끝나는 모든 빈에 transactionAdvice 빈의 부가기능이 적용될 것이다.



{ 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록 }

* TransactionAdvice 클래스로 정의했던 어드바이스 빈을 스프링의 TransactionInterceptor을 이용해 변경한다.
￼
* Top 스키마의 태그를 적용했으니 어드바이스도 tx 스키마에 정의된 태그를 이용하게 만드는 것이 낫다.

￼
* 훨씬 간결해졌음



{ 트랜잭션 속성 테스트 }

* 학습테스트를 만들어보자!
* 예외상황을 만들어야되서 트랜잭션 롤백 테스트를 위해 만든 TestUserService를 활용.
* getAll()메소드를 오버라이드해서 강제로 DB에 쓰기 작업을 추가할 것.
* Expected 조건을 주지않고 테스트를 수행해 예외 때문에 테스트가 실패하는 것을 확인 후 어떤 예외가 던졌는지 확인해서 조건에 넣는다.
￼

* 이제 getAll()을 호출하는 테스트를 만든다.
￼
* 예외 발생 확인이 목적이므로 테스트가 실패하면 성공, 성공하면 실패다.


￼
* 예외가 발생하며 테스트가 실패했음.

* TransientDataAccessResourceException이라는 처음 보는 생소한 예외다. 
* 이 예외는 스프링의 DataAccessException의 한 종류로 일시적인 예외상호앙을 만났을 때 발생하는 예외임.
* 일시적이라는건 재시도하면 성공할 가능성이 있다는 의미.


* 읽기전용 속성을 위반했을 때 발생하는 예외의 종류를 알아봤으니 테스트에 반영하면?
￼
* 모두 성공할 것이다.
* 전용 스키마의 태그를 사용해서 정의한 트랜잭션 AOP가 바르게 동작하고, 메소드에 따라 적절한 트랜잭션 송성이 부여되고 있음을 확인할 수 있다.
