# 1장 오브젝트와 의존관계

## [ Spring Study - week1 ]


- 스프링은 자바기반 기술 
    * 객체지향 언어가 중요한 가치.
    * 오브젝트에 가장 많은 관심을 둔다.

- Java bean 규약이란? ****

- 자바빈
    * 원래 비주얼 툴에서 조작 가능한 컴포넌트.

    * 하지만 지금은 비주얼 컴포넌트라기보단 아래 두가지 오브젝트를 말함. 간단히 bean이라고도 부른다.
        * 디폴트 생성자 : 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를            생성하기 떄문.

        * 프로퍼티 : 빈이 노출하는 이름을 가진 속성.
            * set으로 시작하는 수정자 메소드 setter와 get으로 시작하는 접근자 메소드(getter)를 이용해 수정 또는 조회할 수 있다.

- JDBC란? ****




- JDBC 순서
￼


- DAO는 사용자 정보를 관리함.


- main() : 자신을 엔트리 포인트 기반으로 코드의 기능을 검증하고, 직접 실행 가능하게 해주는 static method.


- 객체지향에서의 분리
    * 관심이 같은 것끼리 하나의 객체 안으로 모이게하고, 관심이 다른것은 따로 떨어져 서로 영향을 주지 않는 것.
    * 중복 코드 메서드 추출. -> 메소드 추출기법.
    * 이러한 작업을 리팩토링(refactoring)이라 한다.


- 리팩토링
    * 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업.
        * 코드 이해 쉬움.
        * 변화에 효율적으로 대응가능.
        * 코드 품질 up
        * 유지보수 쉬워짐.


- 상속과 추상메소드
    * 상속과 추상메소드 활용으로 더 분리할 수 있다. 
    * 상속
        * 부모 클래스의 속성과 기능을 자식 클래스가 물려받는 것.
            * 코드 재사용성.
            * 유지보수 용이.
            * 계층 구조 형성
    * 추상 메소드
        * 선언만 있고, 실제 구현 코드는 없는 메소드.
        * 반드시 추상 클래스 내부에서 
        * 스스로 객체(인스턴스) 생성 불가능.
    * 추상 메소드는 상속받는 자식 클래스에서 반드시 재정의(오버라이딩)하여 구현해야한다

    * 상속과 추상 메소드는 상호보완적 관계. 상속은 강제성이 없지만, 추상 메소드를 사용하면 상속 관계에 강제성 부여할 수 있다.

    * 자바는 다중상속을 허용하지 않는다.

    * 상속은 관심이 다른 기능을 분리하고, 필요에따라 변신가능하게 확장성이 좋다.



- 클래스의 분리
    * 상속이 아닌 독립적인 클래스로 만든다. 
        * 단점 : 상속이 되어있지 않기 때문에 커넥션이 없어져 코드 수정없이 기능을 변경할 방법이 없다.
        * 해결하기위해 인터페이스를 도입.

- 인터페이스
    * 클래스간의 긴밀한 연결고리 역할.
    * 구현한 클래스에 대한 구체적인 정보는 모두 감춘다.
    * 인터페이스로 추상화 해놓은 통로로 접근한다. -> 실제 구현 클래스를 바꿔도 신경 안써도된다.
    * 클래스 사이에 관계가 만들어진다는 것은 인터페이스 없이 다른 클래스를 직접 사용한다는 뜻이다. 그러므로 클래스가 아니라 오브젝트와 오브젝트 사이의 관계를 설정해줘야 한다.(의존관계)

    * 코드에서는 특정 클래스를 몰라도 해당 클래스가 구현한 인터페이스를 사용했다면, 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용할 수 있는데, 이것이 객체지향에서 다형성이라는 특징이다.


- 객체지향 기술의 여러가지 이론
    * 개방 폐쇄 원칙(OCP, Open-Close Principle)
        * 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

    * 설계 원칙(SOLID)
        * SRP(Single Responsibility Principle) : 단일 책임 원칙.
        * OCP(Open-Close Principle) : 개방 폐쇄 원칙.
        * LSP(Liskov Substitution Principle) : 리스코프 치환 원칙.
        * ISP(Interface Segregation Principle) : 인터페이스 분리 원칙.
        * DIP(Dependeny Inversion Principle) : 의존관계 역전 원칙.

- 개방 폐쇄 원칙
    * 높은 응집도와 낮은 결합도
        * 높은 응집도 : 화가 일어나면 변하는 부분이 크다. 일부분만 바뀌면 오류를 일일이 확인해야된다.
        * 낮은 결합도 : 변화에 대응하는 속도 up, 확장하기 매우 편리.



- 제어의 역전( IoC, Inversion of Control ) *****
    * 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는것을 의미.(권한을 개발자가 아닌 스프링 프레임워크에 넘기는 것을 의미.)
    * 원래는 모든 오브젝트가 능동적으로 자신이 사용할 클래스를 결정하고, 오브젝트를 만들지 스스로 관장한다.
    * 장점 :
        * 낮은 결합도 
        * 높은 재사용성과 유연성 
        * 테스트 용이성 : 의존성을 외부에서 주입받아서.
        * 유지보수성 향상 : 비즈니스 로직과 객체 관리가 분리.


- 팩토리(Factory)
    * 오브젝트를 생성하는 쪽과 생성된 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하려는 목적으로 사용.
    * 관심을 분리하고 책임을 나누고 유연하게 확장 가능한 구조로 만드는 작업.
￼

    * 애플리케이션 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다는데 큰 의미가 있음.


    * 프레임워크도 제어의 역전 개념이 들어가는데, 프레임 워크 위에 개발한 클래스를 두고, 흐름을 주도하는 중에 개발자가 만든 애플리케이션 코드를 사용하도록 만드는 방식.


- 오브젝트 팩토리를 이용한 스프링 loC
    * 스프링에서는 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트를 빈(bean)이라고 한다. 

    * 빈의 생성과 관계설정과 같은 제어를 담당하는 loC 오브젝트를 “ 빈 팩토리 “라고한다.

    * 보통은 빈 팩토리보다는 이를 좀 더 확장한 “ 애플리케이션 컨텍스트(application context) “를 주로 이용한다

    * 스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration이라는 애노테이션을 추가함.

    * 오브젝트를 만들어주는 메소드에는 @Bean 애노테이션을 붙여줌.


- ApplicationContext 타입의 객체
    * loC와 더불어 컨테이너의 중앙 역할을 담당하는 스프링 컨테이너. BeanFactory를 상속받아 확장된 인터페이스.
    * Bean의 생성과 관리뿐만 아니라 엔터프라이즈급 애플리케이션 개발을 위한 다양한 부가 기능을 제공.
        * 빈 생명주기 관리
        * 의존성 주입(DI)
        * 프로퍼티 설정 및 환경 관리
        * 리소스 관리
        * 국제화 지원
        * 이벤트 발행 등등..


- @Bean에서 UserDao처럼 메소드는 하나뿐인데 굳이 사용하는 이유?
    * 생성하는 방식이나 구성을 다르게 가져가는 메소드를 추가할 수 있기 때문.
    * 제네릭(generic) 메소드 방식을 사용해 파라미터에 리턴 타입을 주면, 지저분한 캐스팅 코드를 안써도 된다.


- ApplicationContext 장점
    * 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.

    * 종합 IoC 서비스를 제공해준다.
        * 오브젝트 생성과 관계설정 뿐만 아니라 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져가듯이 활용도가 높다.

    * 빈을 검색하는 다양한 방법을 제공.


- 빈(bean)
    * 스프링이 IoC 방식으로 관리하는 오브젝트. 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만 빈이다.

- 빈 팩토리
    * IoC를 담당하는 핵심 컨테이너. 빈을 등록, 생성, 조회, 돌려주고… 보통은 빈 팩토리 바로 사용보단 확장한 애플리케이션 컨텍스트를 이용한다. BeanFactory라고 붙여쓰면 빈 팩토리가 구현하고 있는 가장 기본적인 인터페이스 이름이 된다. 이 인터페이스에 getBean()과 같은 메소드가 정의되어 있다.

- 애플리케이션 컨텍스트
    * ApplicationContext는 BeanFactory를 상속한다.

- 설정정보/설정 메타정보(configuration metadata)
    * AC와 BF가 IoC를 적용하기 위해 사용하는 메타정보를 말함. 영어로 “ configuration ” 라고 함.
    * IoC 컨테이너에 으해 관리되는 애플리케이션 오브젝트를 생성하고 구성할때 사용.
    * 애플리케이션의 형상정보라고도 부름.




- 스프링이 싱글톤으로 빈을 만드는 이유
    * 자바 엔터프라이즈 기술을 사용하는 서버환경이기 떄문이다.

    * 매번 클라이언트에서 요청이 올떄마다 로직을 담당하는 오브젝트를 만들면 서버에 부하가오고 감당하기 힘들다.

    * 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어서 사용하는 것이 싱글톤 패턴의 원리이다. 서버 환경에서는 서비스 싱글톤의 사용이 권장된다.


- 싱글톤 구현 방법
￼



- 싱글톤 패턴 구현 방식의 문제
    * Private 생성자를 갖고 있기 떄문에 상속할 수 없다.
        * 다형성 적용 불가능.
        * 객체지향적인 설계의 장점 적용 어려움.
        * 객체지향 특징이 적용되지 않는 static 필드와 method를 사용하는 것도 문제 발생.

    * 테스트하기가 어렵다.
        * 싱글톤은 만들어지는 방식이 제한적이기 떄문에 테스트에서 사용될 때 오브젝트 등 대체가 어렵다.

        * 필요한 오브젝트를 만들어 사용할 수 밖에 없기 떄문에 테스트용 오브젝트로 대체하기 어려움.

        * 서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못함.

        * 전역 상태를 만들 수 있기 떄문에 바람직하지 않음.


- 싱글톤과 오브젝트의 상태
    * 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용되는 경우 상태정보를 내부에 갖고 있지 않은 무상태(stateless) 방식으로 만들어져야 한다. 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱틀톤 인스턴스 변수를 수정한는 것은 위험하다.

    * 이때는 파라미터와 로컬 변수, 리턴 값 등을 이요하면된다. -> 새로운 값을 저장할 독립적인 공간이 만들어지기 때문.



- IoC와 DI(Dependency Injection)
    * IoC 기능의 대표적인 동작원리는 주로 의존관계 주입이라고 불린다.

    * 오브젝트는 다른 오브젝트에 주입할 수 있느게 아니다. 오브젝트의 레퍼런스가 전달된 뿐.

    * 오브젝트 레퍼런스를 외부로부터 제공 받고 이를 여타 오브젝트와 다이내믹하게 의존관계가 만들어 지는 것이 핵심.

- 의존관계 주입의 조건
    * 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 Interface에만 의존해야된다.

    * 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정한다.

    * 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.


- DI(Dependency Injection)
    * 주입이라는 건 외부에서 내부로 무엇인가를 넘겨줘야 하는데, 자바에서는 파라미터로 오브젝트의 레퍼런스를 전달해준다.

    * 가장 손쉽게 사용할 수 있는 것이 파라미터 전달이 간으한 메소드는 바로 생성자이다.

- 의존관계 검색(Dependency Lookup)
    * 런타임 시 의존관계를 결정하는 점에서 스스로 검색을 이용하기 떄문에 의존관계 검색이라고 불리우는 것이 있음.

    * 자신이 어떤 클래스의 오브젝트를 이용할지 결정하는 것이 아닌 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

    * 하지만 의존관계 검색보다 의존성 주입이 더 바람직하다.(훨씬 단순하고 깔끔하기 떄문).




- 메소드를 이용한 의존관계 도입
    * 수정자 메소드를 이용한 주입
        * Setter 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 사용
        * 항상 set으로 시작.

    * 일반 메소드를 이용한 주입
        * set으로 시작해야하고 한번에 한 개의 파라미터만 가질 수 있다.
