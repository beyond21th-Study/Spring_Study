# 개요
- 스프링의 근간은 오브젝트
- 스프링은 객체지향 설계와 구현에 관해 까다롭지는 않지만 어떻게 효과적으로 설계, 구현, 사용, 개선할지 기준을 마련
- 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 방식을 손쉽게 사용할 수 있도록 프레임워크 형태로 제공

# 자바빈
- 원래는 비주얼 툴에서 조작 가능한 컴포넌트
- 현재는 다음 관례를 따라 만들어진 오브젝트
## 기준 1: 디폴트 생성자
- 자바빈은 파라미터가 없는 디폴트 생성자를 가져야 함
- 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요
## 기준 2: 프로퍼티
- 자바빈이 노출하는 이름을 가진 속성을 프로퍼티라 함
- setter 또는 getter를 이용해 수정 또는 조회

# 관심사의 분리
## 코드 변화의 이유
- 상황이 변함에 따라 코드를 개선해야 할 필요가 있음 
- 객체지향 프로그래밍은 절차적 프로그래밍에 비해 초기에 더 많은 작업을 요구
- 객체지향이 변화에 효과적으로 대처할 수 있기 때문
## 분리
- 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어남
- 하지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많음
- 관심이 같은 것끼리는 모으고 다른 것은 떨어져 있게 하는 것이 좋음
- 즉, 관심이 같은 것끼리는 하나의 객체 또는 친한 객체로
- 관심이 다른 것은 따로 떨어져서 서롱 영향을 주지 않도록 분리
- 같은 관심에 효과적으로 집중할 수 있도록 만들어줌

# 추출
- 중복 코드의 메소드를 추출
- 중복된 코드를 메소드로 추출해 놓으면 해당 기능에 대한 변경이 생길 때 메소드 하나만 수정하면 됨
## 리팩토링
- 기능에 영향을 주지 않으면서 내부 구조를 변경해 재구성
- 코드 내부의 설계 개선으로 코드의 이해가 더 쉬워짐
- 변화에 효율적으로 대응 가능
- 생산성, 코드 품질 상승
- 유지보수하기 쉬움
## 메소드 추출
- 공통의 기능을 담당하는 메소드로 중복된 코드를 뽑아내는 것

# 상속을 통한 확장
- 추상 메소드를 갖는 클래스를 상속받아 사용하면 해당 메소드를 수정해 사용 가능
- 클래스 계층구조를 통해 여러 관심을 독립적으로 분리하며 변경 작업 용이

# 탬플릿 메소드 패턴
- 디자인 패턴 중 하나
## 방법
1. 슈퍼클래스에 기본적인 로직의 흐름 생성
2. 기능의 일부를 추상 메소드나 오버라이딩 가능한 protected 메소드 등으로 설정
3. 서브클래스에서 해당 메소드를 필요에 맞게 구현해 사용

# 팩토리 메소드 패턴
- 디자인 패턴 중 하나로 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것
- 상속을 통해 기능을 확장
- 주로 인터페이스 타입으로 오브젝트를 리턴하기 때문에 서브클래스에서 정확히 어떤 클래스의 오브젝트를 만들어 리턴할 지는 슈퍼클래스에서 알지 못 함
- 서브클래스에서 같은 클래스의 오브젝트를 반환할 수 있지만 해당 오브젝트를 생성하는 방식이 다르다면 팩토리 메소드 패턴으로 인정
## 단점
1. 자바는 클래스의 다중 상속을 허용하지 않기 때문에 이미 특정 클래스를 상속 중이라면 사용할 수 없음
2. 상속을 통한 클래스 관계는 밀접함
  - 서브클래스는 슈퍼클래스의 기능을 직접 사용 가능
  - 따라서 슈퍼클래스 내부의 변경 시 모든 서브클래스를 함께 수정하거나 다시 개발해야 할 수도 있음
  - 또는 슈퍼클래스가 더 이상 변화하지 않도록 제약이 필요할 수도 있음 

# 디자인 패턴
- 특정 상황을 해결할 수 있는 재사용 가능한 솔루션
## 장점
- 간단한 패턴 이름 언급으로 설계의 의도와 해결책을 함께 설명 가능
## 보통의 해결 방식
1. 클래스 상속
2. 오브젝트 합성

# 완전한 다른 클래스로 분리
- 필요한 클래스에서 객체를 생성하고 메소드 사용
## 단점
1. 기능의 분리만이 이루어졌을 뿐 객체를 생성하기 때문에 기능의 변경 시 사용하는 쪽의 코드 수정이 불가피
2. 호출하는 쪽이 사용되는 쪽의 클래스에 대한 정보(메소드 이름 등)에 대해 너무 많이 알고 있어야 함
  - 따라서 객체를 사용하는 구체적인 방법에 종속되어버림
  - 자유로운 확장 불가

# 인터페이스 사용
- 두 개의 클래스가 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리 생성
- 인터페이스로 추상화해놓은 상태에 접근할 대는 오브젝트를 만들 때 사용할 클래스에 대해 몰라도 됨
- 인터페이스는 기능만 정해놓은 것이지 구현 방법은 정해져 있지 않기 때문
- 메소드의 이름만 지어놓으면 타 클래스에서 다양한 방식으로 구현 가능

# 객체 사이의 관계
- 객체 사이의 관계는 런타임 시 한 쪽이 다른 객체의 레퍼런스를 갖고 있는 형식으로 만들어짐
- 관계를 가질 객체는 직접 생성자를 호출해 만들거나 외부에서 만들어준 것을 가져옴
  - 외부에서 만든 객체는 메소드 파라미터나 생성자 파라미터로 받아옴
- 클래스 간이 아니라 객체 사이에 관계가 생기는 것은 괜찮음
- 특정 클래스의 오브젝트를 인터페이스 타입으로 받으면 클래스 사이의 관계가 아님
## 클래스 사이의 관계
- 클래스 사이의 관계는 코드에 다른 클래스 이름이 나타나기 때문에 만들어짐

# 클라이언트
- 클래스 사이의 관계와 오브젝트 간 관계를 맺는 책임을 가짐
- 클래스 간의 중재자 역할
## 클라이언트와 인터페이스 도입의 장점
- 상속을 사용하는 방식에 비해 유연
  - 특정 인터페이스를 사용하기만 하면 다른 클래스에도 구현 방식을 그대로 적용 가능
  - 기능에 대해 변경사항이 생겨도 한 곳의 코드만 수정하면 됨
  
# 객체지향 설계 원칙
- 깔끔한 설계를 위한 객체지향 설계 원칙
## SOLID
1. SRP The Single Responsibility Principle: 단일 책임 원칙
2. OCP The Open Closed Principle: 개방 폐쇄 원칙
3. LSP The Liskov Substitution Principle: 리스코프 치환 원칙
4. ISP The Interface Segregation Principle: 인터페이스 분리 원칙
5. DIP The Dependency Inversion Principle: 의존관계 역전 원칙

# 높은 응집도와 낮을 결합돠
## 높은 응집도
- 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻
- 변화가 일어날 때 해당 모듈에서 변하는 부분이 큼
- 여러 곳을 보지 않아도 되는 이점
## 낮은 결합도
- 책임과 관심사가 다른 오브젝트 또는 모듈과 느슨하게 연결되어 있다는 뜻
- 관계를 유지하는데 필요한 최소한의 방법만 간접적인 형태로 제공
- 나머지는 독립적이고 알 필요 없는 형태로 유지
- 변화에 대응하는 속도가 높아지고 구성이 깔끔해짐
- 하나의 오브젝트에 변경이 있을 때 관계를 맺고 있는 다른 오브젝트에 변경을 적게 요구

# 전략 패턴
- 자신의 기능 맥락에서 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리
- 구현한 알고리즘 클래스를 필요에 따라 바꿔서 사용 가능하게 하는 디자인 패턴

# 제어의 역전 IoC
- Inversion of Control
- 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않음
- 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하는 것
- 설계가 깔끔해지고 유연성이 증가하며 확장성이 좋아짐
## 팩토리
- 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 역할을 하는 클래스
- 오브젝트를 사용하는 쪽의 역할과 책임을 깔끔하게 분리하기 위해 사용

# 스프링의 IoC
## 빈 Bean
- 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
- 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
## 빈 팩토리 Bean Factory
- 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트
## 애플리케이션 컨텍스트 Application Context
- IoC 방식을 따라 만들어진 일종의 빈 팩토리
- 빈 팩토리와 동일
- 구성요소의 제어 작업에 초점을 맞춘 단어
- 별도의 정보를 참고해 빈의 생성, 관계설정 등의 제어 작업 총괄
- 코드 내에 정보를 담고 있지는 않고 다른 곳에서 참조
- ApplicationContext 타입의 오브젝트
- AnnotationConfigApplicationContext 생성자에 @Configuration이 붙은 클래스를 넣어주면 됨
## getBean(bean_name, class)
- ApplicationContext가 관리하는 오브젝트를 요청하는 메소드
- 기본적으로 Object 타입을 리턴하기 때문에 캐스팅 해 주어야 함
## @Configuration
- 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
## @Bean
- 오브젝트 생성을 담당하는 IoC용 메소드라는 표시

# 애플리케이션 컨텍스트의 동작 방식
- IoC 컨테이너, 스프링 컨테이너, 빈 팩토리라고도 부름
- BeanFactory 인터페이스를 상속하기 때문에 일종의 빈 팩토리인 것
- 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당
- @Configuration이 붙은 클래스에서 설정 정보를 등록해 두고 @Bean이 붙은 메소드의 이름을 가져와 빈 목록을 만들어 둠
- 클라이언트가 애플리케이션 컨텍스트의 getBean() 메소드를 호출하면 빈 목록에서 요청한 이름이 있는지 찾고 있다면 빈을 생성하는 메소드를 호출해 오브젝트 생성 후 클라이언트에게 돌려줌
## 애플리케이션 컨택스트 사용 시의 장점
### 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없음
- 클라이언트가 필요한 오브젝트를 가져오려면 사용할 팩토리 메소드를 알아야 하고 필요할 때마다 오브젝트를 생성해야 함
- 애플리케이션 컨텍스트를 사용하면 직접 할 필요가 없음
- 일관된 방식으로 원하는 오브젝트 가져올 수 있음
### 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공
- 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수 있음
- 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정방식의 다변화 등 오브젝트를 효과적으로 활용할 수 있는 다양한 기능 제공
- 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템과의 연동 등을 컨테이너 차원에서 제공하기도 함
### 빈을 검색하는 다양한 방법 제공
- getBean() 메소드는 빈의 이름을 이용해 빈을 찾아줌
- 타입만으로 빈을 검색하거나 특정 어노테이션 설정이 되어 있는 빈을 찾을 수도 있음

# 스프링 IoC 용어 정리
## 빈 Bean, 빈 오브젝트 Bean Object
- IoC 방식으로 관리하는 오브젝트
- aka 관리되는 오브젝트 managed object
- 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 빈은 아님
- 스프링이 직접 생성과 제어를 담당하는 오브젝트만이 빈
## 빈 팩토리 Bean Factory
- 스프링의 IoC를 담당하는 핵심 컨테이너
- 빈을 등록, 생성, 조회, 리턴 등 부가적인 빈을 관리하는 기능을 담당
- 보통 이를 확장한 애플리케이션 컨텍스트를 사용
## 애플리케이션 컨텍스트 Application Context
- 빈 팩토리를 확장한 IoC 컨테이너
- 빈을 등록하고 관리하는 기본적인 기능은 빈 팩토리와 동일
- 스프링이 제공하는 각종 부가 서비스를 추가로 제공
- 빈의 생성과 제어에 더해 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것
- BeanFactory를 상속
- 해당 오브젝트는 하나의 애플리케이션에서 보통 여러 개가 만들어져 사용됨
## 설정정보/메타정보 Configuration Metadata
- 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
- 컨테이너의 어떤 기능을 세팅, 조정하거나 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용
## 컨테이너 Container 또는 IoC 컨테이너
- IoC 방식으로 빈을 관리한다는 의미에서 애플리케이션 컨텍스트나 빈 팩토리를 지칭하는 말
## 스프링 프레임워크
- IoC 컨테이너, 애플리케이션 컨텍스트를 포함해 스프링이 제공하는 모든 기능을 통틀어 말하는 것

# 오브젝트의 동일성과 동등성
## 동일성 Identity
- 아예 같은 오브젝트
- == 연산자로 비교
## 동등성 Equality
- 갖는 값이 같은 것
- equals() 메소드로 비교

# 싱글톤 패턴
- 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려줌
- 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 함
- input이 많기 때문에 엔터프라이즈 분야에서 싱글톤으로 사용하는 것
## 싱글톤 패턴 사용 방법
1. 클래스 밖에서 오브젝트를 생성하지 못 하도록 생성자를 private로 만듬
2. 생성된 싱글톤 오브젝트를 저장할 수 있는 자신과 같은 타입의 스태틱 필드 정의
3. 스태틱 팩토리 메소드인 getInstance()를 만들고 이 메소드가 최초로 호출되는 시점에서 한 번만 오브젝트 생성
4. 생성된 오브젝트는 스태틱 필드에 저장
  - 또는 스태틱 필드의 초기값으로 오브젝트를 미리 만들어 둘 수 있음
5. getInstance() 메소드를 통해 이미 만들어져 스태틱 필드에 저장해둔 오브젝트를 넘겨줌
## 싱글톤 패턴의 문제점
### private 생성자를 갖고 있기 때문에 상속 불가능
- 상속과 이를 이용한 다형성 적용 불가
- 객체 지향의 장점이 퇴색
### 테스트하기 힘듬
- 만들어지는 방식이 제한적이기 때문에 테스트에서 사용될 때 목 오브젝트로의 대체가 힘듬
- 필요한 오브젝트는 직접 오브젝트를 만들어 사용할 수밖에 없음
### ㅅ어버 환경에서는 싱글톤이 하나만 생성되는 것을 보장하지 못 함
- 서버의 구현 방식에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 만들어질 수 있음
- 서버 환경에서 꼭 싱글톤이 보장된다고 보기는 어려움
### 전역 상태를 만들수 있기 때문에 바람직하지 못 함
- 싱글톤의 스태틱 메소드를 이용해 언제든지 접근 가능하기 때문에 자연스럽게 전역 상태로 사용되기 쉬움

# 싱글톤 레지스트리
- 스프링이 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능
- 스프링 컨테이너가 싱글톤 레지스트리
- 싱글톤 생성, 관리, 공급
## 장점
- 스태틱 메소드와 private 생성자를 사용하지 않아도 되고 평범한 자바 클래스를 싱글톤으로 활용하게 해 줌
- 평범한 클래스도 IoC 방식의 컨테이너를 사용해 생성과 관계설정, 사용 등에 대한 제어권을 컨테이너에 넘기면 싱글톤 방식으로 관리 가능
  - 오브젝트 생성에 관한 모든 권한은 애플리케이션 컨텍스트에게 있기 때문에 가능한 것
- 싱글톤으로 사용되어야 하는 환경이 아니라면 간단히 오브젝트를 생성해 사용 가능
- public 생성자를 가질 수 있음

# 싱글톤과 오브젝트의 상태
- 싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해 사용 가능
  - 따라서 상태 관리에 주의해야 함
- 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사용될 때는 상태 정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어져야 함
- 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 오브젝트의 인스턴스 변수를 수정하는 것은 매우 위험
  - 자기 값을 저장하고 다른 값을 읽어올 수 있기 때문
- 따라서 싱글톤은 기본적으로 인스턴스 필드의 값을 변경하고 유지하는 상태유지 방식으로 만들지 않음
- 이 때 여러 정보를 다루기 위해 파라미터, 로컬 변수, 리턴 값 등을 이용
  - 메소드 파라미터나 메소드 안에서 생성되는 로컬 변수는 매번 새로운 값을 독립적으로 저장하는 공간을 만들기 때문에 여러 스레드가 변수의 값을 덮어쓰지 않음
- 읽기 전용 정보라면 인스턴스 변수로 사용해도 상관 없음

# 빈의 스코프 Scope
- 빈이 생성되고, 존재하고, 적용되는 범위
- 기본 스코프는 싱글톤
  - 싱글톤 스코프는 컨테이너 내의 한 개의 오브젝트만 만들어져 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지
  
# 의존관계 주입 Dependency Injection
- 스프링 IoC 기능의 대표적인 동작 원리
- 오브젝트 레퍼런스를 외부로부터 제공받고 이를 통해 다른 오브젝트와 동적으로 의존관계가 만들어지는 것
- 구체적인 의존 오브젝트와 그것을 사용할 주체(보통 클라이언트 오브젝트)를 런타임 시에 연결해 주는 작업
- DI를 원하는 오브젝트는 자신이 먼저 컨테이너가 관리하는 빈이 되어야 함
## 의존관계
- A가 B에게 의존하고 있다면, B가 변할 때 A에게 영향을 미친다는 것
- ex. A에서 B에 정의된 메소드를 사용하는 것
  - 상ㅇ에 대한 의존관계가 있다고 함
- 인터페이스에 대해서만 의존관계를 만들어 두면 인터페이스 구현 클래스와의 관계는 느슨해지며 변화에 영향을 덜 받게 됨
### 런타임/오브젝트 의존관계
- 런타임 시에 오브젝트 사이에서 만들어지는 의존관계
- 모델링 시점의 의존관계와는 다름
- 인터페이스를 통한 의존관계는 런타임 시에 사용할 오브젝트가 어떤 클래스로 만든 것인지 미리 알 수 없음
- 실제 사용 대상인 오브젝트를 의존 오브젝트라 함
## 의존관계 주입의 조건
1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않음
  - 인터페이스에만 의존하고 있어야 함
2. 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제 3의 존재가 결정
  - 제 3의 존재는 관계설정 책임을 가진 코드를 분리해 만들어진 오브젝트
3. 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만들어짐
## DI 컨테이너
- 의존관계 주입을 담당하는 컨테이너
- 자신이 결정한 의존관계를 맺어줄 클래스의 오브젝트를 만들고 생성자의 파라미터로 오브젝트의 레퍼런스 전달

# 의존관계 검색
- 의존관계를 외부로부터 주입받는 것이 아니라 스스로 검색을 이용해 만들어냄
- 필요한 객체를 요청해 받는 것
- 대개는 의존관계 주입을 사용하는 것이 나음
## 의존관계 주입과 검색의 차이점
- 검색은 자신이 요청하는 것이기 때문에 자신이 스프링의 빈일 필요가 없음

# 의존관계 주입의 응용
## 기능 구현의 교환
- 특정 기능을 사용하기 위한 객체를 컨테이너로부터 주입받기 때문에 다른 기능으로의 변경이 쉬움
## 부가기능 추가
- 중간에 클래스를 추가하거나 호출하는 클래스를 변경해 의존관계를 다르게 넣어주면 원래의 기능이 바뀌거나 코드를 수정해야 하는 일이 적게 부가기능을 추가할 수 있음

# 메소드를 이용한 의존관계 주입
## 수정자 메소드를 이용한 주입
- 수정자(setter) 메소드는 외부에서 오브젝트 내부의 애트리뷰트 값을 변경하려는 용도로 주로 사용됨
- 수정자의 핵심 기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것
- 입력 값에 대한 검증이나 그 밖의 작업을 수행할 수도 있음
- 외부로부터 제공받은 오브젝트 레퍼런스를 저장해 뒀다가 내부의 메소드에서 사용하게 하는 DI 방식에서 활용하기에 적당
## 일반 메소드를 이용한 주입
- 한 번에 한 개의 파라미터만 갖는 수정자 메소드 대신 사용
- 여러 개의 파라미터를 갖는 일반 메소드를 DI 용으로 사용하는 것
- 여러 개의 초기화 메소드를 만들 수도 있기 대문에 한 번에 모든 필요한 파라미터를 받아야 하는 생성자보다 나음
- 단, 파라미터가 많아지면 실수하기 쉬움


# 1장 정리
## 1. 관심사의 분리, 리팩토링
- 책임이 다른 코드를 분리해 각기 다른 클래스로 생성
## 2. 전략 패턴
- 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 설계 후 다른 클래스에서 인터페이스를 통해 접근하도록 함
- 따라서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도 그 기능을 사용하는 클래스의 코드는 수정할 필요가 없음
## 3. 개방 폐쇄 원칙
- 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않음
- 자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경 가능
## 4. 높은 응집도, 낮은 결합도
- 낮은 결합도: 한 쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않음
- 높은 응집도: 자신의 책임과 관심사에만 순수하게 집중
## 5. 제어의 역전 IoC
- 오브젝트가 생성되고 다른 오브젝트와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘김
- 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨 오브젝트가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만듬
## 6. 싱글톤 레지스트리
- 서버에서 사용되는 서비스 오브젝트로서의 장점을 살릴 수 있는 싱글톤 패턴
- 싱글톤 패턴의 단점을 극복할 수 있도록 컨테이너 활용
## 7. 의존관계 주입 DI
- 런타임 시에 실제 사용할 구체적인 의존 오브젝트를 제 3자의 도움으로 주입받아 동적인 의존관계를 가짐
## 8. 생성자 주입과 수정자 주입
- 의존 오브젝트를 주입할 때 생성자와 수정자 메소드를 이용

