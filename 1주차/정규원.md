# 1장 오브젝트와 의존관계

## 스프링을 이해하기 위해서는 오브젝트에 깊은 관심을 가져야한다.

애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정을 진지하게 생각해봐야 한다.

## 1.1 초난감 DAO

### 1.1.1 User

```java
public class User {
    String id;
    String name;
    String password;
    
    getter/ setter 등등
}
```

사용자 정보를 저장하는 자바빈 규약을 따르는 오브젝트

### 1.1.2 UserDAO

DAO 란 Data Access Object의 약자로 DB를 사용해 데이터를 조작하기 위해 만든 오브젝트를 의미한다.

```java
package springbook.user.dao;

import springbook.user.domain.User;

import java.sql.*;

public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

위 예시는 사용자를 생성하고, 아이디를 가지고 사용자 정보를 읽어오는 한개의 메소드를 만든 것이다.

이 코드가 정말 제대로 동작하는지 어떻게 확인할 수 있을까?

### 1.1.3 main()을 이용한 테스트 코드

```java
public static void main(String[] args) throws SQLException, ClassNotFoundException {
  UserDao dao = new UserDao();

  User user = new User();
  user.setId("sasca");
  user.setName("jalgayo");
  user.setPassword("jalgayo");

  dao.add(user);
  System.out.println(user.getId() +" 등록 성공");

  User user2 = dao.get(user.getId());
  System.out.println(user2.getName());
  System.out.println(user2.getPassword());

  System.out.println(user2.getId() +" 조회 성공");

}
```

위 예시 코드를 실행해서 잘 동작한다면, 등록과 조회가 잘 될것이다.

그런데 지금 만든 UserDao 클래스 코드에는 사실 여러가지 문제가 있다.

이를 객체지향 기술의 원리에 충실한 멋진 스프링 스타일의 코드로 개선해보면서 의문을 던져본다.

왜 이 코드에 문제가 많다고 하는지? 잘 동작하는 코드를 굳이 수정하고 개선을 왜 해야하는지? 등등 다양한 의문이 들텐데 이는 다음 챕터에서 설명하겠다.

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

개발자가 객체를 설계할때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비해야할 것인가이다.

왜? 이러한 고민을 하는것인가에 대한건 사용자의 비즈니스 프로세스와 그에 따른 요구사항이 끊임없이 바뀌고 발전하면서 변경에 대한 변화가 갑자기 발생할 수 있다.

→ 어떻게 대응 하는가?

분리와 확장을 고려한 설계로 필요한 작업을 최소화 할 수 있다.

관심사에 대한 분리 : 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.
처음에는 모든 것을 뭉뚱그려서 한데 모으는 편이 쉽고 편하지만, 언젠가는 그 뭉쳐 있는 여러 종류의 관심사를 적절하게 구분하고 따로 분리하는 작업을 해줘야만 할때가 온다. 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어 준다.

### 1.2.2 커넥션 만들기의 추출

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

```java
public class UserDao{
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    
    private Connection getConnection() throws ...{
        Class.forName(...)
        Connection c = Driver...
        return c;
    }
}
```

왼쪽 코드와 오른쪽 코드의 차이점이 보이는가?

UserDao의 관심사항으로는

첫째, DB와 연결을 위한 커넥션을 어떻게 가져올까라는 **관심**이다. ( 어떤 드라이버?, 어떤 로그인 정보? 등등)

둘째, DB에 보낼 SQL Statement를 만들고 **실행** 시키는것.

셋째, 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘 소중한 공유 리소스를 시스템에 **돌려**주는 것이다.

왼쪽 코드에서 가장 문제되는것은 Connection 오브젝트를 가져오는 부분이다. DB 커넥션을 가져오는 부분에서는 다른 관심사와 섞여서 같은 add() 메소드에 담겨있고, 이 코드 또한 get() 메소드안에도 **중복**되어 있다는 점이다.

만약 이 코드를 확장시켜 다른 추가 메소드 (ex, 삭제와 관련된 delete메소드 추가)를 작성한다면 Connection코드가 중복되어 나타날 것이다.

이렇게 하나의 관심사가 중복되어 있고, 여기저기 흩어져서 다른 관심의 대상과 얽혀있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 되어 스파게티 코드가 된다.

오른쪽의 코드는 Connection과 관련된 부분을 각 메소드에서 떼어내 메소드를 만들고 add()와 get()에서는 이 커넥션 객체를 가져오는 방식으로 중복을 제거하였다.

만약 DB의 종류와 접속 부분이 바뀌어서 드라이버 클래스와 URL이 바뀌었을 경우 Connection을 수정하는 부분만 변경하면 되기때문에 다른 메소드에 영향을 주지 않고, 관심 내용이 독립적으로 존재하므로 수정이 간단해졌다.

이런 작업을 **리팩토링**이라고 한다. 또한 위해서 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출 기법**이라고 부른다.

리팩토링 : 기존의 코드를 외부의 동작방식에서는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 코드의 내부 설계가 개선되어 이해하기 편해지고, 변화에 효율적으로 대응할 수있다는 장점이 있다. 생산성 증대, 코드의 품질 향상, 유지보수 용이, 견고하면서 유연한 제품을 개발할 수 있다.

### 1.2.3 DB 커넥션 만들기의 독립

만약 UserDao를 사용하는 기업이 N사와 D사에 납품한다고 가정해보자

N사와 D사 모두 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶다?

→ 어떻게 하면 소스코드 제공 없이 N사와 D사에 제공해주지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적용할 수 있을까?

**상속에 의한 확장**

UserDao에서 메소드의 구현코드를 제거하고 getConnection을 추상 메소드로 만들어 놓는다.

```java
public class UserDao{
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    
    private Connection getConnection() throws ...{
        Class.forName(...)
        Connection c = Driver...
        return c;
    }
}
```

```java
public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    public abstract Connection getConnection() throws ... ;
}

```

추상 메소드는 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add()와 get() 메소드에서 원하는 코드를 유지할 수 있다.

이 추상 클래스인 UserDao를 N사와 D사에게 판매를 하고, 구입한 회사에서는 이 클래스를 상속받아 NUserDao와 DUserDao라는 서브 클래스를 만들고 그들이 원하는 요구사항에 맞춰 확장 하도록 하면 UserDao의 기능과 함께 사용할 수 있다.

기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 상속을 통한 서브클래스로 분리해버리는 것이다.

![image.png](image.png)

![image.png](image%201.png)

DAO의 핵심 기능인 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당하는 UserDao와, DB 연결 방법을 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

UserDao는 변경이 용이하다라는 수준을 넘어서 손쉽게 확장된다고 한다,

위와 같이 슈퍼클래스(UserDao)에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected(public 에서 전체만 빠진 부분) 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.

![image.png](image%202.png)

UserDao의 getConnection 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다. UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고 볼 수 있다. 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**이라고 부르기도 한다.

NUserDao와 DUserDao가 모두 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴할 수도 있다.

그래도 오브젝트를 생성하는 방식이 다르다면, 팩토리 메소드 패턴으로 이해할 수 있다.

팩토리 메소드 패턴과 템플릿 메소드 패턴은 상속을 통해 기능을 확장하게 하는 패턴이고, 구조도 비슷하지만,

팩토리 메소드 패턴은 주로 인터페이스 타입으로 오브젝트를 리턴하므로 서브 클래스에서 정확히 어떤 클래스의 오브젝트를 반환하는 지는 관심이 없고, 오브젝트 생성 방법과 클래스를 서브클래스에서 결정할 수 있도록 정의 해놓은 메소드를 팩토리 메소드라고, 이 방식을 통해 오브젝트 생성 방법을 나머지 로직, 즉 슈퍼 캘르스의 기본 코드에서 독립시키는 방법이다.

과연 상속을 사용한게 답일까?

→ 간단해보이고 사용하기도 편리하게 느껴지지만, UserDao가 다른 목적을 위해 상속을 사용하고 있다면?

**자바는 클래스의 다중상속을 허용하지 않는다.** 단지 커넥션 객체를 가져오는 방법을 분리하기 위해 상속구조로 만들어 버리면 다른 목적으로 UserDao에 상속을 적용하기 힘들다.

**상속을 통한 상하위 클래스의 관계는 생각보다 밀접하다.** 

상속관계는 두 가지 다른 관심사에 대해 긴밀한 결합을 허용한다. 서브 클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다. (ex. super, super(); 그래서 슈퍼클래스 내부의 변경이 있을 때 모든 서브클래스를 함께 수정하거나 다시 개발할 필요도 있다.

## 1.3 DAO의 확장

### 1.3.1 클래스의 분리

이젠 상속이 아닌 완전히 독립적인 클래스로 만들어 보자.

![image.png](image%203.png)

UserDao가 SimpleConnectionMaker를 사용하도록 변경한다.

![image.png](image%204.png)

![image.png](image%205.png)

![image.png](image%206.png)

UserDao에는 new 키워드를 사용해 SimpleConnectionMaker 클래스의 오브젝트를 만들어 두고, add와 get에서 사용하게 하고

SimpleConnectionMaker에는 DB 생성 기능을 담았다.

더이상 상속을 쓰지 않으니 abstract로 제거한 모습이다.

이렇게 분리한게 과연 제대로 동작을 할까?

→ N사와 D사에 공급을 할때 기능을 확장해서 사용하게 했던게 불가능 해졌다.

왜일까?

→ UserDao가 SimmpleConnectionMaker라는 특정 클래스에 종속되어 있기 때문에 상속을 사용했던 것처럼 UserDao 코드의 수정 없이 DB 커넥션 생성 기능을 변경할 방법이 없다.

만약 변경을 해야할 경우 

```java
private SimpleConnectionMaker = new SimpleConnectionMaker();
```

위와 같은 코드를 수정하지 않고는 DB 변경을 바꿀 수 없다.

그럼 상속을 하기 전에 방법처럼 모든 소스코드를 수정해야 하는가?

먼저 문제점부터 확인 해보자.

첫째, SimpleConnecttionMaker의 메소드가 문제다.

makeNewConnection을 사용해 DB 커넥션을 가져오게 했는데, 만약 D 사에서 만든 DB 커넥션 제공 클래스는 openConnection이라는 메소드 이름을 사용했다면 커넥션 가져오는 모든 코드를 다 일일히 수정해야 할 것이다.

두번째, DB 커넥션을 제공하는 클래스가 어떤것인지를 UserDao가 구체적으로 알고 있어야 한다.

UserDao에 SimpleConnectionMaker라는 클래스 타입의 인스턴스 변수까지 정의해놓고 있으니, N 사에서 다른 클래스를 구현하면 어쩔 수 없이 UserDao 자체를 다시 수정해야한다.

UserDao가 SimpleConnectionMaker라는 특정 클래스와 그 코드에 종속적이기때문에 확장에서 자유롭지 못하다.

그럼 어떻게 하면 이를 해결할 수 있을까?

### 1.3.2 인터페이스 도입

가장 좋은 해켤책은 두 개의 클래스가 서로 긴밀하게 연결되어 있지 않도록 중간에 추상적인 느슨한 연결고리를 만들어주는 것이다.

추상화 : 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업이다.

추상화를 위해 자바에서 제공하는 가장 유용한 도구는 바로 **인터페이스**이다,

**인터페이스**는 자신을 구현한 클래스에 대한 구체적인 정보는 모두 감춰버린다.

결국 오브젝틀ㄹ 만들려면 구체적인 클래스 하나를 선택해야겠지만 인터페이스로 추상화해놓은 최소한의 통로를 통해 접근하는 쪽에서는 오브젝트를 만들 때 사용할 클래스가 무엇인지 몰라도 된다.

![image.png](image%207.png)

인터페이스는 어던 일을 하겠다는 기능만 정의해놓은 것이다.

UserDao가 인터페이스를 사용하게 한다면 인터페이스의 메소드를 통해 알 수 있는 기능에만 관심을 가지면 도지, 그 기능을 어떻게 구현했는지에는 관심을 둘 필요가 없다.

![image.png](image%208.png)

위와 같이 ConnectionMaker 인터페이스를 정의하고, DB 커넥션을 가져오는 메소드를 makeConnection()이라고 정했다. 이 인터페이스를 사용하는 UserDao 입장에서는 ConnectionMaker 인터페이스 타입의 오브젝트라면 어떤 클래스로 만들어졌든지 상관없이 makeConnection() 메소드를 호출하기만 하면 Connection 타입의 오브젝트를 만들어서 돌려줄 것이라고 기대할 수 있다.

![image.png](image%209.png)

![image.png](image%2010.png)

이제는 N사와 D사가 DB 접속용 클래스를 다시 만든다고 해도 UserDao의 코드를 뜯어 고칠 일은 없다.

바로 아까전의 첫번째 문제를 해결했다. 그럼 두번째 문제는 어떻게 해결할까?

![image.png](image%2011.png)

초기에 한번 어떤 클래스의 오브젝트를 사용할지를 결정하는 생성자의 코드는 제거되지 않고 남아있다.

### 1.3.3 관계설정 책임의 분리

왜 분리를 했는데도 UserDao가 인터페이스뿐 아니라 구체적인 클래스까지 알아야 할까?

→ 또 다른 관심사항이 존재하기 때문이다.

UserDao와 UserDao가 사용할 ConnectionMaker의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심.

먼저 알아둬야 할 것이 있다.

두 개의 오브젝트가 있고 한 오브젝트가 다른 오브젝트의 기능을 사용한다면, 사용되는 쪽이 사용하는 쪽에게 서비스를 제공하는 셈이다.

사용되는 오브젝트를 서비스, 사용하는 오브젝트를 클라이언트라고 부를수 있다.

그럼 우리 코드로 가서 살펴보자

UserDao의 클라이언트 : UserDao를 사용하는 오브젝트

왜 갑자기?

→ UserDao의 클라이언트 오브젝트가 바로 제 3의 관심사항인 UserDao와 ConnectionMaker 구현 클래스의 관계를 결정해주는 기능을 분리해서 담아두기에 적절한 곳이기 때문이다.

오브젝트 사이의 관계는 런타임 시에 한쪽이 다른 오브젝트의 레퍼런스를 갖고 있는 방식으로 만들어진다.

예를 들면 다음 코드는 DConnectionMaker의 오브젝트의 레퍼런스를 UserDao의 connectionMaker 변수에 넣어서 사용하게 함으로써, 두개의 오브젝트가 ‘사용’이라는 관계를 맺게 해준다.

![image.png](image%2011.png)

오브젝트 사이의 관계가 만들어지려면 생성자를 호출해서 직접 오브젝트를 만드는 방법도 존재하고

외부에서 만들어준 것을 가져오는 방법도 있다.

외부에서 만든 오브젝트를 전달받으려면 메소드 파라미터나 생성자 파라미터를 이용하면 된다.

![image.png](image%2012.png)

인터페이스를 사용했음에도 불구하고 UserDao와 DConnectionMaker사이의 직접적인 관계가 있다는 사실.

만약에 UserDao가 NConnectionMaker를 사용하게 하려면 UserDao의 코드를 뜯어고쳐서 이번에는 NConnectionMaker와 관계를 맺도록 만들어야 한다.

따라서 UserDao의 모든 코드는 ConnectionMaker 인터페이스 외에는 어떤 클래스와도 관계를 가져서는 안되게 해야한다.

물론 UserDao 오브젝트가 동작하려면 특정 클래스의 오브젝트와 관계를 맺어야한다.

하지만 클래스 사이에 관계가 만들어진 것은 아니고, 단지 오브젝트 사이에 다이내믹한 관계가 만들어 지는 것이다.

클래스 사이의 관계는 코드에 다른 클래스의 이름이 나타나기 때문에 만들어 지는것이다. 하지만 오브젝트 사이의 관계는 그렇지 않다. 코드에서는 특정 클래스를 전혀 알지 못하더라도 해당 클래스가 구현한 인터페이스를 사용했다면, 그 클래스의 오브젝트를 인터페이스 타입으로 받아서 사용 가능하다.

객체지향의 다형성 이라는 특징 때문이다.

![image.png](image%2013.png)

런타임 시점의 오브젝트간 관계를 보여주는 오브젝트 다이어그램이다.

![image.png](image%2014.png)

DConnectionMaker를 사라지게하고 ConnectionMaker의 구현 클래스를 클라이언트인 UserDaoTest에 떠넘겼다.

UserDaoTest는 이제 UserDao와 ConnectionMaker 구현 클래스와의 런타임 오브젝트 의존관계를 설정하는 책임을 담당해야한다.

![image.png](image%2015.png)

UserDao의 생성자 파라미터에 ConnectionMaker를 받게해 두 개의 오브젝트를 연결해준다.

이로써 UserDao에는 전혀 손을 대지 않고도 모든 고객이 만족스럽게 DB 연결 기능을 확장해서 사용할 수 있게 됐다.

![image.png](image%2016.png)

### 1.3.4

객체지향 설계 원칙 (SOLID)

SRP : 단일 책임 원칙

OCP : 개방 폐쇄 원칙

LSP : 리스코프 치환 원칙

ISP : 인터페이스 분리 원칙

DIP : 의존관계 역전 원칙

우리가 지금까지 해왔던걸 개방 폐쇄 원칙을 이용하면 리팩토링 작업의 특징과 최정적으로 설계와 코드의 장점이 무엇인지 효과적으로 설명할 수 있다.

개방 폐쇄 원칙 : 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.

또한 높은 응집도와 낮은 결합도라는 고전적인 원리로도 설명이 가능하다.

응집도가 높다 : 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다는 뜻이다.

→ 변화가 일어날 때 해당 모듈의 많은 부분이 함께 바뀐다면 응집도가 높다.

결합도가 낮다 : 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도가 낮다.

ex) ConnectionMaker의 클래스를 결정하는 책임을 클라이언트 오브젝트에 넘김

전략 패턴: UserDaoTest-UserDao-ConnectionMaker 구조의 다지인 패턴을 전략 패턴에 해당한다고 볼수있다.

전략 패턴은 자신의 기능 맥락에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 외부로 분리시키고, 이를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있게 하는 디자인 패턴이다.

여기서 말하는 알고리즘은 독립적인 책임으로 분리가 가능한 기능을 뜻한다.

UserDao는 전략 패턴의 컨텍스트에 해당하고, 변경 가능한, DB 연결 방식이라는 알고리즘을 ConnectionMaker라는 인터페이스를 정의하고, 이를 구현한 클래스, 즉 전략을 바꿔가면서 사용할 수 있게 분리했다.

## 1.4 제어의 역전 (IoC)

IoC는 Inversion of Control의 약자다.

ConnectionMaker의 구현 클래스를 담당하던 UserDaoTest는 본래의 기능은 UserDao를 테스트 하는 기능에서 책임이 추가 되었다.

그러니 이것도 분리해보자.

### 1.4.1 오브젝트 팩토리

팩토리 : 객체의 생성 방법을 결정하고 그렇게 만들어진 오브젝트를 돌려주는 오브젝트

![image.png](image%2017.png)

![image.png](image%2018.png)

이렇게 생성책임을 팩토리 클래스에 넘겼다.

UserDaoTest는 정말 기능이 제대로 동작하는지에 관심이 있고, DaoFactory는 UserDao와 ConnectionMaker사이의 관계를 맺어주는것에 관심을 두게끔 분리 하였다.

![image.png](image%2019.png)

이제 분석해보자

UserDao와 ConnectionMaker는 각각 애플리케이션의 핵심적인 데이터 로직과 기술 로직을 담당하고 있고, DaoFactory는 이런 애플리케이션의 오브젝트들을 구성하고 그 관계를 정의하는 책임을 맡고있다.

DaoFactory는 애플리케이션을 구성하는 컴포넌트의 구조와 관계를 정의한 설계도 같은 역할을 할 수있다.

### 1.4.2 오브젝트 팩토리의 활용

![image.png](image%2020.png)

만약 계좌를 담당하는 Dao와 메세지를 담당하는 Dao를 다시 만들어서 그걸 D사에서 쓴다면?

ConnectionMaker 구현 클래스의 인스턴스를 만드는 부분이 반복돼서 나타난다. 이렇게 오브젝트 생성 코드가 중복되는건 좋지 않은 현상이다. DAO가 더 많아지면 ConnectionMaker의 구현클래스를 바꿀때 마다 일일이 수정해야 하기 때문이다.

![image.png](image%2021.png)

중복 문제를 해결하기위해 분리해냈다.

ConnectionMaker의 구현 클래스를 결정하고 오브젝트를 만드는 코드를 별도의 메소드로 뽑아내고 DAO를 생성하는 각 메소드에게 파라미터로 새로 만든 ConnectionMaker 생성용 메소드를 이용하도록 한다.

### 1.4.3 제어권의 이전을 통한 제어관계 역전

제어의 역전이라는 건, 간단히 프로그램의 제어 흐름 구조가 뒤바뀌는 것이라고 설명할 수 있다.

일반적인 프로그램의 흐름은 main()메소드와 같이 프로그램이 시작되는 지점에서 다음에 사용할 오브젝트를 결정하고, 결정한 오브젝트를 생성하고, 만들어진 오브젝트에 있는 메소드를 호출하고, 그 오브젝트 메소드 안에서 다음에 사용할 것을 결정하고 호출하는 식의 작업이 반복된다.

제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다.

제어의 역전에서는 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다. 당연히 생성하지도 않는다. 또 자신도 어떻게 만들어지고 사용되는지를 알 수 없다. 모든 제어 권한을 자신이 아닌 다른 대상에게 위임하기 때문이다.

우리가 했던 템플릿 메소드 패턴을 생각해보자. 추상 userDao를 상속한 서브클래스는 getConnection()을 구현한다. 하지만 이 메소드가 언제 어떻게 사용될지는 자신은 모른다. 서브클래스에서 결정 되는 것이 아니다. 단지 이런 방식으로 DB 커넥션을 만든다는 기능만 구현해놓으면, 슈퍼클래스인 UserDao의 템플릿 메소드인 add(), get()등에서 필요할 때 호출되어 사용하는 것이다. 즉 제어권을 상위 템플릿 메소드에 넘기고 자신은 호출되어 사용되도록 한다는 제어의 역전 개념이 사용되는 패턴이라고 볼 수 있다.

## 1.5 스프링의 IoC

스프링에서는 스프링이 제어권을 가지고 직접 만들과 관계를 부여하는 오브젝트를 빈(bean)이라고 부른다.

오브젝트 단위의 애플리케이션 컴포넌트를 말한다. 동시에 스프링 빈은 스프링 컨테이너가 생성과 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트를 가리키는 말이다.

스프링에서는 빈의 생성과 관계설정 같은 제어를 담당하는 IoC 오브젝트를 빈 팩토리라고 부른다.

보통 빈 팩토리보다는 이를 좀 더 확장한 **애플리케이션 컨텍스트**를 주로 사용한다.

애플리케이션 컨텍스트는 IoC 방식을 따라 만들어진 일종의 빈 팩토리라고 생각하면 되고, 별도의 정보를 참고해서 빈(오브젝트)의 생성, 관계설정 등의 제어 작업을 총괄한다.

스프링이 빈 팩토리를 위한 오브젝트 설정을 담당하는 클래스라고 인식할 수 있도록 @Configuration이라는 어노테이션을 추가한다.

그리고 오브젝트를 만들어주는 메소드에는 @Bean을 붙인다.

![image.png](image%2022.png)

![image.png](image%2023.png)

![image.png](image%2024.png)

DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 UserDaoTest에 구현했다.

getBean() 메소드는 ApplicationContext가 관리하는 오브젝트를 요청하는 메소드다. 

userDao() 메소드를 호출해서 그 결과를 가져온다고 생각하면 된다.

getBean()은 기본적으로 Object 타입으로 리턴하게 되어 있어서 매번 리턴되는 오브젝트에 다시 캐스팅을 해줘야 한다. → 제네릭 메소드 방식을 사용하면 해결 가능

그런데 굳이 스프링을 사용해 IoC를 적용했다고 해서 별로 장점이 없지 않을까?

그냥 DaoFactory같은 오브젝트 팩토리를 만들어서 사용하면 되는게 아닐까 라는 궁금점이 들 수 있다.

### 1.5.2 애플리케이션 컨텍스트의 동작 방식

![image.png](image%2025.png)

오브젝트 팩토리 == 스프링의 애플리케이션 컨텍스트

ApplicationContext는 ApplicationContext 인터페이스를 구현하는데, ApplicationContext는 빈 팩토리가 구현하는 BeanFactory 인터페이스를 상속했으므로 애플맅케이션 컨텍스트는 일종의 빈 팩토리이다.

DaoFactory는 UserDao를 비롯한 DAO 오브젝트를 생성하고  DB 생성 오브젝트와 관계를 맺어주는 제한적인 역할을 하는데 반해, 애플리케이션 컨텍스트는 애플리케이션에서 IoC를 적용해서 관리할 모든 오브젝트에 대한 생성과 관계설정을 담당한다.

대신 ApplicationContext에는 DaoFactory와 달리 직접 오브젝트를 생성하고 관계를 맺어주는 코드가 없고,

그런 생성 정보와 연관관계 정보를 별도의 설정정보를 통해 얻는다. 때로는 외부의 오브젝트 팩토리에 그 작업을 위임하고 그 결과를 가져다가 사용하기도 한다.

애플리케이션 컨텍스트를 얻을 수 있는 장점은 다음과 같다.

1. 클라이언트는 구체적인 팩토리 클래스를 알 필요가 없다.
2. 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
3. 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.

종합 IoC 서비스란? 

→ 단지 오브젝트 생성과 다른 오브젝트와의 관계 설정만이 아닌 오브젝트가 만들어지는 방식, 시점과 전략을 다르게 가져갈수있고, 이에 부가적으로 자동생성, 오브젝트에 대한 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 오브젝트를 효과적으로 활용할 수있는 다양한 기능을 제공 또, 빈이 사용할 수 있는 기반기술 서비스나 외부 시스템광의 연동 등을 컨테이너 차원에서 제공해주기도 한다.

## 1.5.3 스프링 IoC의 용어 정리

### 빈

빈 또는 빈 오브젝트는 스프링이 IoC 방식으로 관리하는 오브젝트라는 뜻이다. 관리되는 오브젝트(managed object)라고 부르디고 한다. 주의할 점은 스프링을 사용하는 애플리케이션에서 만들어지는 모든 오브젝트가 다 빈은 아니라는 사실이다. 그중에서 스프링이 직접 그 생성과 제어를 담당하는 오브젝트만을 빈이라고 부른다.

### 빈 팩토리

스프링의 IoC를 담당하는 핵심 컨테이너를 가리킨다. 빈을 등록하고, 생성하고, 조회하고 돌려주고, 그 외에 부가적인 빈을 관리하는 기능을 담당한다. 보통은 이 빈 팩토리를 바로 사용하지 않고 이를 확장한 애플리케이션 컨텍스트를 이용한다. 

### 애플리케이션 컨텍스트

빈 팩토리를 확장한 IoC 컨테이너다. 빈을 등록하고 관리하는 기본적인 긴응은 빈 팩토리와 동일하다. 여기에 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.

빈 팩토리라고 부를 때는 주로 빈의 생성과 제어의 관점에서 얘기하는 것이고, 애플리케이션 컨텍스트라고 할 때는 스프링이 제공하는 애플리케이션 지원 기능을 모두 포함해서 이야기하는 것이라고 보면 된다. 스프링에서는 애플리케이션 컨텍스트라는 용어보다 빈 팩토리보다 더 많이 사용한다.

### 설정정보/ 설정 메타 정보

스프링의 설정정보란 Application Context 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보를 말한다. Configuration. 실제로 스프링의 설정정보는 컨테이너에 어떤 기능을 세팅하거나 조정하는 경우에도 사용하지만, 그보다는 IoC 컨테이너에 의해 관리되는 애플리케이션 오브젝트를 생성하고 구성할 때 사용된다.

### 컨테이너 또는 IoC 컨테이너

IoC 방식으로 빈을 관리한다는 의미에서 Application Context나 빈 팩토리를 컨테이너 또는 IoC 컨테이너라고도 한다. 후자는 주로 빈 팩토리의 관점에서 이야기하는 것이고, 그냥 컨테이너 또는 스프링 컨테이너라고 할 때는 Application Context를 가리키는 것이라고 보면 된다.

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

![image.png](image%2026.png)

DaoFactory를 직접 사용한느것과 @Configuration 어노테이션을 추가해서 스프링의 Application Context를 통해 사용하는 것은 동일한 것 같다.

그런데 정말 차이점이 없을까?

위 코드를 통해 우리가 확인해보고 싶은건 여러번 호출했을 때마다 동일한 오브젝트가 돌아오는가 아닌가이다.

여기서 중요한건 오브젝트의 동일성과 동등성이다.

두개의 오브젝트가 완전히 같은것을 동일한 오브젝트이고, 동일한 정보를 담고있는건 동등한 오브젝트이다.

동일하다면 한개의 오브젝트에 두개의 오브젝트 참조값을 가지고있는것이고, 동등한 경우에는 두개의 오브젝트가 각기 다른 메모리에상에 존재하는 것이다.

위 코드를 출력해보면

![image.png](image%2027.png)

위와 같이 새로운 오브젝트가 생겼다는 사실을 알 수 있다.

계속 호출 될때마다 새로운 오브젝트가 생겨나는 것이다.

반대로 스프링의 Application Context를 사용한 결과를 보자

![image.png](image%2028.png)

![image.png](image%2029.png)

두 오브젝트의 출력 값이 같으므로, getBean()을 두 번 호출해서 가져온 오브젝트가 동일하다는 사실을 알 수 있다.

여기서 알수있는건 스프링은 여러 번에 걸쳐 빈을 요청하더라도 매번 동일한 오브젝트를 돌려준다는 것이다.

왜 그럴까?

### 1.6.1 싱글톤 레지스트리로서의 Application Context

Application Context는 우리가 만들었던 오브젝트 팩토리와 비슷한 방식으로 동작하는 IoC컨테이너다. 그러면서 동시에 이 애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이기도 하다.

스프링은 기본적으로 별다른 설정을 하지 않으면 내부에서 생성하는 빈 오브젝트를 모두 싱글톤으로 만든다. 여기서 싱글톤이라는 것은 디자인 패턴에서 나오는 싱글톤 패턴과 비슷한 개념이지만 그 구현 방법은 확연히 다르다.

왜 스프링은 싱글톤으로 만드는 것일까?

매번 클라리언트에서 요청이 올때마다 각 로직을 담당하는 오브젝트를 새로 만들어서 사용한다고 생각해보자. 요청 한번에 5개의 오브젝트가 새로 만들어지고 초당 500개의 요청이 들어오면 초당 2500개의 오브젝트가 새롭게 생성된다. 이렇게 부하가 걸리면 서버가 감당하기 힘들다.

엔터프라이즈 분야에서는 서비스 오브젝트라는 개념을 일찍부터 사용해왔다.

서블릿은 자바 엔터프라이즈 기술의 가장 기본이 되는 서비스 오브젝트라고 할 수있다. 서블릿은 대부분 멀티스레드 환경에서 싱글톤으로 동작한다. 서블릿 클래스당 하나의 오브젝트만 만들어 두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다.

싱글톤 패턴의 구현 방식에는 다음과 같은 문제가 있다.

1. private 생성자를 갖고 있기 때문에 상속할 수 없다.
2. 싱글톤은 테스트하기가 힘들다.
3. 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
4. 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못한다.

스프링은 서버환경에서 싱글톤이 만들어져서 서비스 오브젝트 방식으로 사용되는 것은 적극 지지한다. 스프링은 직접 싱글톤 형태의 오브젝트를 만들고 관리하는 기능을 제공한다. 그것이 바로 **싱글톤 레지스트리**다.

스프링 컨테이너는 싱글톤을 생성하고, 관리하고, 공급하는 싱글톤 관리 컨테이너이기도 하다. 싱글톤 레지스트리의 장점은 스태틱 메소드와 private 생성자를 사용해야 하는 비정상적인 클래스가 아니라 평범한 자바 클래스를 싱글톤으로 활용하게 해준다는 점이다. 평범한 자바 클래스라도 IoC 방식의 컨테이너를 사용해서 생성과 관계 설정, 사용 등에 대한 제어권을 컨테이너에게 넘기면 쉽게 싱글톤 방식으로 만들어져 관리되게 할 수 있다. 오브젝트 생성에 관한 모든 권한은 IoC 기능을 제공하는 애플리케이션 컨텍스트에 있기 때문이다.

스프링의 싱글톤 레지스트리 덕분에 싱글톤 방식으로 사용될 애플리케이션 클래스라도 public 생성자를 가질 수 있다.

### 1.6.2 싱글톤과 오브젝트의 상태

싱글톤은 멀티스레드 환경이라면 여러 스레드가 동시에 접근해서 사용할 수 있다.

기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 오브젝트로 사영되는 경우에는 상태정보를 내부에 갖고 있지 않은 무상태 방식으로 만들어 져야한다.

### 1.6.3 스프링 빈의 스코프

스프링이 관리하는 오브젝트, 즉 빈이 생성되고, 존재하고, 적용되는 범위를 빈의 스코프라고 한다.

스프링 빈의 기본 스코프는 싱글톤이다. 싱글톤 스코프는 컨테이너 내에 한 개의 오브젝트만 만들어져서, 강제로 제거하지 않는 한 스프링 컨테이너가 존재하는 동안 계속 유지된다.

## 1.7 의존관계 주입

### 1.7.1 제어의 역전(IoC)과 의존관계 주입

IoC가 매우 느슨하게 정의돼서 폭넓게 사용되는 용어다. 때문에 스프링을 IoC 컨테이너라고만 해서는 스프링이 제공하는 기능의 특징을 명확하게 설명하지 못한다.

스프링이 제공하는 IoC 방식을 핵심을 짚어주는 DI(Dependency Injection)이라는 좀 더 의도가 명확히 드러나는 이름을 사용하기 시작했다. 

DI?

DI는 의존성 주입이다. 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 오브젝트와 다이내믹하게 의존관계가 만들어지는 것이 핵심이다.

![image.png](image%2030.png)

의존이란 무엇인가? B가 변하면 그것이 A에게 옇양을 미친다는 뜻이다.

의존 관계에는 방향성이 있다. A가 B에 의존하고 있지만, B는 A에게 의존하지 않는다. 의존하지 않는다는 말은 B는 A의 변화에 영향을 받지 않는다는 뜻이다.

![image.png](image%2031.png)

UserDao는 DConnectionMaker라는 클래스의 존재도 알지 못한다.

UserDao는 DConnectionMaker 클래스에 의존하지 않기 때문이다.

의존관계 주입은 이렇게 구체적인 의존 오브젝트와 그것을 사용할 주체, 보통 클라이언트라고 부르는 오브젝트를 런타임 시에 연결해주는 작업을 말한다. UserDao는 ConnectionMaker 인터페이스라는 매우 단순한 조건만 만족하면 어떤 클래스로부터 만들어졌든 상관없이 오브젝트를 받아들이고 사용한다.

정리하면 의존관계 주입이란 다음과 같은 세 가지 조건을 충족하는 작업을 말한다.

- 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존하고 있어야 한다.
- 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
- 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로서 만들어진다.

의존관계 주입의 핵심은 설계 시점에는 알지 못했던 두 오브젝트의 관계를 맺도록 도와주는 제3의 존재가 있다는 것이다.

DI에서 말하는 제3의 존재는 바로 관계설정 책임을 가진 코드를 분리해서 만들어진 오브젝트라고 볼 수 있다.

DaoFactory, 스프링의 Application Context, 빈 팩토리, IoC 컨테이너 등이 모두 외부에서 오브젝트 사잉의 런타임 관계를 맺어주는 책임을 지닌 제 3의 존재라고 볼수있다.

![image.png](image%2032.png)

![image.png](image%2033.png)

### 1.7.3 의존관계 검색과 주입

스프링이 제공하는 IoC 방법에는 의존관계 주입만 있는 것이 아니다.

의존 관계를 맺는 방법이 스스로 검색을 이용한 의존관계 검색이라고 불리는 것도 있다.

의존관계 검색은 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.

의존관계 검색은 기존 의존관계 주입의 거의 모든 장점을 갖고 있다.

단 하나의 차이점이라면 의존 관계 검색 방식에서는 검색하는 오브젝트는 자신이 스프링의 빈일 필요가 없다는 점이다.

반면 의존관계 주입에서는 DI를 원하는 오브젝트는 먼저 자신이 컨테이너가 관리하는 빈이 돼야 한다는 사실을 잊지 말자.

### 1.7.4 의존관계 주입의 응용

기능 구현의 교환

UserDao가 ConnectionMaker라는 인터페이스에만 의존하고 있다는건 ConnectionMaker를 구현하기만 하고 있다면 어떤 오브젝트든지 사용할 수 있다는 뜻이다.

![image.png](image%2034.png)

![image.png](image%2035.png)

이런식으로 딱 한줄로 로컬과 운영용 DB로 나눠서 연결할수있다.

DI의 설정정보에 해당하는 DaoFactory만 다르게 만들어두면 나머지 코드에는 전혀 손대지 않고 개발 시와 운영 시에 각각 다른 런타임 오브젝트에 의존관계를 갖게 해줘서 문제를 해결 가능하다.

부가 기능 추가

DB 연결 카운팅 횟수를 세고자 한다면

![image.png](image%2036.png)

![image.png](image%2037.png)

중간에 이런식으로 의존관계를 맺어준다면  가능하다.

![image.png](image%2038.png)

### 1.7.5 메소드를 이용한 의존 관계 주입

지금까지는 생성자를 이용해 의존관계 주입을 했다.

하지만 반드시 생성자를 사용해서 의존관계를 주입할 필요는 없다.

**수정자 메소드를 이용한 주입**

수정자(setter) 메소드는 외부에서 오브젝트 내부의 속성 값을 변경하려는 용도로 사용된다.

수정자 메소드의 핵심기능은 파라미터로 전달된 값을 보통 내부의 인스턴스 변수에 저장하는 것이다. 부가적으로, 입력 값에 대한 검증이나 그 밖의 작업을 수행할 수도 있다. 수정자 메소드는 외부로부터 제공받은 오브젝트 레퍼런스를 저장해뒀다가 내부의 메소드에서 사용하게 하는 DI방식에서 활용하기에 적당하다.

**일반 메소드를 이용한 주입**

수정자 메소드 처럼 set으로 시작해야 하고 한 번에 한 개의 파라미터만 가질 수 있다는 제약이 싫다면 여러 개의 파라미터를 갖는 일반 메소드를 DI용으로 사용할 수도 있다.

![image.png](image%2039.png)

![image.png](image%2040.png)