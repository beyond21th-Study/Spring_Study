# 1장 오브젝트와 의존관계

## 스프링을 이해하기 위해서는 오브젝트에 깊은 관심을 가져야한다.

애플리케이션에서 오브젝트가 생성되고 다른 오브젝트와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정을 진지하게 생각해봐야 한다.

## 1.1 초난감 DAO

### 1.1.1 User

```java
public class User {
    String id;
    String name;
    String password;
    
    getter/ setter 등등
}
```

사용자 정보를 저장하는 자바빈 규약을 따르는 오브젝트

### 1.1.2 UserDAO

DAO 란 Data Access Object의 약자로 DB를 사용해 데이터를 조작하기 위해 만든 오브젝트를 의미한다.

```java
package springbook.user.dao;

import springbook.user.domain.User;

import java.sql.*;

public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

위 예시는 사용자를 생성하고, 아이디를 가지고 사용자 정보를 읽어오는 한개의 메소드를 만든 것이다.

이 코드가 정말 제대로 동작하는지 어떻게 확인할 수 있을까?

### 1.1.3 main()을 이용한 테스트 코드

```java
public static void main(String[] args) throws SQLException, ClassNotFoundException {
  UserDao dao = new UserDao();

  User user = new User();
  user.setId("sasca");
  user.setName("jalgayo");
  user.setPassword("jalgayo");

  dao.add(user);
  System.out.println(user.getId() +" 등록 성공");

  User user2 = dao.get(user.getId());
  System.out.println(user2.getName());
  System.out.println(user2.getPassword());

  System.out.println(user2.getId() +" 조회 성공");

}
```

위 예시 코드를 실행해서 잘 동작한다면, 등록과 조회가 잘 될것이다.

그런데 지금 만든 UserDao 클래스 코드에는 사실 여러가지 문제가 있다.

이를 객체지향 기술의 원리에 충실한 멋진 스프링 스타일의 코드로 개선해보면서 의문을 던져본다.

왜 이 코드에 문제가 많다고 하는지? 잘 동작하는 코드를 굳이 수정하고 개선을 왜 해야하는지? 등등 다양한 의문이 들텐데 이는 다음 챕터에서 설명하겠다.

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

개발자가 객체를 설계할때 가장 염두에 둬야 할 사항은 바로 미래의 변화를 어떻게 대비해야할 것인가이다.

왜? 이러한 고민을 하는것인가에 대한건 사용자의 비즈니스 프로세스와 그에 따른 요구사항이 끊임없이 바뀌고 발전하면서 변경에 대한 변화가 갑자기 발생할 수 있다.

→ 어떻게 대응 하는가?

분리와 확장을 고려한 설계로 필요한 작업을 최소화 할 수 있다.

관심사에 대한 분리 : 관심이 같은 것 끼리는 하나의 객체 안으로 또는 친한 객체로 모이게 하고, 관심이 다른 것은 가능한 한 따로 떨어져서 서로 영향을 주지 않도록 분리하는 것.
처음에는 모든 것을 뭉뚱그려서 한데 모으는 편이 쉽고 편하지만, 언젠가는 그 뭉쳐 있는 여러 종류의 관심사를 적절하게 구분하고 따로 분리하는 작업을 해줘야만 할때가 온다. 관심사가 같은 것끼리 모으고 다른 것은 분리해줌으로써 같은 관심에 효과적으로 집중할 수 있게 만들어 준다.

### 1.2.2 커넥션 만들기의 추출

```java
public class UserDao {

    public void add(User user) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("insert into users(id, name, password) values(?, ?, ?)");
        ps.setString(1, user.getId());
        ps.setString(2, user.getName());
        ps.setString(3, user.getPassword());

        ps.executeUpdate();

        ps.close();
        c.close();
    }

    public User get(String id) throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        Connection c = DriverManager.getConnection("jdbc:mysql://localhost/tobi", "root", "");
        PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
        ps.setString(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();
        User user = new User();
        user.setId(rs.getString("id"));
        user.setName(rs.getString("name"));
        user.setPassword(rs.getString("password"));

        rs.close();
        ps.close();
        c.close();

        return user;
    }
}
```

```java
public class UserDao{
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    
    private Connection getConnection() throws ...{
        Class.forName(...)
        Connection c = Driver...
        return c;
    }
}
```

왼쪽 코드와 오른쪽 코드의 차이점이 보이는가?

UserDao의 관심사항으로는

첫째, DB와 연결을 위한 커넥션을 어떻게 가져올까라는 **관심**이다. ( 어떤 드라이버?, 어떤 로그인 정보? 등등)

둘째, DB에 보낼 SQL Statement를 만들고 **실행** 시키는것.

셋째, 작업이 끝나면 사용한 리소스인 Statement와 Connection 오브젝트를 닫아줘 소중한 공유 리소스를 시스템에 **돌려**주는 것이다.

왼쪽 코드에서 가장 문제되는것은 Connection 오브젝트를 가져오는 부분이다. DB 커넥션을 가져오는 부분에서는 다른 관심사와 섞여서 같은 add() 메소드에 담겨있고, 이 코드 또한 get() 메소드안에도 **중복**되어 있다는 점이다.

만약 이 코드를 확장시켜 다른 추가 메소드 (ex, 삭제와 관련된 delete메소드 추가)를 작성한다면 Connection코드가 중복되어 나타날 것이다.

이렇게 하나의 관심사가 중복되어 있고, 여기저기 흩어져서 다른 관심의 대상과 얽혀있으면, 변경이 일어날 때 엄청난 고통을 일으키는 원인이 되어 스파게티 코드가 된다.

오른쪽의 코드는 Connection과 관련된 부분을 각 메소드에서 떼어내 메소드를 만들고 add()와 get()에서는 이 커넥션 객체를 가져오는 방식으로 중복을 제거하였다.

만약 DB의 종류와 접속 부분이 바뀌어서 드라이버 클래스와 URL이 바뀌었을 경우 Connection을 수정하는 부분만 변경하면 되기때문에 다른 메소드에 영향을 주지 않고, 관심 내용이 독립적으로 존재하므로 수정이 간단해졌다.

이런 작업을 **리팩토링**이라고 한다. 또한 위해서 중복된 코드를 뽑아내는 것을 리팩토링에서는 **메소드 추출 기법**이라고 부른다.

리팩토링 : 기존의 코드를 외부의 동작방식에서는 변화 없이 내부 구조를 변경해서 재구성하는 작업 또는 기술을 말한다. 코드의 내부 설계가 개선되어 이해하기 편해지고, 변화에 효율적으로 대응할 수있다는 장점이 있다. 생산성 증대, 코드의 품질 향상, 유지보수 용이, 견고하면서 유연한 제품을 개발할 수 있다.

### 1.2.3 DB 커넥션 만들기의 독립

만약 UserDao를 사용하는 기업이 N사와 D사에 납품한다고 가정해보자

N사와 D사 모두 각기 다른 종류의 DB를 사용하고 있고, DB 커넥션을 가져오는 데 있어 독자적으로 만든 방법을 적용하고 싶다?

→ 어떻게 하면 소스코드 제공 없이 N사와 D사에 제공해주지 않고도 고객 스스로 원하는 DB 커넥션 생성 방식을 적용할 수 있을까?

**상속에 의한 확장**

UserDao에서 메소드의 구현코드를 제거하고 getConnection을 추상 메소드로 만들어 놓는다.

```java
public class UserDao{
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    
    private Connection getConnection() throws ...{
        Class.forName(...)
        Connection c = Driver...
        return c;
    }
}
```

```java
public abstract class UserDao {
    public void add(User user) throws ClassNotFoundException...{
        Connection c = getConnection();
        ...
    }
    
    public User get(String id) throws ...{
        Connection c = getConnection();
    }
    public abstract Connection getConnection() throws ... ;
}

```

추상 메소드는 메소드 코드는 없지만 메소드 자체는 존재한다. 따라서 add()와 get() 메소드에서 원하는 코드를 유지할 수 있다.

이 추상 클래스인 UserDao를 N사와 D사에게 판매를 하고, 구입한 회사에서는 이 클래스를 상속받아 NUserDao와 DUserDao라는 서브 클래스를 만들고 그들이 원하는 요구사항에 맞춰 확장 하도록 하면 UserDao의 기능과 함께 사용할 수 있다.

기존에는 같은 클래스에 다른 메소드로 분리됐던 DB 커넥션 연결이라는 관심을 상속을 통한 서브클래스로 분리해버리는 것이다.

![image.png](image.png)

![image.png](image%201.png)

DAO의 핵심 기능인 어떻게 데이터를 등록하고 가져올 것인가라는 관심을 담당하는 UserDao와, DB 연결 방법을 어떻게 할 것인가라는 관심을 담고 있는 NUserDao, DUserDao가 클래스 레벨로 구분되고 있다.

UserDao는 변경이 용이하다라는 수준을 넘어서 손쉽게 확장된다고 한다,

위와 같이 슈퍼클래스(UserDao)에 기본적인 로직의 흐름(커넥션 가져오기, SQL 생성, 실행, 반환)을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected(public 에서 전체만 빠진 부분) 메소드 등으로 만든 뒤 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하도록 하는 방법을 디자인 패턴에서 **템플릿 메소드 패턴**이라고 한다.

![image.png](image%202.png)

UserDao의 getConnection 메소드는 Connection 타입 오브젝트를 생성한다는 기능을 정의해놓은 추상 메소드다. UserDao의 서브클래스의 getConnection() 메소드는 어떤 Connection 클래스의 오브젝트를 어떻게 생성할 것인지를 결정하는 방법이라고 볼 수 있다. 이렇게 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하게 하는 것을 **팩토리 메소드 패턴**이라고 부르기도 한다.

NUserDao와 DUserDao가 모두 같은 종류의 Connection 구현 클래스의 오브젝트를 리턴할 수도 있다.

그래도 오브젝트를 생성하는 방식이 다르다면, 팩토리 메소드 패턴으로 이해할 수 있다.